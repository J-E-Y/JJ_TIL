---
title: __React
date: '2020-01-14'
draft: true
menu:
  tutorial:
    parent: "_section2"
    weight: 2
toc: yes
type: docs
---


## 1. What is "React"??


* 인터렉션이 늘어남에 OR 관리 해야할 Dom 이 많아질수록 관리하기가 힘들어짐
* 프론트 엔드 라이브러리, 프레임웍 많이 있다. 그중에 하나가 React 이다. 





## React ES6




#### 반드시 알아야 할 ES6 문법들


    1) Destructuring(구조 분해)
    2) spread operator(전개 구문)
    3) rest parameters
    4) default parameters(기본 매개변수)
    5) template literals
    6) arrow function(화살표 함수)
    7) for-of loop








1.Destructuring(구조 분해)


> 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식

```js

var a, b, rest;

[a, b] = [10, 20];

console.log(a); //10
console.log(b); //20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(a); //10
console.log(b); //20
console.log(rest); //[30, 40, 50]



({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}

var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2




선언에서 분리한 할당

var a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2



기본값

var a, b;

[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7



변수 값 교환하기

var a = 1, b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1


일부 반환 값 무시하기

function f() {
    return [1, 2, 3];
}

var [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

반환 값을 모두 무시할 수도 있음
[,,] = f();




새로운 변수 이름으로 할당하기

var o = {p: 42, q: true};
var {p: foo, q: bar} = o;
//var foo = 42; // 이것과 동일하다. 
//var bar = true; // 이것과 동일하다. 


//[foo, bar] = [42, true]   같다 왜??



console.log(foo); // 42

console.log(bar); // true

```






2.spread operator(전개 구문)

> 배열이나 문자열과 같이 반복 가능한 문자를 0개 이상의 인수 (함수로 호출할 경우) 또는 요소 (배열 리터럴의 경우)로 확장하여, 0개 이상의 키-값의 쌍으로 객체로 확장시킬 수 있음.

```js

function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

console.log(sum.apply(null, numbers)); //6
console.log(sum(...numbers)); //6
//함수에 배열을 인자로 넣고 싶을 대, apply대신 배열을 전개해서 사용할 수 있다.


구문


myFunction(...iterableObj);


[...iterableObj, '4', 'five', 6];


let obj = {a: 1, b: 2};
let objClone = { ...obj }; //얕은 복사
console.log(objColne); //{a: 1, b: 2}


배열의 연결(concat 대신 사용)


var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = arr1.concat(arr2); //arr1: [0, 1, 2, 3, 4, 5]



var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = [...arr1, ...arr2]; //arr1: [0, 1, 2, 3, 4, 5]





```
3.rest parameters

* 정해지지 않은 수(an indefinite number, 부정수) 인수를 배열로 나타낼 수 있게 함.

```js

function sum(...theArgs) {
  return theArgs.reduce((previous, current) => {
    return previous + current;
  });
}

// 만약 function sum(arguments) 으로 하면 
// sort, map, forEach 또는 pop 같은 메서드 가 되지 않는다. 

console.log(sum(1, 2, 3)); //6
console.log(sum(1, 2, 3, 4)); //10


Rest 파라미터와 arguments 객체간의 차이

`Rest 파라미터`는 구분된 이름(예, 함수 표현에 정식으로 정의된 것)이 주어지지 않은 유일한 대상인 반면, arguments 객체는 함수로 전달된 모든 인수를 포함합니다.

`arguments 객체`는 실제 배열이 아니고 rest 파라미터는 Array 인스턴스로, sort, map, forEach 또는 pop 같은 메서드가 바로 인스턴스에 적용될 수 있음을 뜻합니다.
즉 arguments 객체는 자체에 특정 추가 기능이 있습니다 (callee 속성처럼).


Rest 파라미터 해체

function f(...[a, b, c]) {
  return a + b + c;
}

f(1)// NaN  (b 와 c 가 undefined)
f(1,2)// NaN  ( c 가 undefined)
f(1, 2, 3)    // 6
f(1, 2, 3, 4) // 6 (4번 째 파라미터는 해체되지 않음)

```
4.default parameters(기본 매개변수)

> 기본 함수 매개변수(default function parameter)를 사용하면 값이 없거나 undefined가 전달될 경우 매개변수를 기본값으로 초기화할 수 있음.

```js



function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5, 2)); //10  
console.log(multiply(5)); //5 // 5 * 1



```
5.template literals

> 내장된 표현식을 허용하는 문자열 리터럴입니다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있습니다. 이전 버전의 ES2015사양 명세에서는 "template strings" (템플릿 문자열) 라고 불려 왔습니다.

```js

var text = `hello`;
console.log(`text: ${text}, type: ${typeof text}`);
//text: hello, type: string

```
6.arrow function(화살표 함수)

> 화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다. 화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.

` 화살표 함수는 항상 익명입니다. `


```js
var materials = [
  'Hydrogen',
  'Helium',
  'Lithium',
  'Beryllium'
];



materials.map(value => value.length);
// //Array [8, 6, 7, 9]

```


7.for-of loop


> for...of 명령문은 반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복하고 각 개별 속성값에 대해 실행되는 문이 있는 사용자 정의 반복 후크를 호출하는 루프를 생성합니다.


```js


const array1 = ['a', 'b', 'c'];

for (const element of array1) {
  console.log(element);
}
// expected output: "a"
// expected output: "b"
// expected output: "c"

Map의 대한 반복문

인스턴스의 키와 value 값을 가져온다. 

let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);

for (let entry of iterable) {
  console.log(entry);
}
// [a, 1]
// [b, 2]
// [c, 3]

 인스턴스에 value값을 가져온다. 

for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3




```





## JSX

JSX 란?

* 자바 스크립트의 확장 문법

* 반드시 하나의 엘리먼트로 감싸야 한다.

* 자바스크립트 코드를 적용할 땐 { } 안에 작성한다.

* JSX 내부에선 if문을 사용할 수 없다. IIFE or 삼항연산자 사용

* 엘리먼트의 클래스 이름을 적용할 때, className 을 사용(class는 ES6에 존재하기 때문)



JSX 객체 표현

> Babel은 JSX를 React.createElement() 호출로 컴파일합니다.

* 아래 두 예제는 동일합니다.

```

// 
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);


const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);

```

React.createElement() 는 버그 없는 코드를 작성하는 데 도움을 주는 몇가지 체크를 하지만 기본적으로는 아래와 같은 객체를 생성합니다.

```js


// Note: this structure is simplified
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  }
};

```

이 객체는 `“React elements”` 부릅니다. 화면에서 볼 수 있는 내용에 대한 설명으로 생각할 수 있습니다. React는 이 객체를 읽어들이고 이를 사용하여 DOM을 구성하고 최신 상태로 유지합니다.



























## 1. Data flow

* 부모 컴포넌트에서 자식 컴포넌트로 데이터가 흐름 
* 자식이 부모컴포넌트에 데이터를 줄수 없음

![](/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 1.50.10 PM.png)



## 2. 컴포넌트와 Props


* Props 란?

  * Props: `상위` 컴포넌트가 `하위` 컴포넌트에게 `내려`주는 `데이터(속성)`
  * 단순히 사용만 할 수 있다. 변경할 수 없다.


* 컴포넌트?

  * 개념상 컴포넌트는 자바스크립트 함수와 비슷함. 
  * 임의의 입력 (“props”라고 부르는)을 받아들이고 어떤 게 화면에 나타나야 하는 지를 설명하는 React 요소를 반환함.


* 2-1. 함수형 및 클래스 컴포넌트


> 컴포넌트는 자바스크립트의 함수형 및 클래스형으로 작성할 수 있다.


```js

`아래는 함수형으로 작성한 컴포넌트`


function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
}


`아래는 ES6를 사용해 작성한 컴포넌트`


class Welcome extends React.Component {
    render() {
        return <h1>Hello, {props.name}</h1>;
    }
}


위의 두 컴포넌트는 React 관점에서 보면 동일하지만 ES6의 클래스 기능을 사용한 컴포넌트가 몇가지 기능을 더 가지고 있음.


```




2-2. 컴포넌트 렌더링


* props: React가 유저가 정의한 컴포넌트를 나타내는 요소를 볼 때 JSX 속성을 이 컴포넌트에 단일 객체로 전달하는데, 이 객체를 props라고 부름


`Bable`

```js 



function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Rami" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);

```

![](/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 2.29.59 PM.png)




` 여기서의 props: { name: 'rami' } `
`Welcome(props)`
컴포넌트의 이름은 항상 `대문자`로 시작해야 함.


2-3. 컴포넌트 결합

> 컴포넌트는 출력될 때 다른 컴포넌트를 참조할 수 있습니다. 이를 통해 모든 세부 레벨에서 동일한 컴포넌트 추상화를 사용할 수 있습니다.

```js
//-----------------component-------------------------------
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
//-----------------component-------------------------------
 
function App() {
  return (
    <div>
      <Welcome name="Sara" />  // name="Sara" >>>props
      <Welcome name="Cahal" /> // name="Cahal" >>>props
      <Welcome name="Edite" /> // name="Edite"  >>>props
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);


```


![](/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 2.47.22 PM.png)



2.4 Props는 읽기전용



## 3. State


3-1. State

> 컴포넌트가 갖는 `상태`. `객체의 형태`로 컴포넌트 내에서 보관하고 관리한다.


* 1) `class` 컴포넌트로 작성되어야 한다

> class형식으로 무조건 작성되어야 하한다. 


* 2) 반드시 `setState` 메서드로 값을 변경

> `state의 값을 직접적으로 변경하면 안됨.`

state 값을 변경할때 변경 ( setState 메서드 사용할때 ) ==> `render() 함수`가 실행된다. 

```js

class Foo extends Component{
    state = {
        a: 10,
        b: false
    }
	changeState() {        
        //this.state.a = 100; ~~~~~~!!!~~~!!!  직접 바꾸면 안되고 
        this.setState({     // 이렇게 
            a: 100          // 이렇게 
        })                  // 이렇게  바꿔야 한다. 
    }
}


```


* 3) State 업데이트는 비동기일 수 있다



> React는 여러 setState() 호출을 성능을 위해 단일 업데이트로 배치할 수 있습니다.

> this.props 및 this.state 가 비동기로 업데이트될 수 있기 때문에, 다음 state를 계산할 때 해당 값을 신뢰해서는 안됩니다.

> 예를 들어, 카운터를 업데이트하는 이 코드는 실패할 수 있습니다.




```js

// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});


```

* 이 문제를 해결하기 위해 객체가 아닌 함수를 받는 두 번째 형식의 setState() 를 사용할 수 있습니다.

```js


// Correct
this.setState((prevState, props) => ({
  counter: prevState.counter + props.increment
}));


```


* 4)State Update는 병합됨

> setState() 를 호출할 때, React는 현재 state와 제공한 객체를 병합합니다.

```js

constructor(props) {
    super(props);
    this.state = {
        posts: [],
        comments: []
    };
}

componentDidMount() {
    fetchPosts().then(response => {
      this.setState({
        posts: response.posts
        //여기서의 setState()는 posts만 변경할 뿐 comments는 건드리지 않음.
      });
    });

    fetchComments().then(response => {
      this.setState({
        comments: response.comments
        //여기서의 setState()는 comments만 변경할 뿐 posts는 건드리지 않음.
      });
    });
  }



```



* 5) 데이터는 아래로 흐름

> 부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없습니다.

**State는 props와 비슷하지만 컴포넌트에 의해 완전히 제어되며 private 속성이다.**



## **Life Cycle**


컴포넌트가 브라우저에 보여질 때, 업데이트될 때, 사라질 때 각 단계 전,후로 특정 메서드가 호출된다.

라이프 사이클 이벤트란

React의 컴포너트는 생명주기(Life cycle)을 가진다. 생명주기란 컴포넌트가 생성되고 사용되고 소멸될 때 까지 일련의 과정을 말한다.
이러한 생명주기 안에서는 특정 시점에 자동으로 호출되는 메서드가 있는데, 이를 라이프 사이클 이벤트라고 한다.


![](/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 4.48.31 PM.png)


* 많은 컴포넌트를 가진 어플리케이션에서, 컴포넌트가 제거될 때 리소스를 풀어주는 건 아주 중요한 일

* 컴포넌트가 DOM에 최초로 렌더링 될 때 React에서 이를 “mounting” 이라고 부릅니다.
메서드명은 componentDidMount라고 써야 함.

* DOM에서 컴포넌트를 삭제할 때 React에서 이를 “unmounting” 이라고 부릅니다.
메서드명은 componentWillUnmount이다.


`라이프사이클 훅`


> 컴포넌트가 `마운트` (mount) 되고 `언마운트` (unmount) 될 때 `특정 코드`를 실행하기 위해 컴포넌트 클래스에 특별한 메서드를 선언할 수 있고 이런 메서드들을 “`라이프사이클 훅`” 이라고 부릅니다.

































