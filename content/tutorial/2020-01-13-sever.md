---
title: __Interaction With Server
date: '2020-01-13'
draft: true
menu:
  tutorial:
    parent: "_section2"
    weight: 1
toc: yes
type: docs
---





## 브라우저란?

인터넷 망에서 정보를 감색하는데 사용하는 응용프로그램을 말한다.

* 기능

웹 페이지 열기, 최근 방문한 URL(uniform resource locator) 및 즐겨찾기 제공, 웹페이지 저장 


* 종류

Explorer

fireFox

Chrome

Safari

Opera



## Sever

* 내컴퓨터가 다른컴퓨터에게 정보를 전달하고 공유하게 되면 내컴퓨터는 서버컴퓨터가 되는것이다.

* 어떤 형태의 컴퓨터든 정보제공 역활을 하는 주체이면 ‘서버’컴퓨터로 불릴수 있다. (노트북꾸진것이라도 서버컴퓨터가 될수있다.)

* 예) 맛집에가서 사진을찍고 내컴퓨터에 저장했다 이것을 다른이에게 공유하기위해 다른 컴퓨터들이 내가 저장한 사진에 접근해서 볼수 있도록 하는것이다. 그럼 내컴퓨터는 서버컴퓨터가 되는것이다. 


## API 

`[Application Program Interface]`


프로그램과 또 다른 프로그램을 연결해주는 일종의 `다리`라고 볼 수 있습니다.

서버 자원을 잘 가져다가 쓸수 있게 만들어놓은 `interface` 를 말한다.


`UI`(User Interface)를 먼저 짚고 넘어가려 합니다.

> 아이폰에 홈버튼이 있다. 이것을 누르면 처음화면으로 간다
이홈버튼은 스마트폰안에 있는 내용들을 확일할수 있게 사용자를 이어주는 매개체입니다.


`API`도 같은 맥락이라고 볼 수 있는데요


> 모든각국의 나라 도시의 날씨의 정보가 있는 싸이트가 있다.  그런데 나는 한국의 인천의 날씨를 가져와서 인천사람들에게 이것을 전달하기위해 API 라는 것을 통해 전달할수 있다.

> 이것을 도와주는 중간 `매개체`이다.



get/message 전달하고
post/message 저장한다.



## HTTP :Hypertext Transfer Protocal

* HTTP란

HyperText Transfer Protocol의 약자로 하이퍼텍스트 문서를 교환하기 위하여 사용된 통신 규약이다. 즉, 웹 서버와 클라이언트 간의 통신을 하기 위한 통신 규약이며 HTTP는 1989년 팀 버너스-리에 의해 처음 설계되었다. 

한마디로 클라이언트와 서버간에 통신을 위해 만들어진 규칙이 HTTP 를 주소창에 적고 그다음 URL 주소를 넣어 통신을 하게 만든다.



* HTTP의 동작

HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다. 이러한 단점을 해결하기 위해 Cookie와 Seesion 등장하였다.

HTTP는 연결을 유지하지 않는 프로토콜이기 떄문에 요청/응답(request/response) 방식으로 동작한다.

client는 server에게 request(요청)을 보낸다. 그럼 요청을 받은 server가 해야 할 일은 response(응답)을 보내는 것이다. 

* 예)

예를 들어 이야기해보자. 우리가 회원가입을 하려고 한다. 회원가입 양식을 다 작성한 후 회원가입 버튼을 눌렀을 때 우리가 작성한 양식의 data는 server가 database에 저장해준다. 그리고 사용자는 회원가입이 완료되었다고 뜨는 페이지를 보게될 것이다. 이러한 일이 일어나는데 이 과정을 순서대로 적어보자.


회원가입 버튼을 누르면 client가 server에게 request를 보내는 것이다. 그러면 server는 지정한 방식으로 request가 왔기때문에 그 요청이 오면 request객체가 가지고 있는 data를 저장하도록 코딩을 해놨을 것이다. 그렇게 data를 저장한 후 client에게 회원가입이 완료되었다는 페이지를 보여주기 위해 server는 어떠한 페이지를 보여주는 역할을 response를 통해 하는 것이다. 

이런 과정을 HTTP를 통해 하는 것이다



* HTTP 구성

`Header` 안에  


어디서 보내는 요청인가? origin
컨텐츠 타입은 무엇인가? content-type
어떤 클라이언트를 이용해 보냈는가?
user-agent
  
`Body`안에 

서버에 데이터를 보내기위한 공간으로 활용한다.

* HTTP 속성

`stateless`

요청할때 서버는 멍청해서 그전에 내용을 기억하지 못해서 또 전에 요청한 내용을 동일하게 해줘야 한다. 

 

`connetionless`

물어보면 한번만 대답한다는것
한번요청보내면 대답도 한번








## AJAX란 무엇인가?
	
AJAX는 Asynchronos Javascript And XML이다.

쉽게 말하면, 자바스크립트를 통해서 서버에 데이터를 요청하는 것이다


dynamic web page 페이지 안에서 

서버와 자유롭게 통신하게하는것

`XMLHttpRequest` 등장 


페이지 깜빡임없이 부분적으로 내가 원하는 페이지만 작동하게하기위해 

`Javascript Dom` 등장


이것을 모두 말해서  `Ajax` 라고 합니다. 
 


* 서버랑 통신을 하기 AJAX 를 사용해야 한다. 



처음에는

>XMLHttpRequest 를 사용했었다. 조금 복잡하다.

두번째  

> JQuery 간편 너무 줄였다. 몬말인지 모르겠다. 

마지막

> Fetch API 를 사용한다.  유연하고 가독성 좋고 무슨말인지 이해가 잘된다. 



## Fetch 를 왜 쓰는가?


Factch 는 가져오는 함수

서버 자원을 가져오기 위해



## Request message 

* 웹브라우져와 웹서버 주고받는 내용 

```js

Request Header
GET /1.html HTTP/1.1     => 요청행
Host: localhost:8080     => 네트워크의 컴퓨터 식별하는 이름

User-Agent :     => 유저 컴퓨터, 웹브라우저 정보
...
...
Accept-Encoding : gzip, deflate, br   => 데이터 양이 많으면 압축해서 전송하는데, 어떤 압축방식을 지원하는지 설명
...
...
If-Modified-Since: Tue, ... => 마지막으로 페이지를 다운받은게 언제인지 확인하여 다시 다운받을지 결정
<blank line>    => 블랭크로 헤더와 바디 구분
Request Message Body


```
## ------------Browser Security----------------------------



## CORS

Corss Oring Resource Sharing

CORS 란?



![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 10.52.13 PM.png)






* 브라우저의 현재 웹 페이지에서 다른 페이지에 있는 자원을 쓸수 있게 해주는 정책 이다. 




* 다른 웹 페이지에 있는 리소스를 사용할수 있게 `도와`주는 것이 CORS라고 한다.



예를 들어보자 





예전에는 동일한 도메인에서만 요청과 응답을 할수 있게 해주었다.


![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.34.59 PM.png)


하지만 클라이언트가 ```www.naver/post.com``` 에서 `naver 서버컴퓨터`에서 요청을 보내면 간단하게 응답을 줄수 있는데 

`naver서버컴퓨터`가 `날씨 AIP 서버 컴퓨터` 에서 정보를 가져다가 브라우져상에 보여줘서 사용자들에게 제공하고 있다. 


![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 8.15.14 PM.png)




그러면 클라이언트는 굳이 naver 서버에 요청을 하는것이 아니라 날씨 AIP 서버에 요청을 하는 것이 된다. 

![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 8.15.38 PM.png)



![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.14.38 PM.png)





그러면  위에 그림과 같이 접근을 하고싶을 것이다. 
그러면 도메인 주소가 다르게 된다 `이때` 


![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.40.36 PM.png)



Cross-origin 이 발생하게 된다. 

서로 다른 도메인에 리소스를 보내고 받기 위해서는 

클라이언트와 서버에서 특정한 작업을 해줘야 한다. 

클라이언트는 브라우져에서 담당 하고 서버에서는 option 메소드가 올경우를 대비해서 코드를 작성해서 넣어주면 된다. 




![](/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.47.01 PM.png)



* app.js 서버

> 이런 방식을 통해 options 값을 서버에 작성한다.  

```js

 if (request.method === "OPTIONS") {
    response.writeHead(200, headers);
    response.end("옵션이 맞습니다."); // 처음시작은 헤더를 작성해준다.=조건맞으면 200준다.
    }

```



* Express - Node.js framework 를 이용해 간편하게 작성할수 있다. 
express의 해결방법

* 위에있는 내용과 동일하다. 


```js


const express = require("express"); // 1.express web application framework 불러온다.


// 2.npm install cors


const app = express(); // 3. app으로 프레임워크를 불러온다.


app.use(cors()); // 4. 실행한다. 

```








## XSS



## CSRF


## -------------------------------------------------------------










