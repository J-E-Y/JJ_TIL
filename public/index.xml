<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JohnJung</title>
    <link>/</link>
    <description>Recent content on JohnJung</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Jun 2030 13:00:00 +0900</lastBuildDate>
    
	    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Example Talk</title>
      <link>/talk/example/</link>
      <pubDate>Sat, 01 Jun 2030 13:00:00 +0900</pubDate>
      
      <guid>/talk/example/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click on the &lt;strong&gt;Slides&lt;/strong&gt; button above to view the built-in slides feature.
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Slides can be added in a few ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt; slides using Academic&amp;rsquo;s &lt;a href=&#34;https://sourcethemes.com/academic/docs/managing-content/#create-slides&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Slides&lt;/em&gt;&lt;/a&gt; feature and link using &lt;code&gt;slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upload&lt;/strong&gt; an existing slide deck to &lt;code&gt;static/&lt;/code&gt; and link using &lt;code&gt;url_slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embed&lt;/strong&gt; your slides (e.g. Google Slides) or presentation video on this page using &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34;&gt;shortcodes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Further talk details can easily be added to this page using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>__Asynchronous</title>
      <link>/tutorial/2020-02-08-server-side-techniques/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-02-08-server-side-techniques/</guid>
      <description>

&lt;h2 id=&#34;promise&#34;&gt;Promise&lt;/h2&gt;

&lt;h2 id=&#34;callback&#34;&gt;Callback&lt;/h2&gt;

&lt;h2 id=&#34;promise-chaining&#34;&gt;Promise Chaining&lt;/h2&gt;

&lt;h2 id=&#34;promise-all&#34;&gt;Promise.all&lt;/h2&gt;

&lt;h2 id=&#34;async-await&#34;&gt;async/await&lt;/h2&gt;

&lt;h2 id=&#34;fs-module&#34;&gt;fs module&lt;/h2&gt;

&lt;h2 id=&#34;request&#34;&gt;Request`&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>__Authentication</title>
      <link>/tutorial/2020-02-22-authentication/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-02-22-authentication/</guid>
      <description></description>
    </item>
    
    <item>
      <title>__node</title>
      <link>/tutorial/2020-02-08-node/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-02-08-node/</guid>
      <description>

&lt;h2 id=&#34;node&#34;&gt;Node&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;node.js 란?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;노드는 &lt;code&gt;V8 엔진&lt;/code&gt;으로 만들어진  자바스크립트 &lt;code&gt;런타임&lt;/code&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;v8 이란 ?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;v8 complies Javascript directly to native machine code&lt;/p&gt;

&lt;p&gt;자바스크립트를 기계어로 컴파일 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;런타임이란?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;프로그래밍 언어가 구동되고 있는 환경 이다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결론적으로 Node.js 란?&lt;/p&gt;

&lt;p&gt;node.js 는 자바스크립트를 컴파일 해주는 엔진으로 빌드된 자바스크립트 구동중인 환경이다.&lt;/p&gt;

&lt;h2 id=&#34;restful-api&#34;&gt;RESTful API&lt;/h2&gt;

&lt;h2 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CommonJS 란?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바스크립트를 모튤화 시켜서 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;모듈 : 독립적인 작은 코드들이 모여있는 집합. 다른 곳에서 가져다 활용할 수 있는 기능들&lt;/p&gt;

&lt;p&gt;1.&lt;code&gt;require&lt;/code&gt; 는 nodeJS 에서 사용&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const moment = require(&#39;moment&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;code&gt;import&lt;/code&gt;  는 ES6 에서 새롭게 도입&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import moment from &#39;moment&#39;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js에서 exports와 mudule.exports의 차이&lt;/p&gt;

&lt;p&gt;exports&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;exports를 사용할 때는 exports 객체에 프로퍼티를 추가했다&lt;/li&gt;
&lt;li&gt;여러 개의 객체를 내보낼 경우, exports 변수의 속성으로 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;module.exports&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;module.exports를 사용할 때는 module.exports 변수에 아예 새로운 객체를 할당했다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;딱 하나의 객체를 내보낼 경우, module.exports 변수 자체에 할당한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 10.51.23 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var x = 10;
var mod = require(&#39;./lib/my-module.js&#39;);
var result = mod.x;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


//in lib/my-module.js
var x = 20;
exports.x = 30;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;result: 30&lt;/p&gt;

&lt;p&gt;require이 내보내는 것은 exports라는 객체이다.&lt;/p&gt;

&lt;p&gt;(exports객체 안에 보내고 싶은 부분을 담는 것임.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var mod = require(&#39;./lib/my-module.js&#39;);
var result = mod.x;
//in lib/my-module.js:

var x = 10;
exports.x = 20;
module.exports.x = 30;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;result: 30&lt;/p&gt;

&lt;p&gt;exports는 module.exports를 참조하는 객체이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

var posts = [
    { title: &amp;quot;&#39;Post 1&amp;quot;, body: &#39;this is post one&#39;},
    { title: &amp;quot;Porst 2&amp;quot;, body: &amp;quot;this is post two&amp;quot;}
];
var newarr =[];
function getPosts() {
    setTimeout(()=&amp;gt;{
    let output = &amp;quot;&amp;quot;;
    posts.forEach((post)=&amp;gt;{
    newarr.push(post.title)
    });
    
    console.log(newarr)
    },3000);
}
getPosts();

function createPost(post){
    setTimeout(()=&amp;gt;{
        posts.push(post)
    },2000)
}
createPost({ title: &amp;quot;&#39;Post 3&amp;quot;, body: &#39;this is post three&#39;})



&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// getPosts(); // createPost() 안에 인자값으로 넣는다. 
var posts = [
    { title: &amp;quot;&#39;Post 1&amp;quot;, body: &#39;this is post one&#39;},
    { title: &amp;quot;Porst 2&amp;quot;, body: &amp;quot;this is post two&amp;quot;}
];
var newarr =[];
function getPosts() {
    setTimeout(()=&amp;gt;{
    let output = &amp;quot;&amp;quot;;
    posts.forEach((post)=&amp;gt;{
    newarr.push(post.title)
    });
    
    console.log(newarr)
    },1000);
}
// getPosts(); // createPost() 안에 인자값으로 넣는다. 

function createPost(post,callback){
    setTimeout(()=&amp;gt;{
        posts.push(post)
        callback()
    },2000)
}
createPost({ title: &amp;quot;&#39;Post 3&amp;quot;, body: &#39;this is post three&#39;},getPosts)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;express&#34;&gt;Express&lt;/h2&gt;

&lt;h2 id=&#34;event-loop&#34;&gt;Event Loop&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>__Database</title>
      <link>/tutorial/2020-02-06-database/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-02-06-database/</guid>
      <description>

&lt;h2 id=&#34;mysql&#34;&gt;MYSQL&lt;/h2&gt;

&lt;p&gt;MySQL 이랑 그냥 SQL 의 차이 ??&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MySQL : 데이터베이스(DataBase)이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SQL : 데이터를 관리하기 위해 설계된 프로그래밍 언어이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;mysql-시작하기&#34;&gt;MYSQL 시작하기&lt;/h5&gt;

&lt;p&gt;경로
cd /usr/local/mysql/bin&lt;/p&gt;

&lt;p&gt;비밀번호 입력
./mysql -uroot -p&lt;/p&gt;

&lt;p&gt;생성
mysql&amp;gt; CREATE DATABASE jjdb;&lt;/p&gt;

&lt;p&gt;삭제
mysql&amp;gt; DROP CREATE DATABASE jjd;&lt;/p&gt;

&lt;p&gt;확인&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; DATABASE;&lt;/p&gt;

&lt;p&gt;사용
mysql&amp;gt; UES jjd;&lt;/p&gt;

&lt;p&gt;Data table 만들기&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Data table&lt;/code&gt;을 만들기 위해서는 명시적으로 Database를 선택해 줘야 함 데이터베이스가 선택되면 생성된 모든 테이블들은 그 해당 데이터베이스에서 만들어짐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Table 생성&lt;/p&gt;

&lt;p&gt;table 탐색&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; DESC &lt;code&gt;jjTable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;table 삽입&lt;/p&gt;

&lt;h2 id=&#34;learn-sql&#34;&gt;Learn SQL&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Select&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Customers table 모두 보기
SELECT * FROM Customers;&lt;/p&gt;

&lt;p&gt;CustomerName만 가져오기
SELECT CustomerName,City FROM Customers;&lt;/p&gt;

&lt;p&gt;중복되지 않는 나라만 가져오기
SELECT DISTINCT Country FROM Customers;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Where&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;나라가 멕시코인곳만 가져오기
SELECT * FROM Customers
WHERE Country=&amp;lsquo;Mexico&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;3 And, Or, Not&lt;/p&gt;

&lt;p&gt;나라는 Germany Adn Berlin
SELECT * FROM Customers
WHERE Country=&amp;ldquo;Germany&amp;rdquo; AND City=&amp;ldquo;Berlin&amp;rdquo;&lt;/p&gt;

&lt;p&gt;나라는 Germany And Berlin OR Munchen
SELECT * FROM Customers
WHERE Country=&amp;lsquo;Germany&amp;rsquo; AND (City=&amp;lsquo;Berlin&amp;rsquo; OR City=&amp;lsquo;München&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;나라가 Germany 와 USA 가 아닌곳
SELECT * FROM Customers
WHERE NOT Country=&amp;lsquo;Germany&amp;rsquo; AND NOT Country=&amp;lsquo;USA&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;4.Order By&lt;/p&gt;

&lt;p&gt;나라 알파벳 순서대로 모든 정보들 정렬
SELECT * FROM Customers
ORDER BY Country;&lt;/p&gt;

&lt;p&gt;나라 알파벳 반대순서대로 모든 정보들 정렬
SELECT * FROM Customers
ORDER BY Country DESC;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Insert Into&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;원하는 정보 맨밑에저장된다.
INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
VALUES (&amp;lsquo;Cardinal&amp;rsquo;,&amp;lsquo;Tom B. Erichsen&amp;rsquo;,&amp;lsquo;Skagen 21&amp;rsquo;,&amp;lsquo;Stavanger&amp;rsquo;,&amp;lsquo;4006&amp;rsquo;,&amp;lsquo;Norway&amp;rsquo;);&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Null Values&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Customers table 에 CustomerName, ContactName, Address 목록을 불러오는데 Adrress 에 값이 Null 인 목록을 불러와라
SELECT CustomerName, ContactName, Address
FROM Customers
WHERE Address IS NULL;&lt;/p&gt;

&lt;p&gt;No result.&lt;/p&gt;

&lt;p&gt;반대로 NULL 값이 없는 목록들을 가져와라&lt;/p&gt;

&lt;p&gt;SELECT CustomerName, ContactName, Address
FROM Customers
WHERE Address IS NOT NULL;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Wildcards&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Customers 에 table 안에 city 안에 ber와 같은 char 들이 있는 목록들 불러오기
SELECT * FROM Customers
WHERE City LIKE &amp;lsquo;ber%&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;LIKE &amp;lsquo;ber%&amp;rsquo;     처음
LIKE &amp;lsquo;%es%&amp;rsquo;;    중간
LIKE &amp;lsquo;_ondon&amp;rsquo;;  끝
LIKE &amp;lsquo;L_n_on&amp;rsquo;;  검색중간
LIKE &amp;lsquo;[bsp]%&amp;lsquo;;  b,s,p 시작하는것들
LIKE &amp;lsquo;[!bsp]%&amp;lsquo;; b,s,p 시작하지 않는것들
NOT LIKE &amp;lsquo;[bsp]%&amp;lsquo;; b,s,p 시작하지 않는것들
LIKE &amp;lsquo;[a-c]%&amp;lsquo;;  a부터 c 까지&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Aliases (map)같은 문법&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;새로운 테이블을 만든다.
CustomerID 불러오고 이것의 카테고리는 ID
CustomerName 불로오고 이것의 카테고리는 Customer
그것을 화면에 출력&lt;/p&gt;

&lt;p&gt;SELECT CustomerID AS ID, CustomerName AS Customer
FROM Customers;&lt;/p&gt;

&lt;p&gt;만약 AS 의 사이에 하나만 있으면 데이터만 출력후
뒤에로 넘어간다.
SELECT CustomerName, Address + &amp;lsquo;, &amp;rsquo; + PostalCode + &amp;lsquo; &amp;rsquo; + City + &amp;lsquo;, &amp;rsquo; + Country AS Address
FROM Customers;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-06 at 1.29.29 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;mvc-design-pattern&#34;&gt;MVC design pattern&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;MVC&lt;/code&gt; 패턴은 애플리케이션을 Model, View, Controller 세 역할로 구분한 개발 방법론입니다. 각 요소는 애플리케이션의 작동과 관련하여 각기 다른 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;크게 3가지 패턴을 이야기 할수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Model&lt;/code&gt;은 데이터 처리와 관련된 역할을 수행하는 컴포넌트입니다. 컨트롤러의 명령을 받아 동작합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;View&lt;/code&gt;는 사용자들이 보는 화면(UI)으로서, 컨트롤러와의 소통을 통해 데이터를 입력하거나 출력합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Controller&lt;/code&gt;는 데이터(Model)와 사용자 인터페이스(View)를 연결하는 역할을 합니다..&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>__React</title>
      <link>/tutorial/2020-01-20-react/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-01-20-react/</guid>
      <description>

&lt;h2 id=&#34;what-is-react&#34;&gt;What is &amp;ldquo;React&amp;rdquo;??&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;인터렉션이 늘어남에 OR 관리 해야할 Dom 이 많아질수록 관리하기가 힘들어짐&lt;/li&gt;
&lt;li&gt;프론트 엔드 라이브러리, 프레임웍 많이 있다. 그중에 하나가 React 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;알아야-할-es6-문법들&#34;&gt;알아야 할 ES6 문법들&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1) Destructuring(구조 분해)
2) spread operator(전개 구문)
3) rest parameters
4) default parameters(기본 매개변수)
5) template literals
6) arrow function(화살표 함수)
7) for-of loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.Destructuring(구조 분해)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var a, b, rest;

[a, b] = [10, 20];

console.log(a); //10
console.log(b); //20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(a); //10
console.log(b); //20
console.log(rest); //[30, 40, 50]



({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}

var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2




선언에서 분리한 할당

var a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2



기본값

var a, b;

[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7



변수 값 교환하기

var a = 1, b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1


일부 반환 값 무시하기

function f() {
    return [1, 2, 3];
}

var [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

반환 값을 모두 무시할 수도 있음
[,,] = f();




새로운 변수 이름으로 할당하기

var o = {p: 42, q: true};
var {p: foo, q: bar} = o;
//var foo = 42; // 이것과 동일하다. 
//var bar = true; // 이것과 동일하다. 


//[foo, bar] = [42, true]   같다 왜??



console.log(foo); // 42

console.log(bar); // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.spread operator(전개 구문)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;배열이나 문자열과 같이 반복 가능한 문자를 0개 이상의 인수 (함수로 호출할 경우) 또는 요소 (배열 리터럴의 경우)로 확장하여, 0개 이상의 키-값의 쌍으로 객체로 확장시킬 수 있음.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

console.log(sum.apply(null, numbers)); //6
console.log(sum(...numbers)); //6
//함수에 배열을 인자로 넣고 싶을 대, apply대신 배열을 전개해서 사용할 수 있다.


구문


myFunction(...iterableObj);


[...iterableObj, &#39;4&#39;, &#39;five&#39;, 6];


let obj = {a: 1, b: 2};
let objClone = { ...obj }; //얕은 복사
console.log(objColne); //{a: 1, b: 2}


배열의 연결(concat 대신 사용)


var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = arr1.concat(arr2); //arr1: [0, 1, 2, 3, 4, 5]



var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = [...arr1, ...arr2]; //arr1: [0, 1, 2, 3, 4, 5]





&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.rest parameters&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;정해지지 않은 수(an indefinite number, 부정수) 인수를 배열로 나타낼 수 있게 함.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function sum(...theArgs) {
  return theArgs.reduce((previous, current) =&amp;gt; {
    return previous + current;
  });
}

// 만약 function sum(arguments) 으로 하면 
// sort, map, forEach 또는 pop 같은 메서드 가 되지 않는다. 

console.log(sum(1, 2, 3)); //6
console.log(sum(1, 2, 3, 4)); //10


Rest 파라미터와 arguments 객체간의 차이

`Rest 파라미터`는 구분된 이름(예, 함수 표현에 정식으로 정의된 것)이 주어지지 않은 유일한 대상인 반면, arguments 객체는 함수로 전달된 모든 인수를 포함합니다.

`arguments 객체`는 실제 배열이 아니고 rest 파라미터는 Array 인스턴스로, sort, map, forEach 또는 pop 같은 메서드가 바로 인스턴스에 적용될 수 있음을 뜻합니다.
즉 arguments 객체는 자체에 특정 추가 기능이 있습니다 (callee 속성처럼).


Rest 파라미터 해체

function f(...[a, b, c]) {
  return a + b + c;
}

f(1)// NaN  (b 와 c 가 undefined)
f(1,2)// NaN  ( c 가 undefined)
f(1, 2, 3)    // 6
f(1, 2, 3, 4) // 6 (4번 째 파라미터는 해체되지 않음)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.default parameters(기본 매개변수)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;기본 함수 매개변수(default function parameter)를 사용하면 값이 없거나 undefined가 전달될 경우 매개변수를 기본값으로 초기화할 수 있음.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5, 2)); //10  
console.log(multiply(5)); //5 // 5 * 1



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.template literals&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;내장된 표현식을 허용하는 문자열 리터럴입니다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있습니다. 이전 버전의 ES2015사양 명세에서는 &amp;ldquo;template strings&amp;rdquo; (템플릿 문자열) 라고 불려 왔습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var text = `hello`;
console.log(`text: ${text}, type: ${typeof text}`);
//text: hello, type: string

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.arrow function(화살표 함수)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다. 화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;화살표 함수는 항상 익명입니다.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var materials = [
  &#39;Hydrogen&#39;,
  &#39;Helium&#39;,
  &#39;Lithium&#39;,
  &#39;Beryllium&#39;
];



materials.map(value =&amp;gt; value.length);
// //Array [8, 6, 7, 9]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.for-of loop&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;for&amp;hellip;of 명령문은 반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복하고 각 개별 속성값에 대해 실행되는 문이 있는 사용자 정의 반복 후크를 호출하는 루프를 생성합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

for (const element of array1) {
  console.log(element);
}
// expected output: &amp;quot;a&amp;quot;
// expected output: &amp;quot;b&amp;quot;
// expected output: &amp;quot;c&amp;quot;

Map의 대한 반복문

인스턴스의 키와 value 값을 가져온다. 

let iterable = new Map([[&amp;quot;a&amp;quot;, 1], [&amp;quot;b&amp;quot;, 2], [&amp;quot;c&amp;quot;, 3]]);

for (let entry of iterable) {
  console.log(entry);
}
// [a, 1]
// [b, 2]
// [c, 3]

 인스턴스에 value값을 가져온다. 

for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/h2&gt;

&lt;h2 id=&#34;jsx&#34;&gt;JSX&lt;/h2&gt;

&lt;p&gt;JSX  란?&lt;/p&gt;

&lt;p&gt;JSX 규칙&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;반드시 하나의 엘리먼트로 감싸야 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자바스크립트 코드를 적용할 땐 { } 안에 작성한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JSX 내부에선 if문을 사용할 수 없다. IIFE or 삼항연산자 사용&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;엘리먼트의 클래스 이름을 적용할 때, className 을 사용(class는 ES6에 존재하기 때문)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;component&#34;&gt;Component&lt;/h2&gt;

&lt;p&gt;컴포넌트?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;개념상 컴포넌트는 자바스크립트 함수와 비슷함.&lt;/li&gt;
&lt;li&gt;독립적으로 기능할 것과 재사용 가능할 것&lt;/li&gt;
&lt;li&gt;재사용성과 코드 관리에 용이&lt;/li&gt;
&lt;li&gt;하나의 컴포넌트가 하나의 기능만 하게 햐야한다 왜냐하면 에러 발생시 용의하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Functional component vs Class component&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;함수형 컴포넌트 생성 방식&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prop 값의 변경 없이 바로 렌더하고자 할 때 사용한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function Welcome(props) {
    return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
}



&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;클래스 컴포넌트 생성 방식&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;method를 사용해야 하고, 클래스 내에서 state 관리 할 수 있고, life cycle에 맞춘 함수 관리가 가능하다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


class Welcome extends React.Component {
    render() {
        return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;props-란&#34;&gt;Props 란?&lt;/h2&gt;

&lt;p&gt;부모 컴포넌트가 자식 컴포넌트에게 내려주는 데이터&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;변경불가 - 고정값&lt;/li&gt;
&lt;li&gt;일기전용&lt;/li&gt;
&lt;li&gt;String,number function 내려준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;state&#34;&gt;state&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;state 란?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴퍼넌트의상태
컴포넌트 안에서 관리해야 한다.
setState 메소드를 이용하여 변경해야 한다.
왜냐하면&lt;/p&gt;

&lt;p&gt;1  재랜더링 하기위해
2. 가상돔이 인지하지 못해서&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;state가 변경되는 것은 동기 VS 비동기 ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;setState 메서드 자체는 동기로 작동
하지만 내부에서 state 값을 업데이트하는것은 비동기&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; 의 특징??&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클래스 컴포넌트에서 사용가능
immutable 하다
컴포넌트 내부에서만 접근 가능하다.
변경하려면 SetState사용
state 변화의 결과로 life cycle 이 순환한다.&lt;/p&gt;

&lt;h2 id=&#34;life-cycle&#34;&gt;Life Cycle&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Life Cycle 란?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴퍼넌트가 생성되고 업데이트되고 사라질때
항상!!! 보장된 타이밍에 실행되는 메서드&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-20-react_files/life.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;lifting-state-up&#34;&gt;Lifting state up&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lifting state up  이란?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자식 컴포넌트의 어떤 액션을 통해 부모 컴포넌트의 state 를 변경시키는 작업.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;why??&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴포넌트 단위로 로직을 작성하기 때문에&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how??&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.상위 컴포넌트에서 state 를 변경시키는 method 를 만듭니다.&lt;/p&gt;

&lt;p&gt;2.만든 modthod 를 자식 컴포넌트에게 props 로 넘겨준다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;자식 컴포넌트에서는 넘겨받은 props를 싱행시킨다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;handle-async-function&#34;&gt;Handle Async function&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;setTimeout에서 실행되는 함수안에서 일어나는 연산 들을 가져오기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function hello17th(callback){
  setTimeout(function(){
       var hello = &amp;quot;hello&amp;quot;;
       var name = &amp;quot;jj&amp;quot;
       var im17 = &amp;quot;im17&amp;quot;
       callback( `${hello} ${name} ${im17}`);
},2000);
}

hello17th()  // undefined 와 callback is not a function 나온다. 


// 그럼 어떻게 위에있는 코드를 실행할수 있을까 ?

// 이렇게 callback 함수를 인자안에 작성하면 위에 작성한
// 변수들을 모아서 사용할수 있다. 

hello17th(function(value){
    console.log(value);
    })

// 2초후에 실행된다.     
// hello jj im17 


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;class-or-function-component의-차이&#34;&gt;Class OR Function Component의 차이&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 11.34.35 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 11.34.40 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;virual-dom&#34;&gt;virual Dom&lt;/h2&gt;

&lt;p&gt;virual Dom 을 간단하게 설명한다.&lt;/p&gt;

&lt;p&gt;브라우저에 HTML 을 받으면 그것을 바로 RealDom 에 적용시키지 않고 virual Dom 을 만들어 브라우저에 있는 Dom 과 virual Dom 을 비교해서
바뀐 부분만 변경해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-20-react_files/Screen Shot 2020-02-02 at 11.04.43 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;reactdom-과-reactnative-차이점&#34;&gt;ReactDom 과 reactNative 차이점?&lt;/h2&gt;

&lt;p&gt;리엑트를 사용해서 웹사이트에 올리고 싶다?&lt;/p&gt;

&lt;p&gt;ReactDom 을 쓰면됨&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import ReactDOM from &amp;quot;react-dom&amp;quot;;

ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&amp;quot;root&amp;quot;));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;리엑트를 사용해서 웹사이트에 올리고 싶다?&lt;/p&gt;

&lt;p&gt;reactNative 쓰면됨&lt;/p&gt;

&lt;h2 id=&#34;redux&#34;&gt;Redux&lt;/h2&gt;

&lt;h2 id=&#34;생활코딩예제&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-생활코딩예제&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;component-만들기&#34;&gt;Component 만들기&lt;/h2&gt;

&lt;p&gt;HTML tag&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;header&amp;gt;
      &amp;lt;h1&amp;gt;WEB&amp;lt;/h1&amp;gt;
      world wide web!
    &amp;lt;/header&amp;gt;

    &amp;lt;nav&amp;gt;
      &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;1.html&amp;quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;2.html&amp;quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;3.html&amp;quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/nav&amp;gt;

    &amp;lt;article&amp;gt;
      &amp;lt;h2&amp;gt;HTML&amp;lt;/h2&amp;gt;
      HTML is HyperText Markup Language.
    &amp;lt;/article&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;




&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;App.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;
import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import &amp;quot;./App.css&amp;quot;;

class Content extends Component {
  render() {
    return (
      &amp;lt;article&amp;gt;
        &amp;lt;h2&amp;gt;HTML&amp;lt;/h2&amp;gt;
        HTML is HyperText Markup Language.
      &amp;lt;/article&amp;gt;
    );
  }
}

class TOC extends Component {
  render() {
    return (
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;1.html&amp;quot;&amp;gt;HTML&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;2.html&amp;quot;&amp;gt;CSS&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;3.html&amp;quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;  }
}

// 컴퍼넌트를 만들때는 항상 하나의 최상의 tag로 시작해야한다.

class Subject extends Component {
  render() {
    return (
      &amp;lt;header&amp;gt; 
        &amp;lt;h1&amp;gt;WEB&amp;lt;/h1&amp;gt;
        world wide web!
      &amp;lt;/header&amp;gt;
    );
  }
}

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  render() {
    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;Subject&amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;TOC&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content&amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;props-만들기&#34;&gt;Props 만들기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;
import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import &amp;quot;./App.css&amp;quot;;

class Content extends Component {
  render() {
    return (
      &amp;lt;article&amp;gt; // props
        &amp;lt;h2&amp;gt;{this.props.title}&amp;lt;/h2&amp;gt;  
        {this.props.desc}
      &amp;lt;/article&amp;gt;
    );
  }
}

class TOC extends Component {
  render() {
    return (
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;1.html&amp;quot;&amp;gt;HTML&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;2.html&amp;quot;&amp;gt;CSS&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;3.html&amp;quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
    );
  }
}

// 컴퍼넌트를 만들때는 항상 하나의 최상의 tag로 시작해야한다.
class Subject extends Component {
  render() {
    return (
      &amp;lt;header&amp;gt; // props
        &amp;lt;h1&amp;gt;{this.props.title}&amp;lt;/h1&amp;gt;
        {this.props.sub}
      &amp;lt;/header&amp;gt;
    );
  }
}

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  render() {
    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;Subject title=&amp;quot;WEB&amp;quot; sub=&amp;quot;world wide web!&amp;quot;&amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;Subject title=&amp;quot;menu&amp;quot; sub=&amp;quot;this is what I wanted to build&amp;quot;&amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;TOC&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content
          title=&amp;quot;HTML&amp;quot;
          desc=&amp;quot; HTML is HyperText Markup Language.&amp;quot;
        &amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    ); 
  }
}

export default App;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;component-파일로-분리하기&#34;&gt;Component 파일로 분리하기&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;만약 하나의 파일에 component가 수천개 있다면 복잡할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;App.js&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;main JS 파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;
import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  render() {
    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;Subject title=&amp;quot;WEB&amp;quot; sub=&amp;quot;world wide web!&amp;quot;&amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;Subject title=&amp;quot;menu&amp;quot; sub=&amp;quot;this is what I wanted to build&amp;quot;&amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;TOC&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content
          title=&amp;quot;HTML&amp;quot;
          desc=&amp;quot; HTML is HyperText Markup Language.&amp;quot;
        &amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;




&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;component파일 안에&lt;/p&gt;

&lt;p&gt;subject.js&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;component파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;

// 컴퍼넌트를 만들때는 항상 하나의 최상의 tag로 시작해야한다.

class Subject extends Component {
  render() {
    return (
      &amp;lt;header&amp;gt;
        &amp;lt;h1&amp;gt;{this.props.title}&amp;lt;/h1&amp;gt;
        {this.props.sub}
      &amp;lt;/header&amp;gt;
    );
  }
}

export default Subject;



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;component파일 안에&lt;/p&gt;

&lt;p&gt;content.js&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;component파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;
class Content extends Component {
  render() {
    return (
      &amp;lt;article&amp;gt;
        &amp;lt;h2&amp;gt;{this.props.title}&amp;lt;/h2&amp;gt;
        {this.props.desc}
      &amp;lt;/article&amp;gt;
    );
  }
}

export default Content;



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;component파일 안에&lt;/p&gt;

&lt;p&gt;TOC.js&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;component파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;

class TOC extends Component {
  render() {
    return (
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;1.html&amp;quot;&amp;gt;HTML&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;2.html&amp;quot;&amp;gt;CSS&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;3.html&amp;quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
    );
  }
}

export default TOC;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;state의-사용&#34;&gt;state의 사용&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;리팩토링과 마찬가지이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;
import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      subject: { title: &amp;quot;WEB&amp;quot;, sub: &amp;quot;world wide web!&amp;quot; }
    };
  }
  render() {
    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;Subject
          title={this.state.subject.title} //this 로 constructor 에 속성값 불러온다. 
          sub={this.state.subject.sub}
        &amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;TOC&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content
          title=&amp;quot;HTML&amp;quot;
          desc=&amp;quot; HTML is HyperText Markup Language.&amp;quot;
        &amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;state-key&#34;&gt;state (Key)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;복수의 앨리먼트를 생성할 때는 &lt;code&gt;key&lt;/code&gt;라는 특수한 &lt;code&gt;props&lt;/code&gt;를 사용해야 합니다. 여기서는 key의 사용법을 소개합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;App.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;
import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      subject: { title: &amp;quot;WEB&amp;quot;, sub: &amp;quot;world wide web!&amp;quot; },
      contents: [
        // 1. contents 키값과 value 값으로 [] 만들고 그안에 내용을 적는다.
        { id: 1, title: &amp;quot;HTML&amp;quot;, desc: &amp;quot;HTML is information&amp;quot; },
        { id: 2, title: &amp;quot;CSS&amp;quot;, desc: &amp;quot;CSS is information&amp;quot; },
        { id: 3, title: &amp;quot;JS&amp;quot;, desc: &amp;quot;JS is information&amp;quot; }
      ]
    };
  }
  // 2.render() 메소드 안에 TOC data = {this.state.contents} 넣어준다.
  // 3.그리고 TOC component 로 이동한다.
  render() {
    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;Subject
          title={this.state.subject.title}
          sub={this.state.subject.sub}
        &amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;TOC data={this.state.contents}&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content
          title=&amp;quot;HTML&amp;quot;
          desc=&amp;quot; HTML is HyperText Markup Language.&amp;quot;
        &amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 TOC.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

import React, { Component } from &amp;quot;react&amp;quot;;

class TOC extends Component {
  render() {
    return (
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;1.html&amp;quot;&amp;gt;HTML&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;2.html&amp;quot;&amp;gt;CSS&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;3.html&amp;quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;
          &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
    );
  }
}

export default TOC;



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이후 TOC.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


import React, { Component } from &amp;quot;react&amp;quot;;

class TOC extends Component {
  render() {
    var lists = [];
    var data = this.props.data; // &amp;lt;TOC data={this.state.contents}&amp;gt;&amp;lt;/TOC&amp;gt; 연결된다.
    var i = 0;
    // 여러게의 엘리먼트를 자동으로 생성할때 콘솔에 에러가 발생한다. 왜냐하면 각각의 목록에 키값을 주라는 것이다.
    // 이것은 react 가 필요로 하는 것이기 때문에 넣어 주어야 한다.
    // li tag 에 key 를 넣고 값은 App 의 프로퍼티에 있는 dt
    while (i &amp;lt; data.length) {
      lists.push(
        &amp;lt;li key={data[i].id}&amp;gt;
          &amp;lt;a href={&amp;quot;/content/&amp;quot; + data[i].id}&amp;gt;{data[i].title}&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
      );
      i = i + 1;
    }

    return &amp;lt;nav&amp;gt;{lists}&amp;lt;/nav&amp;gt;;
  }
}

//     &amp;lt;ul&amp;gt;
//       &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;1.html&amp;quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
//       &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;2.html&amp;quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
//       &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;3.html&amp;quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
//     &amp;lt;/ul&amp;gt;

export default TOC;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;이벤트-state-props-그리고-render-함수&#34;&gt;이벤트 state props 그리고 render 함수&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;App.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;
// import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;
// import ReactDOM from &amp;quot;react-dom&amp;quot;;

// react 는 특이한점 state or props 가 바뀌면 render 함수가 다시 호촐된다. render() 함수의 하위함수들도싹다 호출된다.화면이 다시 그려진다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      mode: &amp;quot;welcome&amp;quot;, // 이벤트 준비
      subject: { title: &amp;quot;WEB&amp;quot;, sub: &amp;quot;world wide web!&amp;quot; },
      welcome: { title: &amp;quot;welcom&amp;quot;, desc: &amp;quot;hello react!!!&amp;quot; }, // 이벤트 준비
      contents: [
        { id: 1, title: &amp;quot;HTML&amp;quot;, desc: &amp;quot;HTML is information&amp;quot; },
        { id: 2, title: &amp;quot;CSS&amp;quot;, desc: &amp;quot;CSS is information&amp;quot; },
        { id: 3, title: &amp;quot;JS&amp;quot;, desc: &amp;quot;JS is information&amp;quot; }
      ]
    };
  }

  render() {
    let _title = null; // 이벤트 변수
    let _desc = null; //  이벤트변수
    if (this.state.mode === &amp;quot;welcome&amp;quot;) {
      _title = this.state.welcome.title;
      _desc = this.state.welcome.desc;
    } else if (this.state.mode === &amp;quot;read&amp;quot;) {
      _title = this.state.contents[0].title;
      _desc = this.state.contents[0].desc;
    }

    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;Subject
          title={this.state.subject.title} // 이벤트 위에서 변수 가져옴
          sub={this.state.subject.sub} // 이벤트 위에서 변수 가져옴
        &amp;gt;&amp;lt;/Subject&amp;gt;
        &amp;lt;TOC data={this.state.contents}&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content title={_title} desc={_desc}&amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;이벤트-설치&#34;&gt;이벤트 설치&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;다시 랜더링 되는거 방지하기&lt;/p&gt;

&lt;p&gt;e.preventDefault() 사용하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;
// import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;
// import ReactDOM from &amp;quot;react-dom&amp;quot;;

// react 는 특이한점 state or props 가 바뀌면 render 함수가 다시 호촐된다. render() 함수의 하위함수들도싹다 호출된다.화면이 다시 그려진다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      mode: &amp;quot;welcome&amp;quot;, // 이벤트 준비
      subject: { title: &amp;quot;WEB&amp;quot;, sub: &amp;quot;world wide web!&amp;quot; },
      welcome: { title: &amp;quot;welcom&amp;quot;, desc: &amp;quot;hello react!!!&amp;quot; }, // 이벤트 준비
      contents: [
        { id: 1, title: &amp;quot;HTML&amp;quot;, desc: &amp;quot;HTML is information&amp;quot; },
        { id: 2, title: &amp;quot;CSS&amp;quot;, desc: &amp;quot;CSS is information&amp;quot; },
        { id: 3, title: &amp;quot;JS&amp;quot;, desc: &amp;quot;JS is information&amp;quot; }
      ]
    };
  }

  render() {
    let _title = null; // 이벤트 변수
    let _desc = null; //  이벤트변수
    if (this.state.mode === &amp;quot;welcome&amp;quot;) {
      _title = this.state.welcome.title;
      _desc = this.state.welcome.desc;
    } else if (this.state.mode === &amp;quot;read&amp;quot;) {
      _title = this.state.contents[0].title;
      _desc = this.state.contents[0].desc;
    }

    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        {
          /* &amp;lt;Subject
          title={this.state.subject.title} // 이벤트 위에서 변수 가져옴
          sub={this.state.subject.sub} // 이벤트 위에서 변수 가져옴
        &amp;gt;&amp;lt;/Subject&amp;gt; */
          // App 함수안에 &amp;lt;subject&amp;gt; 를 풀어해친후 테그안에 OnClick  을 넣느다.
          // 이때 e 파마미터를 추가하여 e.preventDefault() 호출한다.
          // 그러면 다시 랜더링하는것을 방지할수 있다.
          &amp;lt;header&amp;gt;
            &amp;lt;h1&amp;gt;
              &amp;lt;a
                href=&amp;quot;/&amp;quot;
                onClick={function(e) {
                  alert(&amp;quot;hello&amp;quot;);
                  e.preventDefault();
                }}
              &amp;gt;
                {this.state.subject.title}
              &amp;lt;/a&amp;gt;
            &amp;lt;/h1&amp;gt;
            {this.state.subject.desc}
          &amp;lt;/header&amp;gt;
        }

        &amp;lt;TOC data={this.state.contents}&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content title={_title} desc={_desc}&amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;state-변경하기&#34;&gt;state 변경하기&lt;/h2&gt;

&lt;p&gt;두가지 필요&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;setState() 메소드 사용&lt;/li&gt;
&lt;li&gt;bind(this) this 묶어주기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;setState 로 꼭 state 값을 바꿔줘야 한다.&lt;/p&gt;

&lt;p&gt;하지만&lt;/p&gt;

&lt;p&gt;&lt;code&gt;주의&lt;/code&gt;
아래 코드에서는 아니다.
그이유는 컴퍼넌트가 생성이 끝난 다음에 동적으로 state를 바꿀때는 다르기 때문이다.
&lt;code&gt;this.setState({})&lt;/code&gt; 이렇게 해주어야 한다. 그래야 react 가 안다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class App extends Component {
constructor(props) {
    super(props);
    this.state = {}
    
    }
    render(){
    if (this.state.mode === &amp;quot;welcome&amp;quot;) {
    //블라브라
    }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;
// import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;
// import ReactDOM from &amp;quot;react-dom&amp;quot;;

// react 는 특이한점 state or props 가 바뀌면 render 함수가 다시 호촐된다. render() 함수의 하위함수들도싹다 호출된다.화면이 다시 그려진다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      mode: &amp;quot;read&amp;quot;, // 이벤트 준비
      subject: { title: &amp;quot;WEB&amp;quot;, sub: &amp;quot;world wide web!&amp;quot; },
      welcome: { title: &amp;quot;welcom&amp;quot;, desc: &amp;quot;hello react!!!&amp;quot; }, // 이벤트 준비
      contents: [
        { id: 1, title: &amp;quot;HTML&amp;quot;, desc: &amp;quot;HTML is information&amp;quot; },
        { id: 2, title: &amp;quot;CSS&amp;quot;, desc: &amp;quot;CSS is information&amp;quot; },
        { id: 3, title: &amp;quot;JS&amp;quot;, desc: &amp;quot;JS is information&amp;quot; }
      ]
    };
  }

  render() {
    let _title = null; // 이벤트 변수
    let _desc = null; //  이벤트변수
    if (this.state.mode === &amp;quot;welcome&amp;quot;) {
      _title = this.state.welcome.title;
      _desc = this.state.welcome.desc;
    } else if (this.state.mode === &amp;quot;read&amp;quot;) {
      _title = this.state.contents[0].title;
      _desc = this.state.contents[0].desc;
    }

    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        {
          /* &amp;lt;Subject
          title={this.state.subject.title} // 이벤트 위에서 변수 가져옴
          sub={this.state.subject.sub} // 이벤트 위에서 변수 가져옴
        &amp;gt;&amp;lt;/Subject&amp;gt; */

          &amp;lt;header&amp;gt;
            &amp;lt;h1&amp;gt;
              &amp;lt;a
                href=&amp;quot;/&amp;quot;
                onClick={function(e) {
                  e.preventDefault();
                  // 클릭시 this.state.mode 값을 바꾸는 명령을 할것이다.
                  // this.state.mode = &amp;quot;welcome&amp;quot; 이것은 자바스크립트에서 허락하지 않는다.
                  // 이럴때 2가지를 해야한다.
                  // 1. setState() 메소드를 쓴다.
                  // 2. bind(this) this 가 바뀌는 것을 잡아준다.
                  this.setState({
                    mode: &amp;quot;welcome&amp;quot;
                  });
                }.bind(this)}
              &amp;gt;
                {this.state.subject.title}
              &amp;lt;/a&amp;gt;
            &amp;lt;/h1&amp;gt;
            {this.state.subject.desc}
          &amp;lt;/header&amp;gt;
        }

        &amp;lt;TOC data={this.state.contents}&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content title={_title} desc={_desc}&amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;컴포넌트-이벤트-만들기&#34;&gt;컴포넌트 이벤트 만들기&lt;/h2&gt;

&lt;p&gt;이벤트를 사용만 했지 만들지는 않았다.&lt;/p&gt;

&lt;p&gt;이벤트의 생상자가 되어보자&lt;/p&gt;

&lt;p&gt;브라우저에서 WEB 을 클릭하면 메시지 내용이 바뀌는 것을 구현한다.&lt;/p&gt;

&lt;p&gt;App.js 파일&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;
// import logo from &amp;quot;./logo.svg&amp;quot;; //필요없다 현재
import TOC from &amp;quot;./component/TOC&amp;quot;;
import Subject from &amp;quot;./component/subject&amp;quot;;
import Content from &amp;quot;./component/content&amp;quot;;
import &amp;quot;./App.css&amp;quot;;
// import ReactDOM from &amp;quot;react-dom&amp;quot;;

// react 는 특이한점 state or props 가 바뀌면 render 함수가 다시 호촐된다. render() 함수의 하위함수들도싹다 호출된다.화면이 다시 그려진다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      mode: &amp;quot;read&amp;quot;,
      subject: { title: &amp;quot;WEB&amp;quot;, sub: &amp;quot;world wide web!&amp;quot; },
      welcome: { title: &amp;quot;welcom&amp;quot;, desc: &amp;quot;hello react!!!&amp;quot; },
      contents: [
        { id: 1, title: &amp;quot;HTML&amp;quot;, desc: &amp;quot;HTML is information&amp;quot; },
        { id: 2, title: &amp;quot;CSS&amp;quot;, desc: &amp;quot;CSS is information&amp;quot; },
        { id: 3, title: &amp;quot;JS&amp;quot;, desc: &amp;quot;JS is information&amp;quot; }
      ]
    };
  }

  render() {
    let _title = null;
    let _desc = null;
    if (this.state.mode === &amp;quot;welcome&amp;quot;) {
      _title = this.state.welcome.title;
      _desc = this.state.welcome.desc;
    } else if (this.state.mode === &amp;quot;read&amp;quot;) {
      _title = this.state.contents[0].title;
      _desc = this.state.contents[0].desc;
    }

    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        {
          &amp;lt;Subject
            title={this.state.subject.title}
            sub={this.state.subject.sub}
            onchanged={function() {
              this.setState({
                mode: &amp;quot;welcome&amp;quot;
              });
            }.bind(this)} //원하는 이름의 함수를 만든다. 이름은 onChanged
          &amp;gt;&amp;lt;/Subject&amp;gt;
        }

        &amp;lt;TOC data={this.state.contents}&amp;gt;&amp;lt;/TOC&amp;gt;
        &amp;lt;Content title={_title} desc={_desc}&amp;gt;&amp;lt;/Content&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subject.js 파일&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;여기에서 OnClick 을 사용해     e.preventDefault(); 와 this.props.onchanged(); 와 .bind(this) 조합하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
import React, { Component } from &amp;quot;react&amp;quot;;



class Subject extends Component {
  render() {
    return (
      &amp;lt;header&amp;gt;
        &amp;lt;h1&amp;gt;
          &amp;lt;a
            href=&amp;quot;/&amp;quot;
            onClick={function(e) {
              e.preventDefault();
              this.props.onchanged();
            }.bind(this)}
          &amp;gt;
            {this.props.title}
          &amp;lt;/a&amp;gt;
        &amp;lt;/h1&amp;gt;
        {this.props.sub}
      &amp;lt;/header&amp;gt;
    );
  }
}

export default Subject;



&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__Web Architecture</title>
      <link>/tutorial/2020-01-13-sever/</link>
      <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-01-13-sever/</guid>
      <description>

&lt;h2 id=&#34;브라우저란&#34;&gt;브라우저란?&lt;/h2&gt;

&lt;p&gt;인터넷 망에서 정보를 감색하는데 사용하는 응용프로그램을 말한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웹 페이지 열기, 최근 방문한 URL(uniform resource locator) 및 즐겨찾기 제공, 웹페이지 저장&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;종류&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Explorer&lt;/p&gt;

&lt;p&gt;fireFox&lt;/p&gt;

&lt;p&gt;Chrome&lt;/p&gt;

&lt;p&gt;Safari&lt;/p&gt;

&lt;p&gt;Opera&lt;/p&gt;

&lt;h2 id=&#34;sever&#34;&gt;Sever&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;내컴퓨터가 다른컴퓨터에게 정보를 전달하고 공유하게 되면 내컴퓨터는 서버컴퓨터가 되는것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;어떤 형태의 컴퓨터든 정보제공 역활을 하는 주체이면 ‘서버’컴퓨터로 불릴수 있다. (노트북꾸진것이라도 서버컴퓨터가 될수있다.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예) 맛집에가서 사진을찍고 내컴퓨터에 저장했다 이것을 다른이에게 공유하기위해 다른 컴퓨터들이 내가 저장한 사진에 접근해서 볼수 있도록 하는것이다. 그럼 내컴퓨터는 서버컴퓨터가 되는것이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[Application Program Interface]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;프로그램과 또 다른 프로그램을 연결해주는 일종의 &lt;code&gt;다리&lt;/code&gt;라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버 자원을 잘 가져다가 쓸수 있게 만들어놓은 &lt;code&gt;interface&lt;/code&gt; 를 말한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UI&lt;/code&gt;(User Interface)를 먼저 짚고 넘어가려 합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;아이폰에 홈버튼이 있다. 이것을 누르면 처음화면으로 간다
이홈버튼은 스마트폰안에 있는 내용들을 확일할수 있게 사용자를 이어주는 매개체입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;API&lt;/code&gt;도 같은 맥락이라고 볼 수 있는데요&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;모든각국의 나라 도시의 날씨의 정보가 있는 싸이트가 있다.  그런데 나는 한국의 인천의 날씨를 가져와서 인천사람들에게 이것을 전달하기위해 API 라는 것을 통해 전달할수 있다.&lt;/p&gt;

&lt;p&gt;이것을 도와주는 중간 &lt;code&gt;매개체&lt;/code&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;get/message 전달하고
post/message 저장한다.&lt;/p&gt;

&lt;h2 id=&#34;http-hypertext-transfer-protocal&#34;&gt;HTTP :Hypertext Transfer Protocal&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HTTP란&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HyperText Transfer Protocol의 약자로 하이퍼텍스트 문서를 교환하기 위하여 사용된 통신 규약이다. 즉, 웹 서버와 클라이언트 간의 통신을 하기 위한 통신 규약이며 HTTP는 1989년 팀 버너스-리에 의해 처음 설계되었다. &lt;/p&gt;

&lt;p&gt;한마디로 클라이언트와 서버간에 통신을 위해 만들어진 규칙이 HTTP 를 주소창에 적고 그다음 URL 주소를 넣어 통신을 하게 만든다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP의 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다. 이러한 단점을 해결하기 위해 Cookie와 Seesion 등장하였다.&lt;/p&gt;

&lt;p&gt;HTTP는 연결을 유지하지 않는 프로토콜이기 떄문에 요청/응답(request/response) 방식으로 동작한다.&lt;/p&gt;

&lt;p&gt;client는 server에게 request(요청)을 보낸다. 그럼 요청을 받은 server가 해야 할 일은 response(응답)을 보내는 것이다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;예)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 이야기해보자. 우리가 회원가입을 하려고 한다. 회원가입 양식을 다 작성한 후 회원가입 버튼을 눌렀을 때 우리가 작성한 양식의 data는 server가 database에 저장해준다. 그리고 사용자는 회원가입이 완료되었다고 뜨는 페이지를 보게될 것이다. 이러한 일이 일어나는데 이 과정을 순서대로 적어보자.&lt;/p&gt;

&lt;p&gt;회원가입 버튼을 누르면 client가 server에게 request를 보내는 것이다. 그러면 server는 지정한 방식으로 request가 왔기때문에 그 요청이 오면 request객체가 가지고 있는 data를 저장하도록 코딩을 해놨을 것이다. 그렇게 data를 저장한 후 client에게 회원가입이 완료되었다는 페이지를 보여주기 위해 server는 어떠한 페이지를 보여주는 역할을 response를 통해 하는 것이다. &lt;/p&gt;

&lt;p&gt;이런 과정을 HTTP를 통해 하는 것이다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Header&lt;/code&gt; 안에&lt;/p&gt;

&lt;p&gt;어디서 보내는 요청인가? origin
컨텐츠 타입은 무엇인가? content-type
어떤 클라이언트를 이용해 보냈는가?
user-agent&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Body&lt;/code&gt;안에&lt;/p&gt;

&lt;p&gt;서버에 데이터를 보내기위한 공간으로 활용한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 속성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;stateless&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;요청할때 서버는 멍청해서 그전에 내용을 기억하지 못해서 또 전에 요청한 내용을 동일하게 해줘야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connetionless&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;물어보면 한번만 대답한다는것
한번요청보내면 대답도 한번&lt;/p&gt;

&lt;h2 id=&#34;ajax란-무엇인가&#34;&gt;AJAX란 무엇인가?&lt;/h2&gt;

&lt;p&gt;AJAX는 Asynchronos Javascript And XML이다.&lt;/p&gt;

&lt;p&gt;쉽게 말하면, 자바스크립트를 통해서 서버에 데이터를 요청하는 것이다&lt;/p&gt;

&lt;p&gt;dynamic web page 페이지 안에서&lt;/p&gt;

&lt;p&gt;서버와 자유롭게 통신하게하는것&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt; 등장&lt;/p&gt;

&lt;p&gt;페이지 깜빡임없이 부분적으로 내가 원하는 페이지만 작동하게하기위해&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Javascript Dom&lt;/code&gt; 등장&lt;/p&gt;

&lt;p&gt;이것을 모두 말해서  &lt;code&gt;Ajax&lt;/code&gt; 라고 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;서버랑 통신을 하기 AJAX 를 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;처음에는&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;XMLHttpRequest 를 사용했었다. 조금 복잡하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두번째&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JQuery 간편 너무 줄였다. 몬말인지 모르겠다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마지막&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Fetch API 를 사용한다.  유연하고 가독성 좋고 무슨말인지 이해가 잘된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;fetch-를-왜-쓰는가&#34;&gt;Fetch 를 왜 쓰는가?&lt;/h2&gt;

&lt;p&gt;Factch 는 가져오는 함수&lt;/p&gt;

&lt;p&gt;서버 자원을 가져오기 위해&lt;/p&gt;

&lt;h2 id=&#34;request-message&#34;&gt;Request message&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;웹브라우져와 웹서버 주고받는 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Request Header
GET /1.html HTTP/1.1     =&amp;gt; 요청행
Host: localhost:8080     =&amp;gt; 네트워크의 컴퓨터 식별하는 이름

User-Agent :     =&amp;gt; 유저 컴퓨터, 웹브라우저 정보
...
...
Accept-Encoding : gzip, deflate, br   =&amp;gt; 데이터 양이 많으면 압축해서 전송하는데, 어떤 압축방식을 지원하는지 설명
...
...
If-Modified-Since: Tue, ... =&amp;gt; 마지막으로 페이지를 다운받은게 언제인지 확인하여 다시 다운받을지 결정
&amp;lt;blank line&amp;gt;    =&amp;gt; 블랭크로 헤더와 바디 구분
Request Message Body


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;browser-security&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;Browser Security&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;cors&#34;&gt;CORS&lt;/h2&gt;

&lt;p&gt;Corss Oring Resource Sharing&lt;/p&gt;

&lt;p&gt;CORS 란?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 10.52.13 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;브라우저의 현재 웹 페이지에서 다른 페이지에 있는 자원을 쓸수 있게 해주는 정책 이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;다른 웹 페이지에 있는 리소스를 사용할수 있게 &lt;code&gt;도와&lt;/code&gt;주는 것이 CORS라고 한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어보자&lt;/p&gt;

&lt;p&gt;예전에는 동일한 도메인에서만 요청과 응답을 할수 있게 해주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.34.59 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 클라이언트가 &lt;code&gt;www.naver/post.com&lt;/code&gt; 에서 &lt;code&gt;naver 서버컴퓨터&lt;/code&gt;에서 요청을 보내면 간단하게 응답을 줄수 있는데&lt;/p&gt;

&lt;p&gt;&lt;code&gt;naver서버컴퓨터&lt;/code&gt;가 &lt;code&gt;날씨 AIP 서버 컴퓨터&lt;/code&gt; 에서 정보를 가져다가 브라우져상에 보여줘서 사용자들에게 제공하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 8.15.14 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 클라이언트는 굳이 naver 서버에 요청을 하는것이 아니라 날씨 AIP 서버에 요청을 하는 것이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 8.15.38 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.14.38 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그러면  위에 그림과 같이 접근을 하고싶을 것이다.
그러면 도메인 주소가 다르게 된다 &lt;code&gt;이때&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.40.36 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cross-origin 이 발생하게 된다.&lt;/p&gt;

&lt;p&gt;서로 다른 도메인에 리소스를 보내고 받기 위해서는&lt;/p&gt;

&lt;p&gt;클라이언트와 서버에서 특정한 작업을 해줘야 한다.&lt;/p&gt;

&lt;p&gt;클라이언트는 브라우져에서 담당 하고 서버에서는 option 메소드가 올경우를 대비해서 코드를 작성해서 넣어주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-13-sever_files/Screen Shot 2020-02-02 at 9.47.01 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app.js 서버&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;이런 방식을 통해 options 값을 서버에 작성한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
 if (request.method === &amp;quot;OPTIONS&amp;quot;) {
    response.writeHead(200, headers);
    response.end(&amp;quot;옵션이 맞습니다.&amp;quot;); // 처음시작은 헤더를 작성해준다.=조건맞으면 200준다.
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Express - Node.js framework 를 이용해 간편하게 작성할수 있다.
express의 해결방법&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;위에있는 내용과 동일하다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

const express = require(&amp;quot;express&amp;quot;); // 1.express web application framework 불러온다.


// 2.npm install cors


const app = express(); // 3. app으로 프레임워크를 불러온다.


app.use(cors()); // 4. 실행한다. 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;xss&#34;&gt;XSS&lt;/h2&gt;

&lt;h2 id=&#34;csrf&#34;&gt;CSRF&lt;/h2&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>6.configure</title>
      <link>/tutorial/2020-02-08-configure/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-02-08-configure/</guid>
      <description>

&lt;h2 id=&#34;visual-studio&#34;&gt;visual studio&lt;/h2&gt;

&lt;p&gt;Material Icon Them
DBdiagram 쓰기
ERD 공부&lt;/p&gt;

&lt;p&gt;magnet 맥스토어
* vim
* git hostoy
* html boilerplate&lt;/p&gt;

&lt;p&gt;eslint-cofig-prettier 충돌나지 않게 하기&lt;/p&gt;

&lt;h2 id=&#34;mysql&#34;&gt;Mysql&lt;/h2&gt;

&lt;p&gt;Mysql 은 디비 이름
SQL 은 디비를 다루기 위한 언어&lt;/p&gt;

&lt;p&gt;터미널 시작&lt;/p&gt;

&lt;p&gt;1.
cd /usr/local/mysql/bin&lt;/p&gt;

&lt;p&gt;2.
./mysql -uroot -p&lt;/p&gt;

&lt;p&gt;테이블 생성&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrap</title>
      <link>/tutorial/bootstrap/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/bootstrap/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;bs-image-img-fluid&#34;&gt;BS_image: &lt;strong&gt;img-fluid&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Description&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Create responsive images by adding an &lt;code&gt;.img-fluid&lt;/code&gt; class to the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag. The image will then scale nicely to the parent element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Syntax&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img class=&amp;quot;img-fluid&amp;quot; src=&amp;quot;img_chania.jpg&amp;quot; alt=&amp;quot;Chania&amp;quot;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;bs-spacing-my&#34;&gt;BS_Spacing: &lt;strong&gt;my&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Description&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Assign responsive-friendly &lt;code&gt;margin&lt;/code&gt; or &lt;code&gt;padding&lt;/code&gt; values to an element or a subset of its sides with shorthand classes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Syntax&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;my&amp;quot;&amp;gt;
  Centered element
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CodeStates</title>
      <link>/tutorial/javascript_dictionary/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/javascript_dictionary/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Dictionary_files/Screen Shot 2019-12-26 at 8.05.41 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Css</title>
      <link>/tutorial/css/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/css/</guid>
      <description>

&lt;h2 id=&#34;what-i-need-to-learn&#34;&gt;what I need to learn&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/CSS_files/Screen Shot 2019-12-17 at 5.06.14 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;lt-style-gt&#34;&gt;&amp;lt;style&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;
/*syntax*/

&amp;lt;style&amp;gt;

a {
  color:red
  }

&amp;lt;/style&amp;gt;



&amp;lt;dd&amp;gt;a :  selector(선택자)&amp;lt;/dd&amp;gt;
&amp;lt;dd&amp;gt;{Color:red}; : declaration (선언)&amp;lt;/dd&amp;gt;
&amp;lt;dd&amp;gt;{Color} :  property (속성)&amp;lt;/dd&amp;gt;
&amp;lt;dd&amp;gt;{Color:red} : property value (속성값)&amp;lt;/dd&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hover-버튼-클릭시-마우스-손가락-변형&#34;&gt;hover 버튼 클릭시 마우스 손가락 변형&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;
button.hover {

 cursor: pointer;
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;스크롤-만들기&#34;&gt;스크롤 만들기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--Vertical scroll bar in div which is a child of css grid column --&amp;gt;

&amp;lt;div class=&amp;quot;A&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;B&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;C&amp;quot;&amp;gt;search&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;D&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;1&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;2&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;3&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;4&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;5&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;6&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;7&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;8&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;9&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;10&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;11&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;12&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;10&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;11&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;12&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;10&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;11&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;E&amp;quot;&amp;gt;12&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 먼제 부모 tag 에 grid 명령과 max-hight 을 준다. 

.A {
  max-height: 300px; /* matters */
  display: grid; /* matters */
  overflow: hidden; /* matters */
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;
html, body, .A {
  height: 100%; /* matters */
  width: 100%;
  margin: 0;
  padding: 0;
}

.A {
  max-height: 300px; /* matters */
  display: grid; /* matters */
  overflow: hidden; /* matters */
}

.B {
  display: grid; /* matters */
  overflow-y: auto; /* matters */
}

.D {
  overflow-y: scroll; /* matters */
}

.C {
  padding: 10px;
  background-color: #07f;
}

.E {
  padding: 10px;
  background-color: #eee;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/CSS_files/Screen Shot 2019-09-25 at 8.37.27 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;boxmodel&#34;&gt;BoxModel&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;{
font-size:20px;
text-align:center;
text-decoration:none; : 밑줄없애기
text-decoration:underline; : 언더라인 만들어라
Border-bottom:red 20px solid;
Border-right: lightblue 20px solid;
Border-right:none; (오른쪽에 있는 선 없애기)
Margin:20px; 가장자리
Padding:20px;
width:20px;  : 폭
Display:none; 
Display:block; : 전체화면을 이용해라 (block level element)
Display:inline; : 부분화면을 이용해라 (inline element)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrapper&#34;&gt;wrapper&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;
/* Most basic example */ 

#wrapper {
    width: 500px;
    margin: 0 auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;wrapper&amp;quot;&amp;gt;
        Piece of text inside a 500px width div centered on the page
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;!-- * How the principle works

Create your wrapper and assign it a certain width. Then apply an automatic horizontal margin to it by using `margin: 0 auto;` or `margin-left: auto;` `margin-right: auto;.` The automatic margins make sure your element is centered.
--&amp;gt;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;media-queries&#34;&gt;media queries&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;
/* @media(max-width:800px) :  screen width &amp;lt; 800px 스크린이 800px 보다 작을때 명령을 내린다.

@media(min-width:800px)  : screen width  &amp;gt; 800px스크린이 800px 보다 클때 명령을 내린다.
*/


    @media(max-width:800px) {
    p {
        font-size: 1px
        font-weight
        font-height
        Display:block;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grid&#34;&gt;Grid&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/CSS_files/Screen Shot 2019-09-23 at 11.52.20 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;div class = &amp;quot;container&amp;quot;&amp;gt;

&amp;lt;div calss = &amp;quot;child1&amp;quot;&amp;gt;1&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child2&amp;quot;&amp;gt;2&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child3&amp;quot;&amp;gt;3&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child4&amp;quot;&amp;gt;4&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child5&amp;quot;&amp;gt;5&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child6&amp;quot;&amp;gt;6&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child7&amp;quot;&amp;gt;7&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child8&amp;quot;&amp;gt;8&amp;lt;/div&amp;gt;
&amp;lt;div calss = &amp;quot;child9&amp;quot;&amp;gt;9&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
.container {
  
  display: grid;  // 처음 시작을 지정해준다. 
  grid-template-columns: 40% 60%; // 위에 있는 그림이 4대 6으로 나뉜다.  
  grid-template-columns: 4fr 6fr;  //  4대 6으로 나뉜다. 
  grid-gap:1rem; // 사이마다 공간을 줄때 4fr 6fr 로 쓰는것을 권장한다. % 로 사용하면 여백이 뒤에 생기기 때문.. 
  
  grid-template-columns: repeat(3, 1fr); // 이것은  1fr 이 세번 반복 
  grid-template-columns: 1fr 1fr 1fr; // 이것과 동일하다. 

  grid-template-columns: 200px 1fr; // 200 픽셀로 왼쪽 것을 고정하고 오른쪽 것을 늘리는 것이다. 

  grid-auto-rows: 200px; // 200 픽셀 씩 모두 통일
  grid-auto-rows: minmax(200px,auto); // 이것은 동일한데 content 늘어나면 같이 같이 늘어난다. 

}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1번칸 늘리기 

.child1 {
  
  grid-column: 1/4 // 열에서 1부터 4까지 차지한다. 

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/CSS_files/Screen Shot 2019-09-23 at 9.44.12 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 4번칸 밑으로 늘리기 

 gird-column:3; // 3번 열부터 시작해라 
 gird-row :2/4; // 2번부터 4버까지 차지하라 
 


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/CSS_files/Screen Shot 2019-09-23 at 9.45.18 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 9번칸을 4번안에 집어넣는다. 
  
 gird-colum:3;
 gird-row:3/5;
 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/CSS_files/Screen Shot 2019-09-23 at 9.47.05 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>/tutorial/git/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/git/</guid>
      <description>

&lt;h2 id=&#34;1-command-line-터미널&#34;&gt;1.Command Line (터미널)&lt;/h2&gt;

&lt;h2 id=&#34;ls&#34;&gt;ls&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;파일보기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ls-a&#34;&gt;ls -A&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;숨겨진 파일까지 보기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ls-al&#34;&gt;ls -al&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;상세 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// (1)         (2)(3)   (4)      (5) (6)   (7)   (8)
//drwxr-xr-x   2 root  wheel    64B 11  7 14:14 test/


//1접근 권한 (읽기/쓰기/실행 가능) 여부
//2chmod 명령어
//3링크된 파일 갯수
//4소유자
//5소유그룹
//6파일 크기
//7만든 날짜
//8만든 시간
//9파일/디렉토리 이름


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cd-디렉토리-이름&#34;&gt;cd 디렉토리 이름&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;디렉토리로 이동( print working List )&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; myuser@mymachine:~$ `cd` Downloads

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cd&#34;&gt;cd-&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;뒤로가기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cd-1&#34;&gt;cd /&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;global 로 가기 (제일 처음 root 디렉토리로 이동 )&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pwd&#34;&gt;pwd&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;내가 어디있는지 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// myuser@mymachine:~/Downloads$ pwd
// showing that .. Users/myuser/Downloads
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;touch-file-name&#34;&gt;touch [file_name]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;빈 파일 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mkdir-dir-name&#34;&gt;mkdir [dir_name]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;디렉토리 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cat-file-name&#34;&gt;cat [file_name]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;텍스트 형태의 파일 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mv-file-or-dir-target-dir&#34;&gt;mv [file_or_dir] [target_dir]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;파일 및 디렉토리 옮기기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mv-file-or-dir-new-name&#34;&gt;mv [file_or_dir] [new_name]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;파일 및 디렉토리 이름 바꾸기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cp-file-target-dir-or-cp-r-folder&#34;&gt;cp [file] [target_dir] or cp -r [folder]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;복사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rm-filename&#34;&gt;rm [filename]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;파일 삭제&lt;/li&gt;
&lt;li&gt;휴지통에 들어가지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rm-r-dirname&#34;&gt;rm -r [dirname]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;폴더 삭제&lt;/li&gt;
&lt;li&gt;휴지통에 들어가지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rm-f-file-or-dirname&#34;&gt;rm -f [file or dirname];&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;coution&lt;/code&gt; 강제로 지우기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_17&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/h2&gt;

&lt;h2 id=&#34;2-git-version-control-system&#34;&gt;2.Git(Version Control System)&lt;/h2&gt;

&lt;h2 id=&#34;git-work-flow&#34;&gt;git-work-flow&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;페어랑 같이 fork 를 받아서 작업할때 쓰는 명령어&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 각각 서로 github 에 있는 레포주소를 clone 해서 연결한다.&lt;/li&gt;
&lt;li&gt;2. John이 코드를 작성한다. 그리고 add,commit,push 명령어를 통해 github 에 올린다.&lt;/li&gt;
&lt;li&gt;3. Tim 이 변경된 작성 코드를 가져온다. git pull [명칭] master 명령한다. 그리고 pull 땡겨온 것 을 &lt;code&gt;꼭&lt;/code&gt; add commit push 를 통해 github 에 올린다. 변경된 push 를 하지 않은체 한다면 다음 commit 이 작동하지 않고 충돌이 난다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/Git_files/1.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/2.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/3.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/4.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/5.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/6.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/7.png&#34; alt=&#34;&#34; /&gt;
  &lt;img src=&#34;/tutorial/Git_files/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;git-remote-remove-명칭&#34;&gt;git remote remove [명칭]&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;remote 연결된거 지우기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
origin	https://github.com/J-E-Y/im-sprint-data-structure.git (fetch)
origin	https://github.com/J-E-Y/im-sprint-data-structure.git (push)
pair	https://github.com/Dal-ya/im-sprint-data-structure.git) (fetch)
pair	https://github.com/Dal-ya/im-sprint-data-structure.git) (push)

git remote remove pair

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-branch-d-test&#34;&gt;git branch -d test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;branch 지우기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
git branch -d test
# Deleted branch test (was ########).


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-push-origin-delete-test&#34;&gt;git push origin &amp;ndash;delete test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;remote 지우기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
it branch -a
# *master
#  test
#  remote/origin/master
#  remote/origin/test



git push origin --delete test
# To &amp;lt;URL of your repository*.git
#  - [deleted]         test

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-branch-a&#34;&gt;git branch -a&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;현재 romote 상태 보기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
git branch -a
# *master
#  test
#  remote/origin/master
#  remote/origin/test




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-init&#34;&gt;git init&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create an empty Git repository or reinitialize an existing one&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-clone&#34;&gt;git clone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Clone a repository into a new directory&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-add&#34;&gt;git add .&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Add all file contents to the index&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-add-파일-이름&#34;&gt;git add 파일 이름&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;one file add&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;git add jung.html

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-commit-m&#34;&gt;git commit -m &amp;ldquo;&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;write message into github&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-remote-add-origin&#34;&gt;git remote add origin&amp;rdquo;&amp;rdquo;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;link local to github&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Git remote add origin &amp;quot;https://github.com/J-E-Y/test_2.git&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-push&#34;&gt;git push&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// git push -u origin master  최종 깇허브에 올리기 
// git push -u origin master  
// git push -f origin master ( 강제로)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-log&#34;&gt;git log&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;그동안 commit 한 내용을 볼수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*enter 키를 치면 밑에 내용을 계속 볼수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;log 파일을 나오려면 q  버튼을 누르면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-status&#34;&gt;git status&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;현재 진행 상태 보기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-config-global&#34;&gt;git config &amp;ndash;global&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;등록하기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.email &amp;quot;yourGitHub@email.com&amp;quot;
git config --global user.name &amp;quot;yourGitHubusername&amp;quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-branch-충돌-방지하기&#34;&gt;git branch : 충돌 방지하기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;merge 하는 중 출돌이 존재할수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;master branch 와 develop branch와 내용이 다를경우 master branch 에서 통합을 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;merge 하는 순간 conflict 가 발생 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git은 병합한 코드가 무엇이 다른지 코드안에 표시가 되게 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그리고 그분은에 들어가서 HAED 부분을 선택할지 develop 부분을 선택할지 직접 수동으로  코드를 삭제해서 결정을 하고 저장한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git add . 하고 다시  git merge develop 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그럼 병합이 된것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;확인 git merge develop 하면 이미 병합이 되었다 .&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그럼 log 하면 같은 화면에 master와 develop 가 동시에 나온다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;develop 는 필요없기 떄문 git branch -d develop 명령으로 삭제한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git branch 만 확인하면 master branch 만 남아있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git push  로 마무리&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-branch&#34;&gt;git Branch&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/Git_files/Screen Shot 2019-09-24 at 3.19.15 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Branch : git 은 동시에 여러 개발자들이 프로젝트에서 각기 다른 기능을 개발할 수 있도록 브랜치 (branch) 기능을 제공한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;일반적으로 EX)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Master Branch&lt;/li&gt;
&lt;li&gt;Develop Branch&lt;/li&gt;
&lt;li&gt;Bug Fix Branch&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;기능들이 수정되면 Master Branch 에 합치기(Merge) 라면 명령어를 사용해서 합치면 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Branch 에는 두가지 용어&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 통합Branch : Master Branch 를 말한다.&lt;/li&gt;
&lt;li&gt;2. 토픽Branch : 특정 기능을 위해 만들어진 Branch 를 말한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;실습&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git branch 명령 하면 현재 몇개의 branch 가 있는지 확일할수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git branch develop 명령 branch 생성&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cheakout develop 명령을 현재 default 값이 master 에서 새로만든 develop branch 로 바꿔준다. (git branch 로 확인할수 있다.);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이상태에서 기존 master branchs 에 있는 코드에 수정을 하고 git add 하고 git commit 을 하고 log 명렁을 하면 현재 &amp;lsquo;HAED -* develop&amp;rsquo; 바뀐것을 볼수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그러면 master branch 에는 적용이 안되있고 새로생성한 branch 에만 해당되어있다.  그러면 develop 에서 작업을 할수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이것을 합치기 위해서는 merge 명령을 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git cheakout master 명령을 해서 되돌아 간다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그리고 git merge develop 명령을 해서 합친다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;마지막으로 git push 명령을 해서 깃허브에 저장한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;필요없는 branch develop 를 삭제는 git branch -d develop 이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;기존에-commit한-내용으로-되돌아-가기&#34;&gt;기존에 commit한 내용으로 되돌아 가기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;log 명령을 하고&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git reset &lt;code&gt;--hard 9a9sdsa8fsdfsd6a78f6safs&lt;/code&gt; 명령을 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;가져온 주소명령으로 돌아가고 그 이후에 있는 commit 내용들을 싹다 지운다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;주의&lt;/em&gt; commit 내용들이 지워질뿐 아니라 모든 로컬에 저장되어있는 파일들도 제거된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그리고 나서 push 를 해주는데 push -f 를 명령해야 깃허브 저장소에서도 동일하게 적용된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;git-log-1&#34;&gt;git :log&lt;/h2&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;git-commit-amend&#34;&gt;git :commit &amp;ndash; amend&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;commit 명령을 잘못 넣으면  이명령어를 통해 수정할수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unix 에디터가 실행된다. 이모드는 수정모두와 관리자 모드로 나뉜다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;수정 모드로 들어가고자 한다면 a 를 입력하면 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그리고 내용을 수정하고 ESC 누르고 : 입력하면 wq! 수정되고 밖으로 나오게 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git status  하면 수정된 파일을 볼수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git push -f 강제로 명령하면 적용된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-cheakout&#34;&gt;git cheakout&amp;ndash;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;add 한다음에 git status 명령을 하면  수정된 파일이 스테이지에 올라가게 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cheakout&amp;ndash; 이라는 명령을 하면 add 하기전 코드상태로 되돌아 간다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-reset&#34;&gt;git reset&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;add 한 파일을 다시 되돌리기&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Html</title>
      <link>/tutorial/html/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/html/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/tutorial/HTML_files/Screen Shot 2019-09-13 at 5.15.58 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;lt-strong-gt&#34;&gt;&amp;lt;strong&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
/*

The HTML &amp;lt;strong&amp;gt; tag gives text a strong emphasis which traditionally means that the text is displayed as bold by the browser. 



Note 

what&#39;s the difference bewteen strong tag and b tag ?

strong tag :시각장애인들 낭독기를 사용할때 조금 더 굵 게 읽는다. 

b tag :평상시대로 굵게 읽는다.

*/

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-h1-gt&#34;&gt;&amp;lt;h1&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--  

The HTML &amp;lt;h1&amp;gt; tag defines the highest level or most important heading in the HTML document. This tag is also commonly referred to as the &amp;lt;h1&amp;gt; element.

--&amp;gt;



&amp;lt;!--  Syntax--&amp;gt;


&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Heading 1 goes here&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-br-gt&#34;&gt;&amp;lt;br&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;!-- The HTML &amp;lt;br&amp;gt; tag defines a line break within text in the HTML document. This tag is also commonly referred to as the &amp;lt;br&amp;gt; element.--&amp;gt;


&amp;lt;!-- Syntax --&amp;gt;



&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;The paragraph starts here&amp;lt;br&amp;gt;
and ends on the next line.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nbsp-making-space&#34;&gt;&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;  (making space)&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
/*
HTML will only display one space between words, no matter how many times you press the space bar. To force an extra space to show up, type `&amp;amp;nbsp;` in the area where you want to force the space.

*/

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-p-gt&#34;&gt;&amp;lt;p&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!---
The HTML &amp;lt;p&amp;gt; tag defines a paragraph in the HTML document. This tag is also commonly referred to as the &amp;lt;p&amp;gt; element.--&amp;gt;

* syntax


&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;The paragraph goes here.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-hr-gt&#34;&gt;&amp;lt;hr&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

The HTML &amp;lt;hr&amp;gt; tag defines a thematic break between paragraphs in HTML5, and a horizontal rule in HTML 4.01. This tag is also commonly referred to as the &amp;lt;hr&amp;gt; element.

* Note

The HTML &amp;lt;hr&amp;gt; element makes line bewteen two paragraphs.

* Syntax

--&amp;gt;


&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;This is the first paragraph.&amp;lt;/p&amp;gt;
&amp;lt;hr&amp;gt;
&amp;lt;p&amp;gt;This is the second paragraph.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-div-gt&#34;&gt;&amp;lt;div&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

The HTML &amp;lt;p&amp;gt; tag defines a generic container in an HTML document that is generally used to group elements. This tag is also commonly referred to as the &amp;lt;p&amp;gt; element.

* Note
 
The HTML &amp;lt;p&amp;gt; element is found within the &amp;lt;body&amp;gt; tag.
The &amp;lt;div&amp;gt; tag is generally used to group elements together.

&amp;lt;p&amp;gt; :element is a block-level element.


* Syntax


--&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div&amp;gt;this is the type of elemnt &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-span-gt&#34;&gt;&amp;lt;span&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

`height 와 width 적용이 안된다.` 하지만 Disply 사용해서 적용할수 있다 


The HTML &amp;lt;span&amp;gt; tag defines a generic inline container in an HTML document. This tag is also commonly referred to as the &amp;lt;span&amp;gt; element.

Note

&amp;lt;span&amp;gt;  tag is is generally used for styling purposes when there is no other element to use.
&amp;lt;span&amp;gt;  tag is a inline-level element
&amp;lt;span&amp;gt; tag does not inherently represent anything


Syntax

--&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;span&amp;gt;Span text goes here&amp;lt;/span&amp;gt; and not here&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;span class=&amp;quot;red_text&amp;quot;&amp;gt;Span text goes here&amp;lt;/span&amp;gt; and not here&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-nav-gt&#34;&gt;&amp;lt;nav&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

The HTML &amp;lt;nav&amp;gt; tag is an HTML5 element that defines a section with navigation links in the HTML document. This tag is also commonly referred to as the &amp;lt;nav&amp;gt; element. It is used to define a block of navigation links, either within the current document or to other documents


* Note

 The &amp;lt;nav&amp;gt; tag is used to create navigation in the HTML document.For IE browsers older than IE 9, use HTML5shiv which is a javascript workaround to provide support for the new HTML5 elements such as: &amp;lt;header&amp;gt;, &amp;lt;main&amp;gt;, &amp;lt;article&amp;gt;, &amp;lt;section&amp;gt;, &amp;lt;aside&amp;gt;, &amp;lt;nav&amp;gt;, &amp;lt;footer&amp;gt;.


* Syntax

--&amp;gt;



&amp;lt;body&amp;gt;
&amp;lt;nav&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/section1/index.html&amp;quot;&amp;gt;Section1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/section2/index.html&amp;quot;&amp;gt;Section2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/section3/index.html&amp;quot;&amp;gt;Section3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-ul-gt&#34;&gt;&amp;lt;ul&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

* Description

(부모태그)
The HTML &amp;lt;ul&amp;gt; tag defines an unordered list in the HTML document. This tag is also commonly referred to as the &amp;lt;ul&amp;gt; element.

* Note

The HTML &amp;lt;ul&amp;gt; element is found within the &amp;lt;body&amp;gt; tag.
The &amp;lt;ul&amp;gt; tag is made up of &amp;lt;li&amp;gt; tags.
Use the &amp;lt;ul&amp;gt; tag when the list items have no numerical ordering.
You can nest &amp;lt;ol&amp;gt;, &amp;lt;ul&amp;gt; and &amp;lt;ul&amp;gt;menu lists.

* Syntax


--&amp;gt;


&amp;lt;body&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-li-gt&#34;&gt;&amp;lt;li&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

* Description


(부모태그)
The HTML &amp;lt;li&amp;gt; tag defines a list item in &amp;lt;ol&amp;gt;, &amp;lt;ul&amp;gt; or &amp;lt;menu&amp;gt; in the HTML document. This tag is also commonly referred to as the &amp;lt;li&amp;gt; element.


* Syntax

--&amp;gt;


&amp;lt;body&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;




&amp;lt;body&amp;gt;
&amp;lt;ol&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&amp;lt;/body&amp;gt;



* Sample Output 2


&amp;lt;body&amp;gt;
&amp;lt;menu type=&amp;quot;toolbar&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;
    &amp;lt;menu label=&amp;quot;File&amp;quot;&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;new()&amp;quot;&amp;gt;New&amp;lt;/button&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;save()&amp;quot;&amp;gt;Save&amp;lt;/button&amp;gt;
    &amp;lt;/menu&amp;gt;
  &amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;
    &amp;lt;menu label=&amp;quot;Edit&amp;quot;&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;copy()&amp;quot;&amp;gt;Copy&amp;lt;/button&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;paste()&amp;quot;&amp;gt;Paste&amp;lt;/button&amp;gt;
    &amp;lt;/menu&amp;gt;
  &amp;lt;/li&amp;gt;
&amp;lt;/menu&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;!--
* Note

The &amp;lt;li&amp;gt; tag is used within &amp;lt;ol&amp;gt;, &amp;lt;ul&amp;gt; or &amp;lt;menu&amp;gt;.
You can nest &amp;lt;ol, &amp;lt;ul&amp;gt; and &amp;lt;menu&amp;gt; lists. (자식태그) li 태그는 반드시 부모태그를 가지고 있다. 

--&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;lt-ol-gt&#34;&gt;&amp;lt;ol&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

* Description
(자식태그)
The HTML &amp;lt;ol&amp;gt; tag defines an ordered list in the HTML document. This tag is also commonly referred to as the &amp;lt;ol&amp;gt; element.

* Syntax

--&amp;gt;




&amp;lt;body&amp;gt;
&amp;lt;ol&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&amp;lt;/body&amp;gt;


&amp;lt;!--

* Note

The &amp;lt;ol&amp;gt; tag is made up of &amp;lt;li&amp;gt; tags. 
Use the &amp;lt;ol&amp;gt; tag when the list items have numeric, meaningful ordering.
You can nest &amp;lt;ol&amp;gt;, &amp;lt;ul&amp;gt; and &amp;lt;menu&amp;gt; lists.

--&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lt-form-gt&#34;&gt;&amp;lt;form&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;!--

* Description

The HTML `&amp;lt;form&amp;gt; tag` is used to create a form on a web page that has interactive controls for user input. This tag is also commonly referred to as the `&amp;lt;form&amp;gt;` element.

* Syntax

--&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;form action=&amp;quot;&amp;quot; method=&amp;quot;get&amp;quot;&amp;gt;
    Company: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;company&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    Address: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;address&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample Output&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/HTML_files/Screen Shot 2019-06-01 at 9.40.42 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;lt-container-gt&#34;&gt;&amp;lt;container&amp;gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

* Description

In HTML, the container is the area enclosed by the beginning and ending tags. For example &amp;lt; HTML &amp;gt; encloses an entire document while other tags may enclose a single word, paragraph, or other elements. In HTML code, all container must have a start and stop tag to close the container. Without a stop tag the start tag will apply to the entire document.
 

--&amp;gt;



&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
      
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;





&amp;lt;!--

 * note
 
 The container div, and sometimes content div, are almost always used to allow for more sophisticated CSS styling. The body tag is special in some ways. Browsers don&#39;t treat it like a normal div; its position and dimensions are tied to the browser window.

But a container div is just a div and you can style it with margins and borders. You can give it a fixed width, and you can center it with margin-left: auto; margin-right: auto.

Plus, content, like a copyright notice for example, can go on the outside of the container div, but it can&#39;t go on the outside of the body, allowing for content on the outside of a border.


--&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cashing&#34;&gt;cashing&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;!--

* Description

파일을 따로 만든후 저장해놓는것


* how to use it? 

&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=“파일이름&amp;quot;&amp;gt;


* Sample Output

--&amp;gt;


&amp;lt;!doctype html&amp;gt;

&amp;lt;html&amp;gt;
&amp;lt;title&amp;gt;web1 - Son&amp;lt;/title&amp;gt;
&amp;lt;meta charset=&amp;quot;ut-8&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style.css&amp;quot;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Javascript_Basic</title>
      <link>/tutorial/javascript/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/javascript/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Dictionary_files/javascriptt-light_870x220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-data-type&#34;&gt;&lt;strong&gt;1.data type&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;자료형이란&#34;&gt;자료형이란?&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;어떤 종류의 데이터를 사용하는 것이지 컴퓨터에게 알려주는 것
자료형마다 사용 가능한 연산자(Operator)를 따로 가지고 있습니다!
자료형이 같아야 연산을 할 수 있습니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;자료형의-종류&#34;&gt;자료형의 종류&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Number :숫자&lt;/li&gt;
&lt;li&gt;String :문자&lt;/li&gt;
&lt;li&gt;Boolean :true and False&lt;/li&gt;
&lt;li&gt;Null : 값이 비어있다&lt;/li&gt;
&lt;li&gt;Undefined :값이 정의되지 않았다&lt;/li&gt;
&lt;li&gt;symbol(new in ECMAScript 6)
and Object :&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;1-number-type-숫자&#34;&gt;1. Number type (숫자)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var firstNum = 10;     // 소수점을 사용하지 않은 표현
var secondNum = 10.00; // 소수점을 사용한 표현
var thirdNum = 10e6;   // 10000000
var fourthNum = 10e-6; // 0.00001
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;length&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &amp;quot;hello&amp;quot;
a.length;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;slice :자르기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &amp;quot;KheLLo&amp;quot;
a[0];
a[1] = &amp;quot;H&amp;quot;; //안 됨


a.slice(1,4);
a.toUpperCase(); : 대문자로 바뀐
a.toLowerCase(); : 소문자로 바뀐다

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-string-문자열&#34;&gt;2. String (문자열)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;I am String&amp;quot;;
&amp;quot;Hello &amp;quot; + &amp;quot;world&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-boolean-불리언&#34;&gt;3. Boolean (불리언)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;true;
false;
5 &amp;gt; 3;
5 === 5;
5 &amp;gt; 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-the-typeof-operator-데이터유형을-알려주는-중요한-연산자&#34;&gt;4. The typeof Operator: 데이터유형을 알려주는 중요한 연산자!&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;typeof 10;        // number 타입
typeof &amp;quot;문자열&amp;quot;;  // string 타입
typeof true;      // boolean 타입
typeof undefined; // undefined 타입
typeof null;      // object 타입

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;5-symbol-심볼&#34;&gt;5. symbol (심볼)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;심볼 타입은 ECMAScript 6부터 새롭게 추가된 타입이다.
심볼은 유일하고 변경할 수 없는 타입으로, 객체의 프로퍼티를 위한 식별자로 사용할 수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sym = Symbol(&amp;quot;javascript&amp;quot;);  // symbol 타입
var symObj = Object(sym);        // object 타입
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;6-object-객체&#34;&gt;6. object (객체)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;자바스크립트의 기본 타입은 객체(object)이다. 객체(object)란 실생활에서 우리가 인식할 수 있는 사물로 이해할 수 있다. 객체는 여러 프로퍼티(property)나 메소드(method)를 같은 이름으로 묶어놓은 일종의 집합체이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dog = { name: &amp;quot;해피&amp;quot;, age: 3 }; // 객체의 생성
// 객체의 프로퍼티 참조
document.getElementById(&amp;quot;result&amp;quot;).innerHTML =
&amp;quot;강아지의 이름은 &amp;quot; + dog.name + &amp;quot;이고, 나이는 &amp;quot; + dog.age + &amp;quot;살 이다.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2-variable&#34;&gt;&lt;strong&gt;2.Variable&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;using-variables&#34;&gt;Using Variables&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var x = 10;

x + 5 ; // =&amp;gt; 15

x ; // =&amp;gt; 10

once we have created our variables,
we can use their name as a substitute for their value elsewhere in our program.


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;declaring-a-variable-without-a-vaue&#34;&gt;Declaring a variable without a Vaue&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
Creating a variable in JavaScript is called &amp;quot;declaring&amp;quot; a variable.

1.var carName;
After the declaration, the variable has no value (technically it has the value of undefined).


To assign a value to the variable, use the equal sign:

2. carName = &amp;quot;Volvo&amp;quot;;   // carName 를 Volvo 로 변경할때 var 없이 만든다 cos 먼저 선언을 했기 때문이다. 

2. var carName = &amp;quot;Volvo&amp;quot;;


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;changing-a-variable-s-value&#34;&gt;Changing a Variable’s value&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
var pokemon = charmander

pokemon = heelo


Notice that When you change the value of a variable, &amp;quot;you don’t need to use the var keyword&amp;quot;The var keyword is only needed for creating new variables.


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;variable-scope-변수의-유효-범위&#34;&gt;variable scope 변수의 유효 범위&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;local variable 지역 변수&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Variables declared inside a function body are in the Local scope.&lt;/p&gt;

&lt;p&gt;지역 변수(local variable)란 함수 내에서 선언된 변수를 가리킨다.
이러한 지역 변수는 변수가 선언된 함수 내에서만 유효하며, 함수가 종료되면 메모리에서 사라진다.함수의 매개변수 또한 함수 내에서 정의되는 지역 변수처럼 동작한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var greeting = &amp;quot;Hello&amp;quot;;

function greetSomeone() {
	var firstName = &amp;quot;john&amp;quot;
	return greeting + &amp;quot; &amp;quot; + firstName;
}

greetSomeone
firstName; // = &amp;gt; Error


Function(greetSomeone) is working but &amp;quot;firstName&amp;quot;&amp;quot; is Error Because we declared our name variable inside the scope of our greetSomeone function.


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;global variable  전역 변수&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Variables declared outside a function body are in the global scope.&lt;/p&gt;

&lt;p&gt;전역 변수(global variable)란 함수의 외부에서 선언된 변수를 가리킨다.
이러한 전역 변수는 프로그램의 어느 영역에서나 접근할 수 있으며, 웹 페이지가 닫혀야만 메모리에서 사라진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex 1-2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;quot;But!!!!!!! if you do this it works well&amp;quot;!!

var greeting = &amp;quot;Hello&amp;quot;;
var firstName = &amp;quot;john&amp;quot;

function greetSomeone() {
	firstName = &amp;quot;JJ&amp;quot;
	return greeting + &amp;quot; &amp;quot;+ firstName;
}


firstNmae // = &amp;gt; JJ

Because you changed a variable the was defined in an outer scope

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;3-operator&#34;&gt;&lt;strong&gt;3.Operator&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;arithmetic-operator-산술-연산자&#34;&gt;arithmetic operator (산술 연산자)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;+	왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 더함.
-	왼쪽 피연산자의 값에서 오른쪽 피연산자의 값을 뺌.
*	왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 곱함.
/	왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눔.
%	왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 나머지를 반환함

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 4;
document.write(x + y + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // 14
document.write(x - y + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // 6
document.write(x * y + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // 40
document.write(x / y + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // 2.5
document.write(x % y);          // 2

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;assignment-operator-대입-연산자&#34;&gt;assignment operator (대입 연산자)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;=	왼쪽 피연산자에 오른쪽 피연산자의 값을 대입함.
+=	왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 더한 후, 그 결과 값을 왼쪽 피연산자에 대입함.
-=	왼쪽 피연산자의 값에서 오른쪽 피연산자의 값을 뺀 후, 그 결과 값을 왼쪽 피연산자에 대입함.
*=	왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 곱한 후, 그 결과 값을 왼쪽 피연산자에 대입함.
/=	왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 결과 값을 왼쪽 피연산자에 대입함.
%=	왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 나머지를 왼쪽
피연산자에 대입함.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 10, z = 10;
x = x - 5;
y -= 5; // y = y - 5 와 같은 표현임.
z =- 5; // z = -5 와 같은 표현임.

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;increment-and-decrement-operator-증감-연산자&#34;&gt;increment and decrement operator ( 증감 연산자 )&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;++x	먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.
x++	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴.
--x	먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.
x--	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 10;
document.write((++x - 3) + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // x의 값을 우선 1 증가시킨 후에 3을 뺌.
document.write(x + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);         // 11
document.write((y++ - 3) + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // 먼저 y에서 3을 뺀 후에 y의 값을 1 증가시킴.
document.write(y);                  // 11
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;comparison-operator-비교-연산자&#34;&gt;comparison operator (비교 연산자)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;==	왼쪽 피연산자와 오른쪽 피연산자의 값이 같으면 참을 반환함.
===	왼쪽 피연산자와 오른쪽 피연산자의 값이 같고, 같은 타입이면 참을 반환함.
!=	왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않으면 참을 반환함.
!==	왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않거나, 타입이 다르면 참을 반환함.
&amp;gt;	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크면 참을 반환함.
&amp;gt;=	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크거나 같으면 참을 반환함.
&amp;lt;	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작으면 참을 반환함.
&amp;lt;=	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작거나 같으면 참을 반환함.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var x = 3, y = 5;
var a = &amp;quot;abc&amp;quot;, b = &amp;quot;bcd&amp;quot;;
document.write((x &amp;gt; y) + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);  // y의 값이 x의 값보다 크므로 false
document.write((a &amp;lt;= b) + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // 알파벳 순서상 &#39;a&#39;가 &#39;b&#39;보다 먼저 나오므로 &#39;a&#39;가 &#39;b&#39;보다 작음.
document.write(x &amp;lt; a);             // x의 값은 숫자이고 a의 값은 문자열이므로 비교할 수 없음.

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;logical-operator-논리연산자&#34;&gt;Logical operator (논리연산자)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;&amp;amp; 는 and 

|| 는 or

! 는 Not
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;bitwise-operator-비트-연산자&#34;&gt;bitwise operator (비트 연산자)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
&amp;amp;	대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)
|	대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)
^	대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)
~	비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산)
&amp;lt;&amp;lt;	지정한 수만큼 비트를 전부 왼쪽으로 이동시킴. (left shift 연산)
&amp;gt;&amp;gt;	부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산)
&amp;gt;&amp;gt;&amp;gt;	지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨.

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;increment-decrement-operator-증감연산자&#34;&gt;increment/decrement operator (증감연산자)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;증감 연산자는 피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자이다.이 연산자는 피연산자가 단 하나뿐인 단항 연산자이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a;
a++;
a = 0;
a++;
a--;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;comparison-operator-비교-연산자-1&#34;&gt;comparison operator (비교 연산자)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;==	왼쪽 피연산자와 오른쪽 피연산자의 값이 같으면 참을 반환함.
===	왼쪽 피연산자와 오른쪽 피연산자의 값이 같고, 같은 타입이면 참을 반환함.
!=	왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않으면 참을 반환함.
!==	왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않거나, 타입이 다르면 참을 반환함.
&amp;gt;	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크면 참을 반환함.
&amp;gt;=	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크거나 같으면 참을 반환함.
&amp;lt;	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작으면 참을 반환함.
&amp;lt;=	왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작거나 같으면 참을 반환함.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;typeof-연산자&#34;&gt;typeof 연산자&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;typeof 연산자는 피연산자의 타입을 반환한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;숫자, NaN	&amp;quot;number&amp;quot;
문자열	&amp;quot;string&amp;quot;
true, false	&amp;quot;boolean&amp;quot;
null	&amp;quot;object&amp;quot;
undefined	&amp;quot;undefined&amp;quot;
함수	&amp;quot;function&amp;quot;
함수가 아닌 객체	&amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeof &amp;quot;문자열&amp;quot;   // string
typeof 10         // number
typeof NaN        // number
typeof false      // boolean
typeof undefined  // undefined
typeof new Date() // object
typeof null       // object
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;ternary-operator-삼항-연산자&#34;&gt;ternary operator (삼항 연산자)&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;삼항 연산자는 유일하게 피연산자를 세 개나 가지는 조건 연산자이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 3, y = 5;
var result = (x &amp;gt; y) ? x : y   // x가 더 크면 x를, 그렇지 않으면 y를 반환함.
document.write(&amp;quot;둘 중에 더 큰 수는 &amp;quot; + result + &amp;quot;이다.&amp;quot;);

삼항 연산자는 짧은 if / else 문 대신 사용할 수 있으며, 코드를 간결하게 만들어 준다.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;delete-연산자&#34;&gt;delete 연산자&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;delete 연산자는 피연산자인 객체, 객체의 프로퍼티(property) 또는 배열의 요소(element) 등을 삭제해 준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;피연산자가 성공적으로 삭제되었을 경우에는 참(true)을 반환하고, 삭제하지 못했을 경우에는 거짓(false)을 반환한다.
이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽이다.&lt;/p&gt;

&lt;h5 id=&#34;쉼표-연산자&#34;&gt;쉼표 연산자&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;쉼표 연산자를 for 문에서 사용하면, 루프마다 여러 변수를 동시에 갱신할 수 있다.&lt;/p&gt;

&lt;p&gt;루프마다 i의 값은 1씩 증가하고, 동시에 j의 값은 1씩 감소함.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for (var i = 0, j = 9; i &amp;lt;= j; i++, j--) {
    document.write(&amp;quot;i의 값은 &amp;quot; + i + &amp;quot;이고, j의 값은 &amp;quot; + j + &amp;quot;이다.&amp;lt;br&amp;gt;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var arr = [1, 2, 3];          // 배열 생성
delete arr[2];                // 배열의 원소 중 인덱스가 2인 요소를 삭제함.
document.write(arr + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); // [1, 2, ]
// 배열에 빈자리가 생긴 것으로 undefined 값으로 직접 설정된 것은 아님.
document.write(arr[2] + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
// 배열의 요소를 삭제하는 것이지 배열의 길이까지 줄이는 것은 아님.
document.write(arr.length);

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;instanceof-연산자&#34;&gt;instanceof 연산자&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;instanceof 연산자는 피연산자인 객체가 특정 객체의 인스턴스인지 아닌지를 확인해 준다.
피연산자가 특정 객체의 인스턴스이면 참(true)을 반환하고, 특정 객체의 인스턴스가 아니면 거짓(false)을 반환한다.
이 연산자는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = new String(&amp;quot;이것은 문자열이다.&amp;quot;);
 
str instanceof Object;  // true
str instanceof String;  // true
str instanceof Array;   // false
str instanceof Number;  // false
str instanceof Boolean; // false

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;void-연산자&#34;&gt;void 연산자&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;void 연산자는 피연산자로 어떤 타입의 값이 오던지 상관없이 언제나 undefined 값만을 반환한다.
이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;이 링크는 동작하지 않는다.&amp;lt;/a&amp;gt;
 
&amp;lt;a href=&amp;quot;javascript:void(document.body.style.backgroundColor=&#39;yellow&#39;)&amp;quot;&amp;gt;
이 링크도 동작하지 않지만, HTML 문서의 배경색을 바꿔준다.
&amp;lt;/a&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;4-conditional&#34;&gt;&lt;strong&gt;4.Conditional&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;
if 문
if / else 문
if / else if / else 문
switch 문

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;if-문&#34;&gt;if 문&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;if (표현식) {
    표현식의 결과가 참일 때 실행하고자 하는 실행문;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 20;
if (x == y) {
document.write(&amp;quot;x와 y는 같다.&amp;quot;);
}
if (x &amp;lt; y) {
document.write(&amp;quot;x가 y보다 작다.&amp;quot;);
}
if (x &amp;gt; y) // 실행될 실행문이 한 줄뿐이라면 중괄호({})를 생략할 수 있음.
document.write(&amp;quot;x가 y보다 크다.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;else-문&#34;&gt;else 문&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
if (표현식) {
    표현식의 결과가 참일 때 실행하고자 하는 실행문;
} else {
    표현식의 결과가 거짓일 때 실행하고자 하는 실행문;
}
else 문을 사용하면 앞의 예제를 좀 더 직관적으로 표현할 수 있다.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 20;
if (x == y) {
document.write(&amp;quot;x와 y는 같다.&amp;quot;);
} else {
if (x &amp;lt; y)
    document.write(&amp;quot;x가 y보다 작다.&amp;quot;);
else // 실행될 실행문이 한 줄뿐이라면 중괄호({})를 생략할 수 있음.
    document.write(&amp;quot;x가 y보다 크다.&amp;quot;);
}


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;else-if-문&#34;&gt;else if 문&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
if (표현식1) {
    표현식1의 결과가 참일 때 실행하고자 하는 실행문;
} else if (표현식2) {
    표현식2의 결과가 참일 때 실행하고자 하는 실행문;
} else {
    표현식1의 결과도 거짓이고, 표현식2의 결과도 거짓일 때 실행하고자 하는 실행문;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 20;
if (x == y) {
document.write(&amp;quot;x와 y는 같다.&amp;quot;);
} else if (x &amp;lt; y) {
document.write(&amp;quot;x가 y보다 작다.&amp;quot;);
} else { // x &amp;gt; y인 경우
document.write(&amp;quot;x가 y보다 크다.&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;switch-case&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;if 와 else if를 반복적으로 써야 하는 상황을 피하게 해 줍니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var value;
switch(value) {
    case 값1:
    //value == 값1일 경우 실행할 코드
    break;
    case 값2:
    //value == 값2일 경우 실행할 코드
    break;
    //...
    default:
    //위쪽에 해당되지 않는 경우 실행할 코드
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;점수가 10점이면 A, 9점이면 B, 그 외에는 C를 출력하는 코드를 작성하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;if로 구현
var score = prompt(&#39;점수를 입력하세요&#39;);
if (score === 10) {
    console.log(&#39;A&#39;);
} else if (score == 9) {
    console.log(&#39;B&#39;);
} else {
    console.log(&#39;C&#39;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
switch-case 로 구현
var score = prompt(&#39;점수를 입력하세요&#39;);
switch (score) {
    case 10:
    console.log(&#39;A);
    break;
    case 9:
    console.log(&#39;B&#39;);
    break;
    default:
    console.log(&#39;C&#39;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;5-loops&#34;&gt;&lt;strong&gt;5.Loops&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;
while 문
do / while 문
for 문
for / in 문
for / of 문

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;while&#34;&gt;while&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;while (표현식) {
    표현식의 결과가 참인 동안 반복적으로 실행하고자 하는 실행문;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;note&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;while 문 만들때는 변수를 미리 만들어 줘야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var n ;
var n = 0;
var n = 1;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n = 1;
while(n &amp;lt;= 100) {    
console.log(&amp;quot;Hi &amp;quot; + n);
n++;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex 1-2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while 문을 사용해서 1에서 100까지의 합을 구해 봅시다.
자주 사용하는 패턴
var i = 0; // 1 변수 초기화
while (i &amp;lt;= 100) { // 2 변수 검사
console.log(i); // 3 코드 다하고나서 
i++; //  4 하나씩 증가
}

그래서 for가 등장함
위의 while 코드와 완전히 똑같음
for (var i = 0; i &amp;lt;= 100; i++) {
console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex gugudan with while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;script&amp;gt;
       
    var strN = Number(prompt(&amp;quot;input which gugudan&amp;quot;));
    var i = 1;
    document.write(&amp;quot;gugudan&amp;quot; + strN + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
    while (i &amp;lt; 10) {
        document.write(strN + &amp;quot; * &amp;quot; + i + &amp;quot; = &amp;quot; + strN * i + &amp;quot; &amp;lt;br&amp;gt; &amp;quot; );
        i++;
    }
   
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;for-문&#34;&gt;for 문&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;for (초기식; 표현식; 증감식) {
    표현식의 결과가 참인 동안 반복적으로 실행하고자 하는 실행문;
}
 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ex 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
for (var i = 1; i &amp;lt; 10; i++) {
document.write(i + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex 1-2 gugudan with for&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    
   var strN = Number(prompt(&amp;quot;input which dan?&amp;quot;));
   document.write(&amp;quot;gugudan&amp;quot; + strN + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
   for (var i = 1; i &amp;lt; 10; i++) {
       document.write(strN + &amp;quot; * &amp;quot; + i + &amp;quot; = &amp;quot; + strN * i + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
   }
    
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ex 1-3 gugudan with button&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;P&amp;gt;사용자가 2 이상, 9 이하가 아닌 값을 입력하는 경우 &amp;quot;2이상, 9이하의 값만      입력할 수 있습니다.&amp;quot;라는 메시지를 출력한다.&amp;lt;/P&amp;gt;
&amp;lt;script&amp;gt;
        
    var strN;
    while (true){
        strN = Number(prompt(&amp;quot;input which dan from 2 dan to 9 dan&amp;quot;))
        if (strN &amp;lt; 2 || strN &amp;gt; 9){
            console.log(&amp;quot;this is not available&amp;quot;);
        } else {
            document.write(&amp;quot;gugudan&amp;quot; + strN + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;); 
            break;
        }
    }
    for (i = 1; i &amp;lt; 10; i ++){
        document.write(strN + &amp;quot; + &amp;quot; + i + &amp;quot; = &amp;quot; + strN + i + &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
    }
        
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;6-array&#34;&gt;&lt;strong&gt;6.Array&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;배열이란&#34;&gt;배열이란?&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;자바스크립트에서 배열(array)은 이름과 인덱스로 참조되는 정렬된 값의 집합으로 정의된다. 배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;특징&#34;&gt;특징&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;배열 요소의 타입이 고정되어 있지 않으므로, 같은 배열에 있는 배열 요소끼리의 타입이 서로 다를 수도 있다. 배열 요소의 인덱스가 연속적이지 않아도 되며, 따라서 특정 배열 요소가 비어 있을 수도 있다.자바스크립트에서 배열은 Array 객체로 다뤄진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;배열-만들기-1&#34;&gt;배열 만들기 1&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var scores = [50, 60, 70];
console.log(scores);
console.log(scores.length);

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;인덱스를-이용해서-배열의-원소-읽기&#34;&gt;인덱스를 이용해서 배열의 원소 읽기&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;scores[0];
scores[3];
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열에-값-쓰기&#34;&gt;배열에 값 쓰기&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;scores[0] = 100;
scores[9] = 50;

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열의-타입-알아보기&#34;&gt;배열의 타입 알아보기&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;typeof scores
typeof scores[0]

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열-만들기-2&#34;&gt;배열 만들기 2&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var a = [];
a[0] = 2;
a[1] = 4;

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열의-길이-구하기&#34;&gt;배열의 길이 구하기&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;scores.length;

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열의-마지막-원소를-읽어-오려면&#34;&gt;배열의 마지막 원소를 읽어 오려면?&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;scores[scores.length - 1];
문자열과 배열
	•	문자열과 배열은 비슷한 성질을 많이 가지고 있습니다.
	•	문자열: Immutable
	•	배열: Mutable
	•	배열의 속성과 메소드를 문자열에도 테스트해보세요.

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열의-메소드들-1&#34;&gt;배열의 메소드들 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;push() 뒤어 붙이기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,];
arr.push(1);

arr; // = &amp;gt; [1,2,3,4,1]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pop() 뒤에 있는거 빼기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,];
arr.pop();

arr; // = &amp;gt; [1,2,3]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unshift()  앞에 붙이기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4];

arr.unshift(1);

arr; // = &amp;gt; [1,1,2,3,4,];

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shift()  앞에 있는거 빼기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4];

arr.shift();

arr; // = &amp;gt; [2,3,4,]

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concat() 더하기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,5];

arr.concat(6); 

&amp;gt;&amp;gt;arr 
[1,2,3,4,5,6]  
기존에 있는 것은 변하지 않는다.
변하게 하기위해서는 변수를 새로 만들기 !


var arr = [1,2,3,4,5];

arr.concat([6,7,8,9,10]);

&amp;gt;&amp;gt;arr
[1,2,3,4,5,6,7,8,9,10] 
여러게를 더할수 있다.

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;join() 문자열로 바꾸기&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,5,6]

arr.join() ;

&amp;gt;&amp;gt;arr
[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;6&amp;quot;]
문자열로 바꿔준다. 

arr.join(&amp;quot;&amp;quot;);

&amp;gt;&amp;gt;arr
[&amp;quot;123456&amp;quot;];
문자열 다 붙인다.

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;indaxtOf() ()&amp;lt;&amp;lt;원소를 입력하면부터 앞에서 부터 찾아서 index번호 알려준다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lastIndaxtOf() ()&amp;lt;&amp;lt;원소를 입력하면부터 뒤에서 부터 찾아서 index번호 알려준다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

var arr = [1,2,3,4,5];
arr.indexOf[1];
// arr



// 2

arr.indexOf[100];
// arr
// -1
// 없는 경우 -1를 호출한다. 

// EX) 
var arr = [1,2,3,4,5,6]
if (arr.indexOf(100) === -1 ) {
만약 100이라는 원소가 arr 에 없으면 
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;slice()&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//원소는 변하지 않는다

var arr = [1, 2, 3, 4, 5];
a.slice(0, 3);
&amp;gt;&amp;gt;a;
123

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;splice()&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//원소 값이 변한다. 
var arr = [1, 2, 3, 4, 5];
a.splice(0, 3);
// a  123


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;split()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;문자열을 문자의 배열로 나누고 싶을 때 사용하는 메소드입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;hello, world this is jj&amp;quot;;

s.split(&amp;quot;&amp;quot;);


// &amp;quot;h&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;,&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;j&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var s = &amp;quot;hello, world this is jj&amp;quot;;
s.split(&amp;quot;,&amp;quot;);

//&amp;quot;hello&amp;quot;, &amp;quot; world this is jj&amp;quot;
//콤마가 생겼다. 콤마의 기준으로 갈라진다.

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;hello world t-h-i-s-i-s-j-j&amp;quot;
s.split(&amp;quot;-&amp;quot;);

&amp;quot;hello  world t&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;j&amp;quot;
- 기준으로 갈라진다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;7-function&#34;&gt;&lt;strong&gt;7.Function&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;함수-만들기&#34;&gt;함수 만들기&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function convertHeight(feet, inches) {
  return (feet * 12 + inches) * 2.54
}
convertHeight(5, 10);
 //= &amp;gt;&amp;gt;177.8

(feet , inches) ==&amp;gt;&amp;gt; parameter ( 매개 변수) 
(5,10)  ==&amp;gt;&amp;gt; argument ( 전달인자	)

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;변수에-담아서-함수-사용하기&#34;&gt;변수에 담아서 함수 사용하기&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var ret = function convertHeight(feet, inches) {
  return (feet * 12 + inches) * 2.54
}
ret(5, 10);
//177.8

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;리턴값-없는-변수를-변수에-담으면-undefind-출력된다&#34;&gt;리턴값 없는 변수를 변수에 담으면 “undefind” 출력된다 .&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;ex 1-1 (console.log)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var foo = function () {
	console.log(“I’m a foo”);
}

// undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex 1-2 (return)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var foo = function () {
	return(“I’m a foo”);
}

// I’m a foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;return-을-break-로-사용하기-return-으로-함수를-종료하는데-사용할-수-있다&#34;&gt;return 을 break 로 사용하기 (return 으로 함수를 종료하는데 사용할 수 있다.)&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;(Option) 2중 루프를 한 번에 빠져 나가기&lt;/p&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 명령은 한 번에 한 루프만 빠져나갑니다.&lt;/p&gt;

&lt;p&gt;함수의 &lt;code&gt;return&lt;/code&gt; 을 이용하면 2중 루프를 한 번에 종료할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;종료하기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var test1 = function (text) {
            if (text === &amp;quot;exit&amp;quot;) {
                return;
            }
            console.log(&amp;quot;실행&amp;quot;);
        }

test1(&amp;quot;exit&amp;quot;) // =&amp;gt; undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;실행 하기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var test1 = function (text) {
            if (text === &amp;quot;exit&amp;quot;) {
                return;
            }
            console.log(&amp;quot;실행&amp;quot;);
        }
test1(&amp;quot;oh&amp;quot;&amp;quot;); // = &amp;gt; 실행 

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;이중-loop-빠져-나가기&#34;&gt;이중 loop 빠져 나가기&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;ex (하나만 빠져 나가기 )&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
for (var i = 0; i &amp;lt; 10; i ++)  {
	for (var j = 0; j &amp;lt; 10; j++) {
		console.log(i , j );
		if (j === 3 ) {
		    break;

		}
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex (이중 loop 빠져나간다 with function)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      
var foo = function() {
    for (var i = 0; i &amp;lt; 10; i ++)  {
      for (var j = 0; j &amp;lt; 10; j++) {
          console.log(i , j );
          if (j === 3 ) {
              return;
                }
              }
            }
         };
foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;배열을-이용한-while-문-for-문&#34;&gt;배열을 이용한 while 문 , for 문&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// while loop
    
    
    function sum (nums) {
    var total = 0;
    var i = 0;
    while (i &amp;lt; nums.length) {
        total = total + nums[i];
        i++;
    }
    return total;
}

sum([2,3,5,1]);

// 11

    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// for loop
  
  
  function sum (nums) {
  	var total = 0 ;
  	for (var i = 0 ; i &amp;lt; nums.length ; i = i + i ) {
  	total = total + nums[i]
  }
	return total;
}

sum([2,3,5,1,]);

// 11

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;8-objects&#34;&gt;&lt;strong&gt;8.Objects&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;making-objects&#34;&gt;making objects&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 1.
  var dog = {};

  dog.name = &amp;quot;jj&amp;quot;
  dog.color = &amp;quot;red&amp;quot;
  dog.kind = &amp;quot;똥깨&amp;quot;
  
  // dog = {name = &amp;quot;jj&amp;quot;, color =&amp;quot;red&amp;quot; , kind = &amp;quot;똥깨 &amp;quot;}


// 2. 
 var dog = {
    name : &amp;quot;jj&amp;quot;,
    color : &amp;quot;red&amp;quot;,
    kind : &amp;quot;똥깨&amp;quot;
}

  // dog = {name = &amp;quot;jj&amp;quot;, color =&amp;quot;red&amp;quot; , kind = &amp;quot;똥깨 &amp;quot;}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;using-objcets-in-javascript&#34;&gt;using objcets in Javascript&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var dog = {
    name = &amp;quot;jj&amp;quot;
    color = &amp;quot;red&amp;quot;
    
};

// we have two systems .

// 1. 
dog.name;
dog[&amp;quot;name&amp;quot;];

//결과갑 똑같다.
// jj

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;changing-objects&#34;&gt;changing objects&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 1. it is changed

dog.name = &amp;quot;john&amp;quot;

// 2. it is added

dog.food = &amp;quot;Banana&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;메소드&#34;&gt;메소드&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;객체에 속한 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
dog.eat = function(food) {
    console.log(this.name + &amp;quot; ate delicious &amp;quot; + food +&amp;quot;...&amp;quot;);
};

p1.eat(&amp;quot;Beef&amp;quot;);

&amp;gt;jj ate delicious Beef ...

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;this&#34;&gt;this&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 메소드 안에서 사용시 함수를 소유한 객체를 가르킨다.

var p2 = {};
p2.name = &amp;quot;jj&amp;quot;;
p2.weight = 80;
p2.say = function(word) {
    console.log(this.name + &amp;quot; says, &amp;quot; + word);
};

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>/tutorial/python/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/python/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;python-operators&#34;&gt;Python: &lt;strong&gt;Operators&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Arithmetic operators&lt;/li&gt;
&lt;li&gt;Assignment operators&lt;/li&gt;
&lt;li&gt;Comparison operators&lt;/li&gt;
&lt;li&gt;Logical operators&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;arithmetic-operator&#34;&gt;Arithmetic Operator&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Addition&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x + y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Subtraction&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x - y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Multiplication&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x * y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Division&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x / y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Modulus&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x % y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;**&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Exponentiation&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x ** y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;//&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Floor division&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x // y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;assignment-operators&#34;&gt;Assignment Operators&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x = 5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = 5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x += 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x + 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x -= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x - 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x *= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x * 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x /= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x / 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;%=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x %= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x % 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;//=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x //= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x // 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;**=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x &lt;code&gt;**= 3&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x ** 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x &amp;amp;= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x &amp;amp; 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x ^= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x ^ 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x &amp;gt;&amp;gt;= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x &amp;gt;&amp;gt; 3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x &amp;lt;&amp;lt;= 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x = x &amp;lt;&amp;lt; 3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;comparison-operators&#34;&gt;Comparison Operators&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Equal&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x == y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Not equal&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x != y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Greater than&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x &amp;gt; y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Less than&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x &amp;lt; y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Greater than or equal to&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x &amp;gt;= y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Less than or equal to&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x  &amp;lt;= y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;python-logical-operators&#34;&gt;Python Logical Operators&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Returns True if both statements are true&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x &amp;lt; 5 and  x &amp;lt; 10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Returns True if one of the statements is true&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;x &amp;lt; 5 or x &amp;lt; 4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Reverse the result, returns False if the result is true&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;not(x &amp;lt; 5 and x &amp;lt; 10)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;exmple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Print(1+1) 더하기
2
Print(1-1) 빼기
0
Print(1*1) 곱하기
1
Print(3**3) 제곱
18
Print(8/2) 나누기
4
Print(3/2*4) 순서대로 곱하기 나누기 우선 그다음에 빼기 더하기
6.0
Print(7//3) 몫구하기 (3이 몇번들어갈수 있는지)
2
Print(3%2) 나머지값구하기(나머지가 1 남는다)
1


# 연산자 우선 순위
# **
# *,/,//,%
# +, -

# 문자열 연산
# + : 문자열 끼리 붙여주는 역할 &amp;quot;Hi&amp;quot; + &amp;quot;Hello&amp;quot; =&amp;gt; &amp;quot;HiHello&amp;quot;
# * : &amp;quot;Hi&amp;quot;*3 =&amp;gt; “HiHiHi&amp;quot;

# 문자열을 표현하는 방법, 만드는 방법
&amp;quot;She said \&amp;quot;Hi\&amp;quot;&amp;quot; # &#39;She said &amp;quot;Hi&amp;quot;&#39;
&#39;I\&#39;m Jake&#39; # 특수문자나 특별한 알파벳 앞에 \(슬래시)를 붙여서 특수 기능을
# 수행하는 것을 이스케이핑 문자 혹은 이스케이핑 처리

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-variables&#34;&gt;Python: &lt;strong&gt;Variables&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Description&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;ariables are containers for storing data values.
Unlike other programming languages, Python has no command for declaring a variable.
A variable is created the moment you first assign a value to it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Example 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
x = 5
y = &amp;quot;John&amp;quot;
print(x)
print(y)

&amp;gt;&amp;gt;5
&amp;gt;&amp;gt;John
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Example 2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
x = 4 # x is of type int
x = &amp;quot;Sally&amp;quot; # x is now of type str
print(x)

&amp;gt;&amp;gt;Sally
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = &amp;quot;awesome&amp;quot;
print(&amp;quot;Python is &amp;quot; + x)

&amp;gt;&amp;gt;Python is awesome
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Variable Names&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;A variable can have a short name (like x and y) or a more descriptive name (age, carname, total_volume). Rules for Python variables:
A variable name must start with a letter or the underscore character
A variable name cannot start with a number
A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ )
Variable names are case-sensitive (age, Age and AGE are three different variables)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;# 변수 이름?
# 대소문자 구분
# 알파벳, 숫자, 한글 : 숫자는 맨앞에는 사용 금지
# 특수문자 : _
# 명사나 동사형

# 표기법
# sayHi : 두번째 단어부터 단어의 첫글자는 대문자
# SayHi : 모든 단어의 첫글자는 대문자
# say_hi : 모두 소문자, 단어사이에 _
# strSayHi : 변수명 앞에 변수의 타입을 기록
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-int-float-str&#34;&gt;Python: int float str&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;1-int-정수&#34;&gt;1.&lt;code&gt;int&lt;/code&gt;: 정수&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;x = input(&amp;quot;숫자를 입력해주세요.:&amp;quot;)
Y = input(&amp;quot;숫자를 입력해주세요.:”)

x = 20
y = 30

Print(x+y)
&amp;gt;&amp;gt;&amp;gt;2030



x = `int`(input(&amp;quot;숫자를 입력해주세요.:&amp;quot;))
Y = `int`(input(&amp;quot;숫자를 입력해주세요.:&amp;quot;))

x = 20
y = 30

Print(x+y)
&amp;gt;&amp;gt;&amp;gt;50
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-float-실수-소수점-나타내주는것&#34;&gt;2. &lt;code&gt;float&lt;/code&gt; :실수  () 소수점 나타내주는것&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;x = `float`(input(“숫자를 입력해주세요.:”)) &amp;gt;&amp;gt;20
Y = `float`(input(“숫자를 입력해주세요.:”)) &amp;gt;&amp;gt;30

Print(x+y)
50.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-str-문자-이것을-사용하면-숫자를-문자로-변환시킬수-있다&#34;&gt;3. &lt;code&gt;Str&lt;/code&gt;  :문자 이것을 사용하면 숫자를 문자로 변환시킬수 있다.&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;x = int(input(&amp;quot;숫자를 입력하세요.:&amp;quot;)
Y = int(input(&amp;quot;숫자를 입력하세요.:&amp;quot;)

sum = x + y

print(&amp;quot;두 수의 합은, sum, &amp;quot;입니다.&amp;quot;)
&amp;gt;&amp;gt;&amp;gt;두 수의 합은 50 입니다.


50  과 입니다 &amp;lt;&amp;lt;&amp;lt;를 붙이고싶다 또는 
문자를 숫자로 바꾸기 위해서 str 필요하다.

print(&amp;quot;두 수의 합은&amp;quot;&amp;quot;,`str`(sum),&amp;quot;입니다.&amp;quot;)

&amp;gt;&amp;gt;&amp;gt;&amp;gt;두 수의 합은 50입니다.



Print(1,2,3,4,end=&amp;quot;,&amp;quot;). &amp;lt;&amp;lt;&amp;lt; 콤마로 띄어쓴다.
print(1,2,3,4,sep=&amp;quot;,&amp;quot;)  &amp;lt;&amp;lt;&amp;lt;&amp;lt;  중간에 문자 집어넣기

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-format-string&#34;&gt;Python:Format_string&lt;/h2&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;format-명령&#34;&gt;format 명령&lt;/h6&gt;

&lt;h5 id=&#34;데이터타입-s-문자열-c-한글자-d-정수-f-실수&#34;&gt;[데이터타입] : s(문자열), c(한글자), d(정수), f(실수)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;example exercise 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foramt_string = &amp;quot;섭씨 35도는 화씨 99도 입니다.&amp;quot;

foramt_string = &amp;quot;섭씨 %f도는 화씨 %f도 입니다.&amp;quot;


msg = foramt_string % (35.7, 99.23)
print(msg)

f 는 소수점 처리를 할수 있다.


foramt_string = &amp;quot;섭씨 &#39;%0.2f&#39;도는 화씨 &#39;%-.4f&#39;도 입니다.&amp;quot;
msg = foramt_string % (35.7, 99.23)
print(msg)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-variables-1&#34;&gt;Python: Variables&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;ariables are containers for storing data values.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 5
y = &amp;quot;John&amp;quot;
print(x)
print(y)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-conditional&#34;&gt;Python: conditional&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;
if (a &amp;gt; b):
    [처리문 실행문]
elif [조건문 조건식]:
    [실행문 처리문]
else:
    [실행문]
&amp;quot;&amp;quot;&amp;quot;
# 조건식 : 명제 -&amp;gt; 참과 거짓으로 판별할 수 있는 구문
# 참과 거짓 : True False
# a &amp;gt; b, a &amp;lt; b, a &amp;gt;= b, a &amp;lt;= b, a == b, a != b
# and, or
# not
# 0, &amp;quot;&amp;quot;, False, []
# 상태 : empty


if not empty:
    청소를 한다.

a = 7
b = 8
c = 9
a &amp;gt; b and a &amp;gt; c
a &amp;gt; b or a &amp;gt; c
not (a &amp;gt; c)

a &amp;lt; b
a &amp;gt;= b
a &amp;lt;= b
a == b
a != b    
    
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = int(input(&amp;quot;당신의 출생연도를 입력해주세요.:&amp;quot;))


age = 2019 - a + 1


if age &amp;gt;= 20:
print(&amp;quot;당신은 성인입니다.”)

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = int(input(&amp;quot;당신의 출생연도를 입력해주세요.:&amp;quot;))

age = 2019 - a + 1

if age &amp;gt;= 20:
print(&amp;quot;당신은 성인입니다.&amp;quot;)

else:
print(&amp;quot;당신은 성인이 아닙니다.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Example exercise 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 사용자의 키와 체중을 입력받아서
# bmi 계산하여 출력하세요
# bmi = 체중(kg) / (키(m)의 제곱)


height = input(&amp;quot;키를 입력하세요 : &amp;quot;)
height = float(height)




weight = input(&amp;quot;체중을 입력하세요 : &amp;quot;)
weight = float(weight)


bmi = weight / ((height/100)**2)




# 키와 체중을 입력받고
# bmi 계산하고
# 18.5 미만 = 저체중
# 18.5 이상 23 미만 = 정상체중
# 23 이상 = 과체중


bmi_level = &amp;quot;&amp;quot;
if bmi &amp;lt; 18.5:
bmi_level = &amp;quot;저체중&amp;quot;
elif 18.5 &amp;lt;= bmi &amp;lt; 23:
bmi_level = &amp;quot;정상체중&amp;quot;
else:
bmi_level =  &amp;quot;과체중&amp;quot;
print(bmi,bmi_level)

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Example exercise 1-2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# 섭씨 -&amp;gt; 화씨로 바꾸는 프로그램
# 화시 -&amp;gt; 섭씨로 바꾸는 기능
# 메뉴 입력 시작
print(&amp;quot;-----MENU-----&amp;quot;)
print(&amp;quot;1. 섭씨 -&amp;gt; 화씨 변환&amp;quot;)
print(&amp;quot;2. 화씨 -&amp;gt; 섭씨 변환&amp;quot;)
print(&amp;quot;3. 프로그램 종료&amp;quot;)
menu = input(&amp;quot;메뉴를 선택하세요 : &amp;quot;)
# 메뉴 입력 끝


# 온도 계산 시작
if menu == &amp;quot;1&amp;quot;:
C = input(&amp;quot;섭씨 온도를 입력하세요 : &amp;quot;)
C = float(C)
F = C * 1.8 + 32
msg = &amp;quot;섭씨 &amp;quot;+str(C)+&amp;quot;도는 화씨 &amp;quot;+str(F)+&amp;quot;도 입니다.&amp;quot;
print(msg)
elif menu == &amp;quot;2&amp;quot;:
F = input(&amp;quot;화씨 온도를 입력하세요 : &amp;quot;)
F = float(F)
C = (F - 32) / 1.8
msg = &amp;quot;화씨 &amp;quot;+str(F)+&amp;quot;도는 섭씨 &amp;quot;+str(C)+&amp;quot;도 입니다.&amp;quot;
print(msg)
elif menu == &amp;quot;3&amp;quot;:
print(&amp;quot;프로그램을 종료합니다.&amp;quot;)
else:
print(&amp;quot;잘못 선택하셨습니다.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-try-except&#34;&gt;Python: try, except&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;
try:
    #[오류가 날지도 모르는 코드]
    a = int(&amp;quot;a&amp;quot;)
    print(&amp;quot;in&amp;quot;)
except ValueError:
    #[발생한 오류에 대응할 코드]
    print(&amp;quot;fired exception&amp;quot;)
except ZeroDivisionError:
    #[발생한 오류에 대응할 코드]
    print(&amp;quot;fired exception&amp;quot;)
except:
    #[발생한 오류에 대응할 코드]
    print(&amp;quot;fired exception&amp;quot;)
else:
    #[오류가 없이 지나왔을 경우 코드]
    print(&amp;quot;no error&amp;quot;)
finally:
    #[어쨋든 실행될 코드]
    print(&amp;quot;anyway&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;exercise 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
number = input(&amp;quot;정수를 입력하세요 : &amp;quot;)
try:
number = int(number)
except ValueError:
print(&amp;quot;정수가 아닙니다. 다시 입력하세요.&amp;quot;)
number = input(&amp;quot;정수를 입력하세요 : &amp;quot;)
number = int(number)


result = number*number
print(result)


# 입력받은 정수의 제곱 값을 출력하는 프로그램
# 만약 숫자가 아니라면 다시 입력하라는 메시지를 출력한다.
# 다시 입력 하라는 메시지는 1회만
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-while&#34;&gt;Python: While&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;
while [조건식]:
    [실행문]
    [실행문]
    [실행문]
    [실행문]

&amp;quot;&amp;quot;&amp;quot;
1 예) 이런식으로 많이 쓰인다.

While True:
    Try:
    Break
    except
2 예)


while True:
    # 정수를 입력받는다. 정수가 입력될 때까지
    number = input(&amp;quot;정수를 입력하세요 : &amp;quot;)
    try:
        number = int(number)
        break
    except:
        print(&amp;quot;정수가 아닙니다. 다시 입력하세요.&amp;quot;)


print(number)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;exercise&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# 섭씨 -&amp;gt; 화씨로 바꾸는 프로그램
# 화시 -&amp;gt; 섭씨로 바꾸는 기능
# 메뉴 입력 시작
print(&amp;quot;-----MENU-----&amp;quot;)
print(&amp;quot;1. 섭씨 -&amp;gt; 화씨 변환&amp;quot;)
print(&amp;quot;2. 화씨 -&amp;gt; 섭씨 변환&amp;quot;)
print(&amp;quot;3. 프로그램 종료&amp;quot;)
menu = input(&amp;quot;메뉴를 선택하세요 : &amp;quot;)
# 메뉴 입력 끝


# 온도 계산 시작
if menu == &amp;quot;1&amp;quot;:
while True:
    try:
        C = input(&amp;quot;섭씨 온도를 입력하세요 : &amp;quot;)
        C = float(C)
        break
    except:
        print(&amp;quot;다시 입력하세요.&amp;quot;)


F = C * 1.8 + 32
msg = &amp;quot;섭씨 &amp;quot;+str(C)+&amp;quot;도는 화씨 &amp;quot;+str(F)+&amp;quot;도 입니다.&amp;quot;
print(msg)
elif menu == &amp;quot;2&amp;quot;:
while True:
    try:
        F = input(&amp;quot;화씨 온도를 입력하세요 : &amp;quot;)
        F = float(F)
        break
    except:
        print(&amp;quot;다시 입력하세요.&amp;quot;)
C = (F - 32) / 1.8
msg = &amp;quot;화씨 &amp;quot;+str(F)+&amp;quot;도는 섭씨 &amp;quot;+str(C)+&amp;quot;도 입니다.&amp;quot;
print(msg)
elif menu == &amp;quot;3&amp;quot;:
print(&amp;quot;프로그램을 종료합니다.&amp;quot;)
else:
print(&amp;quot;잘못 선택하셨습니다.&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-for&#34;&gt;Python: for&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Description&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# for [name] in [bucket]:
#     [실행문]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
for n in range(10):
print(n)
print(n*n)

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;for-range-활용해서-1-100까지의-홀수의-합을-구하는-프로그램&#34;&gt;for, range 활용해서 1~100까지의 홀수의 합을 구하는 프로그램&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;total = 0
for x in range(1,101,2):
    total += x
    total = total + x
print(total)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# &amp;quot;Range는 횟수 용으로 많이 쓰인다.&amp;quot;
# range(Y) : 0 ~ Y-1까지
# range(X,Y) : X ~ Y-1까지
# range(X,Y,Z) : X ~ Y-1까지인데, Z씩 증감
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;for n in range(0,12.2):
    print(n)
2
4
6
8
10
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-module&#34;&gt;Python: Module&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;
import datetime
변수 = datetime.datetime.now()
Print(변수)
Print(변수.strftime(“%y-%m-%d&amp;quot;))
Print(변수.year)
Print(변수.hour)
Print(변수.corosecond)

&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;윤년-프로그램&#34;&gt;윤년 프로그램&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;# 윤년 프로그램을 짜본다.
# 윤년 2월 29일까지 있는 해
# 연도가 400으로 나누어 떨어지면 윤년
# 연도가 100으로 나누어 떨어지면 윤년 x
# 연도가 4로 나누어 떨어지면 윤년
# 1. 올해의 윤년여부 출력
# 2. 사용자의 입력을 받아서 윤년 여부 출력
# 3. 프로그램 종료
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
import datetime
while True:
    print(&amp;quot;----Menu----&amp;quot;)
    print(&amp;quot;1. 올해 윤년 여부&amp;quot;)
    print(&amp;quot;2. 입력 받은 연도 윤년 여부&amp;quot;)
    print(&amp;quot;3. 프로그램 종료&amp;quot;)
    menu = input(&amp;quot;메뉴를 선택하세요 : &amp;quot;)


    if menu == &amp;quot;1&amp;quot;:
        current_time = datetime.datetime.now()
        year = current_time.year
        if (year % 4 == 0 and year % 100 !=0) or year % 400 == 0:
            print(&amp;quot;윤년입니다.&amp;quot;)
        else:
            print(&amp;quot;윤년이 아닙니다.&amp;quot;)
    elif menu == &amp;quot;2&amp;quot;:
        while True:
            try:
                year = input(&amp;quot;판별하고자 하는 연도를 입력하세요 : &amp;quot;)
                year = int(year)
                break
            except:
                print(&amp;quot;다시 입력하세요.&amp;quot;)
        if (year % 4 == 0 and year % 100 !=0) or year % 400 == 0:
            print(&amp;quot;윤년입니다.&amp;quot;)
        else:
            print(&amp;quot;윤년이 아닙니다.&amp;quot;)
    elif menu == &amp;quot;3&amp;quot;:
        break
        # exit()
    else:
        print(&amp;quot;없는 메뉴 입니다.&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-function&#34;&gt;Python: function&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;# def [함수이름]([매개변수,입력값]):
#     [실행구문]
#     [return (반환값, 출력값)]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;example 1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = 1
B = 2
x = 1+2
Print(x)

&amp;gt;&amp;gt;&amp;gt;3

함수 이용하기

def x (A,B) : 
return A+B
print (x(1,2))

&amp;gt;&amp;gt;&amp;gt;3

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;example 1-2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def sayHi():
print(&amp;quot;Hello Python&amp;quot;)


sayHi()

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exercise 1-2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# 1~9까지의 각각의 제곱을 출력하는 함수를 만드세요.
def PrintSquare():
for x in range(1,10):
    print(x*x)


PrintSquare()
PrintSquare()
PrintSquare()
PrintSquare()
PrintSquare()


def PrintSquare2(endNumber):
for x in range(1,endNumber+1):
    print(x*x)


PrintSquare2(10)


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exercise 1-3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 두개의 숫자를 전달 받아서
# 그 두 숫자의 합을 출력하는 함수
def printSum(number1, number2):
print(number1+number2)


printSum(10, 22)

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exercise 1-4&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 별줄수 만들기

&amp;quot;&amp;quot;&amp;quot;
사용자에게 줄 수를 입력받아서
해당 줄 수만큼 별을 출력하시오.
*
***
*****
&amp;quot;&amp;quot;&amp;quot;


line_count = input(&amp;quot;출력할 줄 수를 입력하세요 : &amp;quot;)
line_count = int(line_count)


max_width = line_count*2 - 1
format_string = &amp;quot;{:^&amp;quot;+str(max_width)+&amp;quot;s}&amp;quot;
for count in range(line_count):
#blank_count = line_count-(count+1)
#print(&amp;quot; &amp;quot; * blank_count, end=&amp;quot;&amp;quot;)
start_count = 2 * count + 1




msg = format_string.format(&amp;quot;*&amp;quot;*start_count)
print(msg)

*
***
*****

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;python-crawler&#34;&gt;Python: Crawler&lt;/h2&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;1-변수만들어서-저장하기-data-text-모든-리소스-불러오기&#34;&gt;1. 변수만들어서 저장하기 data.text 모든 리소스 불러오기&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
url = &amp;quot;https://www.naver.com/&amp;quot;
requests.get(url)
data = requests.get(url)
print(data.text)

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-제대로-돌아가고-있는지-확인&#34;&gt;2. 제대로 돌아가고 있는지 확인&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;print (data.status_code)

“””
200
“””

200번대 - 정상
300번대 - redirect
400번대 - 리소스 오류
500번대 - 소스코드 오류
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-test-해보기-만약-이게-맞다면-응답해라&#34;&gt;3. Test 해보기 만약 이게 맞다면 응답해라&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
if data.status_code == requests.codes.ok:
    print(&amp;quot;work out”)


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-from-bs4-import-beautifulsoup-html를-해석해주는-역활&#34;&gt;4. From bs4 import BeautifulSoup HTML를 해석해주는 역활&lt;/h5&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Parsing(파싱) text 파일을 우리가 원하는 것을 불러오기 위해서는       parsing 필요하다.이럴때 BeautifulSoup 이라는 order 필요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html = BeautifulSoup(data.text,&amp;quot;html.parser&amp;quot;)
links = html.select(&amp;quot;.PM_CL_realtimeKeyword_list_base .ah_a”)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;나열방식이 틀림&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1)     for index,keyword in enumerate ( links,start=1 ) :
        print(index,keyword)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1 &lt;sdsdsdsd&gt;
2 &lt;sdsdsdsd&gt;
3 &lt;sdsdsdss&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(2).   For keyword in links[:3]:
       For keyword in links[::3]:
       Print(keyword)



(3)

for link in links:
    rank = link.select_one(&amp;quot;.ah_r&amp;quot;).text
    keyword = link.select_one(&amp;quot;.ah_k&amp;quot;).text
    print(rank,keyword,link.attrs[&amp;quot;href&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1 왕종명 &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EC%99%95%EC%A2%85%EB%AA%85&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EC%99%95%EC%A2%85%EB%AA%85&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;
2 grn &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=grn&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=grn&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;
3 백예린 &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EB%B0%B1%EC%98%88%EB%A6%B0&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EB%B0%B1%EC%98%88%EB%A6%B0&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;
4 붐붐파워 &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EB%B6%90%EB%B6%90%ED%8C%8C%EC%9B%8C&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EB%B6%90%EB%B6%90%ED%8C%8C%EC%9B%8C&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;
5 2019 스타벅스 벚꽃 md &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=2019+%EC%8A%A4%ED%83%80%EB%B2%85%EC%8A%A4+%EB%B2%9A%EA%BD%83+md&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=2019+%EC%8A%A4%ED%83%80%EB%B2%85%EC%8A%A4+%EB%B2%9A%EA%BD%83+md&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;
6 나르샤 &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EB%82%98%EB%A5%B4%EC%83%A4&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EB%82%98%EB%A5%B4%EC%83%A4&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;
7 아소방 매트 &lt;a href=&#34;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EC%95%84%EC%86%8C%EB%B0%A9+%EB%A7%A4%ED%8A%B8&amp;amp;sm=top_lve&amp;amp;ie=utf8&#34; target=&#34;_blank&#34;&gt;http://search.naver.com/search.naver?where=nexearch&amp;amp;query=%EC%95%84%EC%86%8C%EB%B0%A9+%EB%A7%A4%ED%8A%B8&amp;amp;sm=top_lve&amp;amp;ie=utf8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;ldquo;&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Technical terms</title>
      <link>/tutorial/it-terminology/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/it-terminology/</guid>
      <description>

&lt;h2 id=&#34;cpu-메모리-ram-스토리지-hdd-ssd&#34;&gt;CPU &amp;amp; 메모리(RAM)&amp;amp; 스토리지(HDD,SSD)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2020-01-04 at 1.44.50 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. CPU : 중앙정보처리장치, 레지스터, 데이터를 연산/처리하는 가장 중요한 부분, 아주 빠름&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;처리속도가 가장 빠르다.&lt;/p&gt;

&lt;p&gt;어떠한 데이터가져와서 처리하려면&lt;/p&gt;

&lt;p&gt;바로 스토리지로 가지 않는다.왜냐하면 느리고 성능이 CUP 를 못따라 온다.&lt;/p&gt;

&lt;p&gt;그래서 메모리를 거쳐 데이터를 가져와서 처리를 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;2. 메모리(RAM)(램) :  CPU에서 직접 접근이 가능, 사용자가 자유롭게 내용을 읽고 쓰고 지울 수 있다. 휘발성 기억장치, 빠름&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;가격이 비싸다&lt;/p&gt;

&lt;p&gt;용량이 적다&lt;/p&gt;

&lt;p&gt;컴퓨터를 끄면 데이터 사라진다.&lt;/p&gt;

&lt;p&gt;메모리가 하드디스크보다 더빠르게 데이터를 저장하고 가져올수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;3. 스토리지(하드디스크) : HDD,SSD, 비휘발성 기억장치, 용량이 아주 크지만 느림&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;가격이 저렴하다.&lt;/p&gt;

&lt;p&gt;용량이 크고 전원이 꺼져도 데이터가 저장된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;cpu&#34;&gt;CPU&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;중앙 처리 장치 또는 CPU (central processing unit)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CPU 처리하는 용도 데이터를 읽고  처리하고  다시쓰는  동작을 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴퓨터 시스템을 통제하고 프로그램의 연산을 실행하는 가장 핵심적인 컴퓨터의 제어 장치, 혹은 그 기능을 내장한 칩을 말한다. 컴퓨터 안의 중앙 처리 장치(CPU)는 외부에서 정보를 입력 받고, 기억하고, 컴퓨터 프로그램의 명령어를 해석하여 연산하고, 외부로 출력하는 역할을 한다. 따라서 중앙 처리 장치(CPU)는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 시스템 전체를 제어하는 장치로, 모든 컴퓨터의 작동과정이 중앙 처리 장치(CPU)의 제어를 받기 때문에 컴퓨터의 두뇌에 해당한다고 할 수 있다. 실제의 CPU 칩엔 실행 부분뿐만 아니라 캐시 등의 부가 장치가 통합된 경우가 많다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CPU에는 MCU(Micro Control Unit)와 주변 장치(외부 확장 장체에 관한 IC)가 다 들어있는 Soc(System On Chip)가 있다. 주변 IC가 따로 달려 있을 경우, 그것은 MCU라고 할 수 있다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;메모리-ram-random-access-memory-이란&#34;&gt;메모리(RAM) (Random Access Memory) 이란?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2020-01-04 at 1.45.00 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;하드디스크와 시피유 사이에서.. 정보를 전송해주는 컴퓨터 부품이구요&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;하드디스크-hdd-ssd&#34;&gt;하드디스크(HDD,SSD)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2020-01-04 at 1.45.17 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  HDD = SSD. 문서 사진 동영상 드라이버 공간 저장하는곳

  SSD  최근 에 나온것 

  SSD 종류

  1. SLD
  장점: 저장공간보다는 속도에 올인 오래쓴다.

  단점: 가격비쌈 MLC 호환성 좋지 않다.

  2. MLC
  장점: 저장공간도 많고 속도적당히 빠름 호환성 좋고 가격좋고, 30년정도 쓴다.

  3. TLC
  장점: 저장 많이 할수 있다. 가장저렴한 가격 10년 수명
  단점: 속도가 많이 떨어진다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;알고리즘이란&#34;&gt;알고리즘이란?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;알고리즘 이란 어떤 값을 입력으로 받아 원하는 값으로 출력하는 잘 정의된 계산 절차 를 말한다. 따라서 알고리즘은 어떤 입력을 어떤 출력으로 변환하는 일련의 계산 과정이라 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;자료구조란&#34;&gt;자료구조란?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;자료구조 란 데이터에 편리하게 접근하고, 변경하기 위해서 데이터를 저장하거나 조직하는 방법 을 말한다. 모든 목적에 맞는 자료구조는 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;자료구조를-왜-알아야-하는가&#34;&gt;자료구조를 왜 알아야 하는가?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;자료구조의 역확은 &lt;code&gt;메모리&lt;/code&gt;의 효율적인 사용하기 위함이라고 할수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ui-ux&#34;&gt;UI&amp;amp;UX&lt;/h2&gt;

&lt;h4 id=&#34;ui-user-interface&#34;&gt;UI (user Interface)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The user interface (UI), in the industrial design field of human–computer interaction, is the space where interactions between humans and machines occur&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;사용자가 제품이나 서비스를 마주할때 말하는 용어&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;아이폰을 보고 있으면 아이폰 UI&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자판기를 보고 있으면 음료자판기 UI&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ux-user-experience&#34;&gt;UX (user experience)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;refers to a person&amp;rsquo;s emotions and attitudes about using a particular product, system or service. It includes the practical, experiential, affective, meaningful and valuable aspects of human–computer interaction and product ownership. Additionally,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;사용자가 제품이나 서비스의 UI를 마주할 때 익숙하게 사용할 수 있도록 하는 요소&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;저런 문구의 UI이를 UX로 전환하면  우리가 보는 핸드폰다이어리 구조가 완성된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;nat&#34;&gt;NAT&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Network Address Translation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NAT 이란 무엇인가?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User 가 웹사이트에 접촉하려고 할때 IP주소가 같지 않아 불가능 하다.하지만 NET이라는 기능으로 인해 private IP주소를 public IP주소로 바꿔주어서 interface 가능하도록 도와준다&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;또한 다음에 또 접촉하려고 했을때 원활한 접근을 위해 기록해둔다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NET 은 두가지를 한다&lt;/li&gt;
&lt;li&gt;접촉할수있게 사용자의 IP주소를 pubilc IP 주소로 바꿔준다.&lt;/li&gt;
&lt;li&gt;다음 원활한 접근을 위해 기록해둔다&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;port&#34;&gt;port&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Port 란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;컴퓨터의 Lan선은 하나인데 통신을 필요로 하는 프로그램이 다수일 때 이 다수의 프로그램을 구별할 수 있는 번호가 Port이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/port.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;port-forwarding&#34;&gt;port forwarding&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;포트포워딩 (Port Forwarding)이란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;포트 포워딩(port forwarding) 또는 포트 매핑(port mapping)은 컴퓨터 네트워크에서 패킷이 라우터나 방화벽과 같은 네트워크 게이트웨이를 가로지르는 동안 하나의 IP 주소와 포트 번호 결합의 통신 요청을 다른 곳으로 넘겨주는 네트워크 주소 변환(NAT)의 응용이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;쉽게 설명하면 부여받은 IP가 외부에서 내 장치에 접근할 수 있도록 포트, 즉 문을 열어주는 것입니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;언제 Port forwarding 사용하는가?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Web server를 자신의 컴퓨터부터 시작하고 싶을때 port forwarding 을 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How dose port forwarding work ?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;사람들이 나의 컴퓨터로 들어오기 위해서는 public IC주소 (wan IP주소를) 알려주어야 한다. &lt;code&gt;BUT&lt;/code&gt;사람들이 Public IP주소로 들어오면 어느곳으로 이동해야하는지 모른다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이것을 실행하기 위한것이 port forwarding 이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How to convert it ? Router port forwarding 설정을 하면된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/prot for1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;내부 IP주소가 web server 를 설치할 컴퓨터IP이고&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;외부 IP주소가 나의 public IP에 주소를 만들 port 번호 이다.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;url&#34;&gt;URL&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 6.07.41 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;첫번째 URL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;protocol&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;indicates how to access the resource&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;IP address and URL name&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;the computer where the resource is located&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;port&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;can be running multiple network applications&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;resource&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;the web server uses this info to identify the resource&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;두번째 URL Query string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;? 문자가 보이면 쿼리&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;passing some info to the web server ? 바로 질러서 접근할수 있게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;세번째 URL Fragment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;# 보이면 재빨리 찾아서 보내준다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;만약 이것이 없다면 resource 가 web sever 에 가서 저장된 모든 것들을 찾아야 하기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;encoding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 6.15.13 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;문자를 다른현태로 바꿔주는것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;더공부할 내용&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ASCII / ANSI / EUC-KR / CP949 / UTF-8 / UNICODE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;client-sever&#34;&gt;Client &amp;amp; sever&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;HTTP://www.santaged.name/2014/07/up=andnwjkd.thml&#34; target=&#34;_blank&#34;&gt;HTTP://www.santaged.name/2014/07/up=andnwjkd.thml&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTTP : 프로토콜&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;www.santaged.name: 웹서버&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2014/07/up=andnwjkd.thml : web Resource in web sever&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FTP_protocol &amp;amp; HTTP_protocol&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTTP_Protocol 은  is merge protocol in the web client and the web server&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FTP protocol is used for transferring files&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is Web Resource&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;간략 하게 말해서 a web client 가 PDC or HTML Document 등등을 web server 를 통해서 접근하는 것들을 web Resource 라고 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;web resource 안에는 &lt;code&gt;static&lt;/code&gt; 와 &lt;code&gt;dynamic&lt;/code&gt; resource 가 담겨있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Statice resource 는 바뀌지 &lt;code&gt;않는&lt;/code&gt; 정보들을 말하고&lt;/p&gt;

&lt;p&gt;Dynmic resource 는 web client 에서 &lt;code&gt;바꾼&lt;/code&gt; 정보드를 반영하는 것들을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;HTTP Transaction &amp;amp; a stateless protocol&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 5.26.30 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a stateless protocol&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a web client  가 요청한 것을 web sever 는 web resource 에서 가져온다.
다음번에 가져올때 이것을 기억못하게 되고 다시 새로운 a web client 가 web sever 에게 접근하게 되는 과정을 a stateless protocol 이라고 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP Transaction&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a web client 가 web sever 에게 요청을 보내고 그 요청된것을 Response 하는 과정을 HTTP Transaction 이라고 부른다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HTTP : &lt;code&gt;H&lt;/code&gt;ypertext &lt;code&gt;T&lt;/code&gt;ransfer &lt;code&gt;P&lt;/code&gt;rotocal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 5.43.03 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it&amp;rsquo;s this combination if HTTP and URL that makes the web work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 5.51.55 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;html-internet&#34;&gt;HTML &amp;amp; Internet&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTTP HTML&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP : &lt;code&gt;H&lt;/code&gt;ypertext &lt;code&gt;T&lt;/code&gt;ransfer &lt;code&gt;P&lt;/code&gt;rotocal&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTML : &lt;code&gt;H&lt;/code&gt;ypertext &lt;code&gt;M&lt;/code&gt;arkup &lt;code&gt;L&lt;/code&gt;anguage&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;브라우저에서 주소를 치면 나의 컴퓨터는 서버컴퓨터에 &lt;code&gt;요청(get)&lt;/code&gt;한다.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;요청할때 이루어지는 언어가 바로 &lt;code&gt;HTTP&lt;/code&gt; 로 이루어 져 있다.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;서버는 요청받은 내용을 &lt;code&gt;브라우저&lt;/code&gt; 에게 &lt;code&gt;HTML&lt;/code&gt; 언어로 &lt;code&gt;전달&lt;/code&gt;해준다.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTPS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTTPS : &lt;code&gt;H&lt;/code&gt;yperText &lt;code&gt;T&lt;/code&gt;ransfer &lt;code&gt;P&lt;/code&gt;rotocol &lt;code&gt;S&lt;/code&gt;ecure&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;해커들을 방지하기 위해 만들어져 보호시켜주는 시스템&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(HTTPS) is an extension of the Hypertext Transfer Protocol (HTTP).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SSL : &lt;code&gt;S&lt;/code&gt;ecure &lt;code&gt;S&lt;/code&gt;ockets &lt;code&gt;L&lt;/code&gt;ayer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TLS : &lt;code&gt;T&lt;/code&gt;ransport &lt;code&gt;L&lt;/code&gt;ayer &lt;code&gt;S&lt;/code&gt;ecurity&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1.IP 와 DNS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;IP : &lt;code&gt;I&lt;/code&gt;nternet &lt;code&gt;P&lt;/code&gt;rotocol&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;간단히 말해서 컴퓨터의 주소 IP&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;IP 주소는 전통적으로 32비트 길이를 가지고 있고 지금은 128비트 긴주소를 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2.DNS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DNS : &lt;code&gt;D&lt;/code&gt;omain &lt;code&gt;N&lt;/code&gt;ame &lt;code&gt;S&lt;/code&gt;ystem&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DNS  는&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 3.47.39 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;어떻게 &lt;code&gt;DNS&lt;/code&gt;는 무엇을 하는가?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.사용자가 웹다른 사이트를 가고싶을때 검색을 하게 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.그럴때 IP 주소를 알야아 하는데&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.그럴때 우리 컴퓨터 안에있는 DNS 가 IP주소를 찾아서 알려준다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.DNS 하나가 모든 정보를 가지고 있지 않기 때문에 친구들에게 물어봐서 알려준다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;DNS 원리과 위험성&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;원리&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DNS 가 하나라면 혼잡하기 때문에 나눠서 연결되도록 설계 되었다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;지역을 나누는 것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 4.04.29 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS 서버는 정부나 교육기관을 위한 공개되어 있고 누구나 사용 가능한 커뮤니케이션 프로토콜로 제작되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;위험성&lt;/em&gt;
  * DNS SPOOFING 이라 불리는 것은 해커들이 DNS 서버에 침입해서 주소를 바꿔서 사용자를 다른곳으로 보내버린다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;3.패킷 과 라우터&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;패킷  (packet)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;정보를-주고받을때-패킷을-통해-전단된다&#34;&gt;정보를 주고받을때 패킷을 통해 전단된다.&lt;/h6&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 4.08.03 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;용량이-많을때-나눠서-보낸다&#34;&gt;용량이 많을때 나눠서 보낸다.&lt;/h6&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 4.09.25 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;라우터&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;패킷을 &lt;code&gt;관리&lt;/code&gt;하는 것이 라우터&lt;/p&gt;

&lt;p&gt;패킷을 나눠서 보낼때 충돌과 교통이 혼잡 할수가 있다 이것을 방지하기 위해 라우터가 그것을 통제한다.&lt;/p&gt;

&lt;p&gt;도착 순서를 다르게 만든다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/Screen Shot 2019-12-16 at 4.10.04 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;TCP&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP : &lt;code&gt;T&lt;/code&gt;ransMission &lt;code&gt;C&lt;/code&gt;ontrol &lt;code&gt;P&lt;/code&gt;rotocol 전송 제어 프로토콜&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;TCP 는 전송중 끊어진 것들을 다시 원활하게 다시 전송할수 있게 만드는 아주 안전한 메일 시스템과 같은 것이다.&lt;/p&gt;

&lt;p&gt;TCP 가 다 모든 패킷 (사용자가 보낸 정보)  가 도착했는지 확인하고 공유한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;url-uri&#34;&gt;URL &amp;amp; URI&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;URL 과 URI 의 차이점&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;(Uniform Resource Locator) : 네트워크상에서 자원이 어디있는지를 알려주는 주소. 정의 뜻으로는 어떤 차이가 있는지 구별이 어렵다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;URI&lt;/code&gt;(Uniform Resource Identifier) : 인터넷에 있는 자원을 식별할 수 있는 유일한 문자열 주소로, 인터넷에서 요구되는 기본조건으로 인터넷 프로토콜과 항상 함께 붙어 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;예) 주소로 차이점을 느껴보자.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://localhost:8080/profile.jsp의&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/profile.jsp의&lt;/a&gt; 뜻은 localhost라는 서버에 profile.jsp 라는 자원이 있다는 걸 알려주는 주소다. 자원의 위치를 알 수 있는 주소기에 uri도 되며 url도 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://localhost:8080/profile.jsp?addr=seoul&amp;amp;age=22&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/profile.jsp?addr=seoul&amp;amp;age=22&lt;/a&gt; 로 url 의 끝에 쿼리 문자열이 붙으면, 이런 주소는 url이 아닌 uri 이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;간단하게 그냥 서버에 있는 자원의 위치 주소에다가 요청 처리에 필요한 값이 포함여부의 차이를 보면 될것 같다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;갑이 포함되면 uri, 포함 안되면 url.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;javascript-와-ecmascript&#34;&gt;JavaScript 와 ECMAScript&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JavaScript는 1996년에 만들어졌고, 그 다음에 JavaScript의 표준화를 위해 1997년에 ECMAScript가 만들어졌습니다. 당시 기준에서 JavaScript는 ECMAScript 사양을 따르고 있었기 때문에, JavaScript는 ECMAScript 사양을 준수하고 있던 언어의 예시였습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;여기서 우리는 재미있는 사실을 하나 알 수 있습니다. 바로, ECMAScript는 JavaScript를 기반으로 하는 동시에, JavaScript 역시 ECMAScript를 기반으로 한다는 거죠.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;둘의 뗄레야 뗄 수 없는 관계, 그리고 그 두 용어가 혼용되어서 사용되던 이유는 바로 여기에서부터 출발하지 않았을까 생각해봅니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;web-storage&#34;&gt;Web storage&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Web storage (웹 스토리지)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;local storage는 우리가 아는 세션과 비슷하고 session storage는 쿠키와 비슷합니다.
자바스크립트로만 읽고 쓰기가 가능해 서버에서 바로 접근할 수 없고 문자열만 관리가 가능하다는 단점이 있습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;하지만 매번 서버로 전송해야하는 쿠키와 달리 불필요한 트래픽이 없고상대적으로 여유로운 저장공간에 문자열을 객체 정보로 저장할 수 있다는 강점이 있죠.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;로컬 스토리지는 만료 기간의 설정이 없기 때문에 브라우저의 종료와 관계 없이 정말 영구적으로 데이터를 저장할 수 있습니다.os를 재설치 하거나 브라우저를 날려버리는 특수한 상황을 제외하고서요.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;또한 모든 페이지가 사용자릐 로컬 스토리지를 공유하고 브라우저창에 관계없이 사이트 별로 생성 됩니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;세션 스토리지는 브라우저 종료시 사라지고, 새 탭이나 다른 브라우저에서 공유할 수 없습니다. 하나의 페이지 안에서 저장되고 살아있는 데이터라고 생각하시면 됩니다. 우리가 하나의 사이트를 접속하면 하나의 세션이 이루어지는 원리입니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/7D12ECCA-909C-4AE9-8788-58DCD391293F.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;proxy-sever&#34;&gt;Proxy sever&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/BD37F54D-B97E-41B5-BEEF-E92F3E0BAFF9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;tls&#34;&gt;TLS&lt;/h2&gt;

&lt;h4 id=&#34;tls-transport-layer-security&#34;&gt;TLS (Transport Layer Security,)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;클라이언트/서버 응용 프로그램이 네트워크로 통신을 하는 과정에서 도청, 간섭, 위조를 방지하기 위해서 설계되었다. 그리고 암호화를 해서 최종단의 인증, 통신 기밀성을 유지시켜준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;cpu-1&#34;&gt;CPU&lt;/h2&gt;

&lt;h4 id=&#34;중앙-처리-장치-또는-cpu-central-processing-unit&#34;&gt;중앙 처리 장치 또는 CPU (central processing unit)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU 처리하는 용도 데이터를 읽고  처리하고  다시쓰는  동작을 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴퓨터 시스템을 통제하고 프로그램의 연산을 실행하는 가장 핵심적인 컴퓨터의 제어 장치, 혹은 그 기능을 내장한 칩을 말한다. 컴퓨터 안의 중앙 처리 장치(CPU)는 외부에서 정보를 입력 받고, 기억하고, 컴퓨터 프로그램의 명령어를 해석하여 연산하고, 외부로 출력하는 역할을 한다. 따라서 중앙 처리 장치(CPU)는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 시스템 전체를 제어하는 장치로, 모든 컴퓨터의 작동과정이 중앙 처리 장치(CPU)의 제어를 받기 때문에 컴퓨터의 두뇌에 해당한다고 할 수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;실제의 CPU 칩엔 실행 부분뿐만 아니라 캐시 등의 부가 장치가 통합된 경우가 많다.
CPU에는 MCU(Micro Control Unit)와 주변 장치(외부 확장 장체에 관한 IC)가 다 들어있는 Soc(System On Chip)가 있다. 주변 IC가 따로 달려 있을 경우, 그것은 MCU라고 할 수 있다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ssl&#34;&gt;SSL&lt;/h2&gt;

&lt;h4 id=&#34;ssl-secure-sockets-layer-보안-소켓-계층&#34;&gt;SSL (Secure Sockets Layer)  보안 소켓 계층&lt;/h4&gt;

&lt;p&gt;*월드 와이드 웹 브라우저와 웹 서버 간에 데이터를 안전하게 주고받기 위한 업계 표준 프로토콜. 미국 넷스케이프 커뮤니케이션스사가 개발했고, 마이크로소프트사 등 주요 웹 제품 업체가 채택하고 있다. SSL은 웹 제품뿐만 아니라 파일 전송 규약(FTP) 등 다른 TCP/IP 애플리케이션에 적용할 수 있으며, 인증 암호화 기능이 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;인증은 웹 브라우저와 웹 서버 간에 서로 상대의 신원을 확인하는 기능이다. 예를 들면, 웹 브라우저를 사용하는 웹 서버를 사용한 가상 점포의 진위(眞僞) 여부를 조사할 수 있다. 암호화 기능을 사용하면 주고받는 데이터가 인터넷상에서 도청되는 위험성을 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;메소드란&#34;&gt;메소드란?&lt;/h2&gt;

&lt;h4 id=&#34;객체안에-함수가-들어있는것이-메소드&#34;&gt;객체안에 함수가 들어있는것이 메소드&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 객체 만든다 
// obj 의 키는 foo
// foo 의 값은 function()
// obj.foo() 메소드 호출한것이다. 
obj = {
    foo: function () {
        return “hello world”
    }
  }

obj.foo() // “hello world” 
// 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ascii-아키스&#34;&gt;ASCII(아키스)&lt;/h2&gt;

&lt;h4 id=&#34;아키스-코드란-무엇인가&#34;&gt;아키스 코드란 무엇인가?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ASCII (American Standard Code for Information Interchange, 미국 정보 교환 표준 부호)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;영문 알파벳을 사용하는 대표적인 문자 코딩&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴퓨터는 0과 1 숫자 밖에 모르기 때문에 문자도 숫자로 기억합니다. 이때, 어떤 숫자와 어떤 문자를 대응시키는가에 따라 여러 가지 인코딩 방식이 있는데 통상 아스키 코드 방식을 많이 사용합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;아스키 코드(ASCII Table)는 0번부터 127번까지만 사용합니다. 127번 이후 코드를 사용했던 적도 있었는데 이는 표준이 아니며 운영체제마다 다른 코드(문자)를 배치했기 때문에 호환이 되지 않습니다. 윈도우즈 운영체제는 현재 128번부터 255번 사이에 포함된 문자를 출력하려는 시도에 대해 물음표(?)를 출력해서 사용하면 안된다는 것을 알려줍니다. 128번과 255번 문자는 물음표는 아니지만 사용할 수 없는 문자입니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ascii-table-아스키-코드표&#34;&gt;ASCII Table (아스키 코드표 )&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/IT terminology_files/ASCII Table.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;ex&#34;&gt;ex)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;alphabetPosition 함수 만들기&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In this exercise, you are required to, given a string, replace every letter with its position in the alphabet. (문자열이 주어졌을때, 각각의 문자를 알파벳의 몇번째 인지 숫자로 바꾸는 함수를 작성하세요.) If anything in the text isn&amp;rsquo;t a letter, ignore it and don&amp;rsquo;t return it. a being 1, b being 2, etc. (만약 문자가 알파벳이 아니라면, 무시하고 결과값에 포함하지 마세요. a 는 1, b 는 2, 등등 으로 변환됩니다.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;output&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alphabetPosition(&amp;quot;The sunset sets at twelve o&#39; clock.&amp;quot;); 
// &amp;quot;20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var alphabetPosition = function (str) {
 // Your code here
 let output = [];
 // 1. 배열로 바꾼다
 let temp = str.toUpperCase();
 // 2. THE SUNSET SETS AT....
 for(let i=0;i&amp;lt;temp.length;i++){
   if(typeof(temp[i]) ===&#39;string&#39;){
     if(temp[i].charCodeAt(0) - 64 &amp;gt; 0)
       output.push(temp[i].charCodeAt(0) - 64);
   }
 }
 return output.join(&#39; &#39;);
}



&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__Algorithm_1</title>
      <link>/tutorial/2019-11-14-javascript-daliy-coding-level-1/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2019-11-14-javascript-daliy-coding-level-1/</guid>
      <description>

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;longestword&#34;&gt;longestWord&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Using the JavaScript language, have the function LongestWord take the sen parameter being passed and return the largest word in the string. (문장이 주어졌을때, &amp;lsquo;LongestWord&amp;rsquo; 함수는 주어진 문장에서 가장 긴 단어를 반환합니다.)&lt;/p&gt;

&lt;p&gt;If there are two or more words that are the same length, return the first word from the string with that length. Assume sen will not be empty. (만약 가장 긴 단어가 두개 이상이라면, 첫번째로 등장하는 가장 긴 단어를 반환하세요. 문장은 빈 문자열이 아닙니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It&#39;s used by sort() 

function longestWord(string) {

 // 1. 주어진 문장을 배열로 만들기(split)
 let tmp = string.split(&#39; &#39;);
 //let sorted_tmp =[];
 // [&#39;I&#39;,&#39;love&#39;,&#39;codestates&#39;];
 // 2. sort() 사용 =&amp;gt; 성능 떨어짐
 let x = function(a,b){
   return b.length-a.length;
 };
 // 3. 0번째 요소 출력
 return tmp.sort(x)[0];
}

////////////////////////////////////////////////////////

// It&#39;s used by reudce(1)

function longestWord(string) {
 
 let tmp = string.split(&#39; &#39;);
 let max = tmp[0];
 for(let i =1;i&amp;lt;tmp.length;i++){
   if(tmp[i].length&amp;gt;max.length){
     max = tmp[i];
   }
 }
 return max;
}


/////////////////////////////////////////////////////////

// It&#39;s used by reudce(2) 화살표

function longestWord(string) {

return string.split(&#39; &#39;).reduce((acc,cur)=&amp;gt; acc.length&amp;lt;cur.length? cur:acc);
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-1&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;firstcharacter&#34;&gt;firstCharacter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;In this exercise, a string is passed to a method and a new string has to be returned with the first character of each word in the string (문자열이 주어졌을때, &amp;ldquo;firstCharacter&amp;rdquo; 함수는 문자열의 각 단어 첫글자들로 이루어진 문자열을 반환하여야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-1&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function firstCharacter (string) {
 // Your code here
 
 
 // 1. for문 이용
 
 let output = [];
 let temp_arr = [];

 // 1. split으로 단어로 나눠서 배열 만들기
 
 temp_arr = string.split(&#39; &#39;);
 // 2. 각 인덱스의 첫번째 문자를 배열 output 에 담기
 for(let i=0;i&amp;lt;temp_arr.length;i++){
   output.push(temp_arr[i][0]);
 }
 
 // 4. 출력
 return output.join(&#39;&#39;);
 
 
 
 ////////////////////////////////////////////////////////////////////////
 
 // 2. Reduce 이용
 return string.split(&#39; &#39;).reduce(function(acc,cur){
   return acc+cur[0];
 
 },&#39;&#39;);
 
 // 3. Reduce이용 2
 return string.split(&#39; &#39;).reduce( (acc,cur)=&amp;gt;acc+cur[0] ,&#39;&#39;);
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-2&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isoldenoughtodrink&#34;&gt;isOldEnoughToDrink&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;어떤 숫자, 이 경우에는 연령이 하나 주어졌을 때, isOldEnoughToDrink 함수는 주어진 연령의 사람이 미국에서 합법적으로 술을 마실 수 있는지의 여부를 반환해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-2&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function isOldEnoughToDrink(age) {
  // 여기에 코드를 작성하세요
  if (age &amp;lt; 21 ) {
    return false;
  } else {
    return true;
  }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-3&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;checkage&#34;&gt;checkAge&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;이름과 나이를 파라미터로 받는 checkAge라는 함수는 두개 중 하나의 메시지를 리턴합니다.&lt;/p&gt;

&lt;p&gt;만일 21살보다 적으면, Go home, {전달받은_이름}! 만일 21살이거나 더 나이가 많으면, Welcome, {전달받은_이름}! 을 리턴하세요. 쉼표와 공백, 느낌표까지 정확히 리턴해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-3&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function checkAge(name, age) {
  // 여기에 코드를 작성하세요
  if (age &amp;gt;= 21){
    return &#39;Welcome, &#39; + name+ &#39;!&#39;;
  } else {
    return &#39;Go home, &#39; + name+ &#39;!&#39;;
  }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-4&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;equalsten&#34;&gt;equalsTen&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;equalsTen&amp;rdquo;. (&amp;ldquo;equalsTen&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;equalsTen&amp;rdquo; returns whether or not the given number is 10. (&amp;ldquo;숫자가 주어졌을때, &amp;ldquo;equalsTen&amp;rdquo; 함수는 숫자가 10과 같은지 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-4&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function equalsTen(num) {
  // 여기에 코드를 작성하세요
  if ( num !== 10){
    return false;
  }else if (num === 10 ){
    return true;
  }
}

equalsTen(10);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-5&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isgreaterthan&#34;&gt;isGreaterThan&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isGreaterThan&amp;rdquo;. (&amp;ldquo;isGreaterThan&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 2 numbers, &amp;ldquo;isGreaterThan&amp;rdquo; returns whether num2 is greater than num1. (두 숫자가 주어졌을때, &amp;ldquo;isGreaterThan&amp;rdquo; 함수는 두번째 숫자(num2)가 첫번째 숫자(num1)보다 큰지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-5&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function isGreaterThan(num1, num2) {
  // 여기에 코드를 작성하세요
  if ( num1 === num2 ){
    return false;
  } else if ( num1 &amp;lt; num2) {
    return true;
  } else {
    return false;
  }
}

isGreaterThan(20,30)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-6&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;iseven&#34;&gt;isEven&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEven&amp;rdquo;. (&amp;ldquo;isEven&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;isEven&amp;rdquo; returns whether it is even. (&amp;ldquo;숫자가 주어졌을때, &amp;ldquo;isEven&amp;rdquo; 함수는 주어진 숫자가 짝수인지 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-6&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function isEven(num) {
  // 여기에 코드를 작성하세요
  if ( num % 2 === 0 ) {
    return true;
  } else {
    return false;
  }

}

isEven(21)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-7&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isevenandgreaterthanten&#34;&gt;isEvenAndGreaterThanTen&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo;. (&amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo; returns whether it is both even and greater than 10. (숫자가 주어졌을때, &amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo; 함수는 주어진 숫자가 10보다 크고 짝수인지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-7&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function isEvenAndGreaterThanTen(num) {
  // 여기에 코드를 작성하세요
  if ( num % 2 === 0 &amp;amp;&amp;amp; num &amp;gt; 10 ){
    return true;
  } else {
    return false;
  }
}
isEvenAndGreaterThanTen(13);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-8&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertscoretograde&#34;&gt;convertScoreToGrade&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;convertScoreToGrade&amp;rdquo;. (&amp;ldquo;convertScoreToGrade&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a score, &amp;ldquo;convertScoreToGrade&amp;rdquo; returns a string representing the letter grade corresponding to the given score. (점수가 주어졌을때, &amp;ldquo;convertScoreToGrade&amp;rdquo; 함수는 주어진 점수와 대응하는 등급을 문자열로 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-8&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function convertScoreToGrade(score) {
  // 여기에 코드를 작성하세요
  if ( score &amp;gt; 100 || score &amp;lt; 0) {
    return &amp;quot;INVALID SCORE&amp;quot;;
  } else if ( score &amp;gt;= 90 ) {
    return &amp;quot;A&amp;quot;;
  } else if ( score &amp;gt;= 80 ) {
    return &amp;quot;B&amp;quot;;
  } else if ( score &amp;gt;= 70 ) {
    return &amp;quot;C&amp;quot;;
  } else if ( score &amp;gt;= 60 ) {
    return &amp;quot;D&amp;quot;;
  } else {
   return &#39;F&#39;;
  }
}
convertScoreToGrade(0);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-9&#34;&gt;Question&lt;/h3&gt;

&lt;h3 id=&#34;or&#34;&gt;Or&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;or&amp;rdquo;. (&amp;ldquo;or&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 2 boolean expressions, &amp;ldquo;or&amp;rdquo; returns true or false, corresponding to the || operator. (boolean 두개가 주어졌을때, &amp;ldquo;or&amp;rdquo; 함수는 || 연산자에 대응하는 true 나 false 를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-9&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function or(expression1, expression2) {
  // 여기에 코드를 작성하세요
  if ( expression1 !== false  ) {
    return true;
  } else if ( expression2 !== false ) {
    return true;
  } else {
    return false;
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-10&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;iseitherevenandlessthan9&#34;&gt;isEitherEvenAndLessThan9&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEitherEvenAndLessThan9&amp;rdquo;. (&amp;ldquo;isEitherEvenAndLessThan9&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two numbers, &amp;lsquo;isEitherEvenAndLessThan9&amp;rsquo; returns whether at least one of them is even, and, both of them are less than 9. (숫자 두개가 주어졌을때, &amp;lsquo;isEitherEvenAndLessThan9&amp;rsquo; 함수는 2가지 조건을 검사합니다. 우선 두 숫자 중 적어도 하나가 짝수인지, 그리고 두 숫자 모두 9보다 작은지를 확인합니다. 두 조건을 모두 만족 했을 때만 true를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-10&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function isEitherEvenAndLessThan9(num1, num2) {
  if ((num1 % 2 === 0 || num2 % 2 === 0) &amp;amp;&amp;amp; (num1 &amp;lt; 9 &amp;amp;&amp;amp; num2 &amp;lt; 9)) {
    return true;
  } else {
    return false;
  }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;question-getfullname&#34;&gt;Question : getFullName&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getFullName&amp;rdquo;. (&amp;ldquo;getFullName&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a first and a last name, &amp;ldquo;getFullName&amp;rdquo; returns a single string with the given first and last names separated by a single space. (이름과 성이 주어졌을때, &amp;ldquo;getFullName&amp;rdquo; 함수는 이름과 성이 띄어쓰기 하나를 사이에 둔 단일 문자열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-11&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getFullName(firstName, lastName) {
  // 여기에 코드를 작성하세요
  let output = firstName + lastName;
  return firstName + &amp;quot; &amp;quot; + lastName;
}
  
getFullName(&#39;john&#39;,&#39;jung&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-11&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlengthofword&#34;&gt;getLengthOfWord&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLengthOfWord&amp;rdquo;. (&amp;ldquo;getLengthOfWord&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;getLengthOfWord&amp;rdquo; returns the length of the given word. (단어가 주어졌을때, &amp;ldquo;getLengthOfWord&amp;rdquo; 함수는 단어의 길이를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-12&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getLengthOfWord(word) {
  // 여기에 코드를 작성하세요
  let count = word.length;
  return count;
}
getLengthOfWord(&amp;quot;hello&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-12&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeaveragelengthofwords&#34;&gt;computeAverageLengthOfWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeAverageLengthOfWords&amp;rdquo;. (&amp;ldquo;computeAverageLengthOfWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two words, &amp;ldquo;computeAverageLengthOfWords&amp;rdquo; returns the average of their lengths. (두 단어가 주어졌을때, &amp;ldquo;computeAverageLengthOfWords&amp;rdquo; 함수는 두 단어 길이의 평균값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-13&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function computeAverageLengthOfWords(word1, word2) {
  // your code here
  // count
  var firstNum = word1.length;
  var sceondNum = word2.length;
  var ret = (firstNum + sceondNum) / 2;
  return ret;
  }
  computeAverageLengthOfWords(&amp;quot;whatIYouDoing?&amp;quot;,&amp;quot;this is JJ&amp;quot;)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-13&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isoddlength&#34;&gt;isOddLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isOddLength&amp;rdquo;. (&amp;ldquo;isOddLength&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;isOddLength&amp;rdquo; returns whether the length of the given word is odd. (단어가 주어졌을때, &amp;ldquo;isOddLength&amp;rdquo; 함수는 주어진 단어의 길이가 홀수인지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-14&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function isOddLength(word) {
  // your code here
  let countNum = word.length;
  if ( countNum % 2 !== 0) {
    return true;
  } else {
    return false;
  }
}

isOddLength(&amp;quot;heeeee&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-14&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isevenlength&#34;&gt;isEvenLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEvenLength&amp;rdquo;. (&amp;ldquo;isEvenLength&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;isEvenLength&amp;rdquo; returns whether the length of the word is even. (단어가 주어졌을때, &amp;ldquo;isEvenLength&amp;rdquo; 함수는 주어진 단어의 길이가 짝수인지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-15&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function isEvenLength(word) {
  // your code here
  var countNum = word.length;
  if ( countNum % 2 === 0 ) {
    return true;
  } else {
    return false;
  }
}

isEvenLength(&amp;quot;hee&amp;quot;)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-15&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;repeatstring&#34;&gt;repeatString&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;repeatString&amp;rdquo;. (&amp;ldquo;repeatString&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a string and a number, &amp;ldquo;repeatString&amp;rdquo; returns the given string repeated the given number of times. (문자열과 숫자가 주어졌을때, &amp;ldquo;repeatString&amp;rdquo; 함수는 주어진 문자열을 주어진 숫자만큼 반복하여 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-16&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function repeatString(string, num) {
  // your code here
 var repeatation = string.repeat(num) 
 return repeatation;
}

repeatString(&amp;quot;thewordofGod is the way&amp;quot;,50)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-16&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;findshortestofthreewords&#34;&gt;findShortestOfThreeWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;findShortestOfThreeWords&amp;rdquo;. (&amp;ldquo;findShortestOfThreeWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 3 strings, &amp;ldquo;findShortestOfThreeWords&amp;rdquo; returns the shortest of the given strings. (문자열 3개가 주어졌을때, &amp;ldquo;findShortestOfThreeWords&amp;rdquo; 함수는 주어진 문자열 중 가장 짧은 문자열을 반환해야 합니다.)&lt;/p&gt;

&lt;p&gt;If there are ties, it should return the first word in the parameters list. (만약 동률이 있다면, 그 중 앞에 있는 문자열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-17&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function findShortestOfThreeWords(word1, word2, word3) {
  // your code here
  if ( word1.length &amp;lt; word2.length &amp;amp;&amp;amp; word3.length ) {
    return word1;
  } else if (word1.length === word2.length &amp;amp;&amp;amp; word3.length){
    return word1;
  } else if ( word2.length &amp;lt; word1.length &amp;amp;&amp;amp; word3.length ){
  return word2;
  } else if ( word3.length &amp;lt; word2.length &amp;amp;&amp;amp; word1.length ) {
    return word3;
  }
}

findShortestOfThreeWords(&amp;quot;111&amp;quot;,&amp;quot;222&amp;quot;,&amp;quot;333333333&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-17&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;countcharacter&#34;&gt;countCharacter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;countCharacter&amp;rdquo;. (&amp;ldquo;countCharacter&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a string input and a character, &amp;ldquo;countCharacter&amp;rdquo; returns the number of occurences of a given character in the given string. (문자열과 문자가 주어졌을때, &amp;ldquo;countCharacter&amp;rdquo; 함수는 주어진 문자열에서 주어진 문자가 몇개가 있는지를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-18&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function countCharacter(str, char) {
  // your code here
  let countRet = 0;
  for ( let i = 0; i &amp;lt; str.length; i = i + 1 ) {
    if ( str.charAt(i) === char ) {
      countRet = countRet + 1 ;
    }
  }
  return countRet;
}

countCharacter(&amp;quot;hello&amp;quot;, &amp;quot;l&amp;quot; );



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-18&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;arevalidcredentials&#34;&gt;areValidCredentials&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;areValidCredentials&amp;rdquo;. (&amp;ldquo;areValidCredentials&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a name and a password, &amp;ldquo;areValidCredentials&amp;rdquo;, returns true if the name is longer than 3 characters, AND, the password is at least 8 characters long. Otherwise it returns false. (이름과 비밀번호가 주어졌을때, &amp;ldquo;areValidCredentials&amp;rdquo; 함수는 이름이 3글자이상 그리고 비밀번호가 8글자 이상이면 true를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-19&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ex1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function findMinLengthOfThreeWords(word1, word2, word3) {
  // your code here
  if (word1.length === (word2.length &amp;amp;&amp;amp; word3.length)){
    return word1.length
  } else if (word1.length &amp;lt; (word2.length &amp;amp;&amp;amp; word3.length)){
    return word1.length;
  } else if (word2.length &amp;lt; (word1.length &amp;amp;&amp;amp; word3.length) ){
    return word2.length;
  } else if (word3.length &amp;lt; (word1.length &amp;amp;&amp;amp; word2.length) ){
    return word3.length;
  }
}

findMinLengthOfThreeWords(&amp;quot;111&amp;quot;,&amp;quot;2222&amp;quot;,&amp;quot;33333&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMinLengthOfThreeWords(word1, word2, word3) {
  var arr = [];
  arr.push(word1, word2, word3);
  arr.sort();
  return arr[0].length;
}
findMinLengthOfThreeWords(&amp;quot;dwdsdsdsdsdsdsdwd&amp;quot;,&amp;quot;ddwwd&amp;quot;,&amp;quot;wdwdwdsdsdwdwwd&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMinLengthOfThreeWords(word1, word2, word3) {
  // your code here
  /* START SOLUTION */
  words = [word1, word2, word3];
  return words.sort()[0].length;
  /* END SOLUTION */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMinLengthOfThreeWords(word1, word2, word3) {
  return Math.min(word1.length, word2.length, word3.length)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-19&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeareaofatriangle&#34;&gt;computeAreaOfATriangle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given the base and height of a triangle, &amp;ldquo;computeAreaOfATriangle&amp;rdquo; returns its area. (삼각형의 밑변과 높이가 주어졌을때, &amp;ldquo;computeAreaOfATriangle&amp;rdquo; 함수는 삼각형의 넓이를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-20&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function computeAreaOfATriangle(base, height) {
  // your code here
  let ret = base * height / 2;
  return ret;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-20&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeperimeterofacircle&#34;&gt;computePerimeterOfACircle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computePerimeterOfACircle&amp;rdquo;. (&amp;ldquo;computePerimeterOfACircle&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given the radius of a circle, &amp;ldquo;computePerimeterOfACircle&amp;rdquo; returns its perimeter. (원의 반지름이 주어졌을때, &amp;ldquo;computePerimeterOfACircle&amp;rdquo; 함수는 원의 둘레를 반환하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-21&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function computePerimeterOfACircle(radius) {
  // your code here\
  //원의 둘레 = 2 X 반지름 X 원주율 = 지름 X 원주율
  let ret = radius * 2 * Math.PI;
  return ret;
}

computePerimeterOfACircle(200);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-21&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeaverageofnumbers&#34;&gt;computeAverageOfNumbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeAverageOfNumbers&amp;rdquo;. (&amp;ldquo;computeAverageOfNumbers&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;computeAverageOfNumbers&amp;rdquo; returns their average. (숫자이 배열이 주어졌을때, &amp;ldquo;computeAverageOfNumbers&amp;rdquo; 함수는 그들의 평균을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-22&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function computeAverageOfNumbers(nums) {
  // your code here
  let sum = 0;
  if ( nums.length === 0 ) {
    return 0;
  }
  for (let i = 0; i &amp;lt; nums.length; i = i + 1 ){
    sum = sum + nums[i]
  }
  return sum / nums.length; 
}
computeAverageOfNumbers[1,2,3,4,5,6];

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-22&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;converttostring&#34;&gt;convertToString&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;convertToString함수가 있습니다. 이 함수는 주어진 파라미터를 문자열의 형태로 변환합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-23&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertToString(anything) {
  // 여기에 코드를 작성하세요
  return anything.toString();
  // return &amp;quot;&amp;quot; + anything;
  // return String(anything);
}

convertToString(&#39;hello&#39;)




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-23&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;converttonumber&#34;&gt;convertToNumber&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;convertToNumber함수가 있습니다. 이 함수는 주어진 파라미터를 숫자의 형태로 변환합니다.&lt;/p&gt;

&lt;p&gt;숫자로 변환할 수 없는 경우, NaN (Not a number) 이라는 결과가 나올것입니다. NaN은 숫자가 아님을 나타내는 특수한 값으로, 문자열이 아닙니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soution&#34;&gt;My_Soution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertToNumber(anything) {
  anything = Number(anything);
  
  if(!anything){
    return NaN;
  }else{
    return anything;
  }
}
convertToNumber(&#39;hello&#39;)



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-24&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isfalsy&#34;&gt;isFalsy&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;isFalsy함수가 있습니다. falsy 값은, 거짓으로 취급되는 값을 의미합니다. 이 함수는 주어진 파라미터가 falsy값인지 아닌지를 평가합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-24&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isFalsy(anything) {
  // 여기에 코드를 작성하세요
   if ( typeof anything === &#39;undefined&#39; ) {
      return true;
    } else if (!anything) {
      return true;
    } else if ( anything === null ) {
      return true;
    } else if ( anything === 0 ) {
      return true;
    } else if (anything === NaN ) {
      return true;
    } else if ( anything === &#39;&#39; ) {
      return true;
    } else {
      return false;
    }
} 

isFalsy(&#39;hello&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-25&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;gettype&#34;&gt;getType&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;getType함수가 있습니다. 이 함수는 주어진 파라미터의 타입을 리턴합니다.&lt;/p&gt;

&lt;p&gt;Note:
배열을 넘길 경우, &amp;lsquo;object&amp;rsquo;라고 나올 수 있습니다. 배열과 객체는 어떻게 구분할 수 있을까요?
배열과 객체를 구분하려면 Array.isArray 메소드를 사용하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-25&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getType(anything) {
  // 여기에 코드를 작성하세요
  // if 문을 사용해서 문자,숫자, boolean , arry, object 을 구분하는 것을 사용한다.
  if (Array.isArray(anything) === true ) {
    return &#39;array&#39;
  } else 
  return typeof anything;
}


getType([1,2,3,4])

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-26&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getproperty&#34;&gt;getProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;파라미터로 객체와 키를 받는 getProperty함수가 있습니다. 이 함수는 주어진 객체와 키를 이용하여 속성값을 찾아 리턴합니다.
만일 주어진 키가 객체의 속성에 없다면, undefined를 리턴하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-26&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getProperty(obj, propertyName) {
  return obj[propertyName];
}
let person = {
  name: &#39;Steve&#39;,
  age: 16
};

getProperty(person,&amp;quot;name&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-27&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addproperty&#34;&gt;addProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;파라미터로 객체와 키를 받는 addProperty 함수가 있습니다. 이 함수는 주어진 객체에, 키 이름으로 속성을 만들고 값을 true로 설정합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-27&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function addProperty(obj, propertyName) {
  // 여기에 코드를 작성하세요
  return obj[propertyName] = true;
  // return obj.propertyNmae = true; &amp;lt;&amp;lt;&amp;lt;is not working at all
  }

let john = {};

addProperty(john,&#39;isprogrammer&#39;);




// Questoin


/*
obj[propertyName]를 이용했을 때는 테스트가 통과가 되고,
obj.propertyName를 이용했을 때는 통과가 되지 않습니다.
객체에 프로퍼티를 추가할 때 dot노테이션을 사용할 수 있는 걸로 알고있는데..이유가 뭘까요?


answer

으로 했을때는 바로 객체의 키로 접근하고 [ ] 으로 하면 변수로 접근합니다.
addProperty(steve, &#39;isProgrammer&#39;); 이라는 함수 호출 구문이 있다고 가정하면
obj[propertyName] = true; 는 steve.isProgrammer = true; 이고
obj.propertyName = true; 는 steve.propertyName = true; 입니다. 완전히 다른값이 
나오죠?

*/






&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-28&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addobjectproperty&#34;&gt;addObjectProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;파라미터로 두 개의 객체와 키를 받는 addObjectProperty 함수가 있습니다. 이 함수는 주어진 첫번째 객체에, 키 이름으로 속성을 만드는데, 그 값은 두번째 객체로 설정합니다.
객체의 키 값은 또다른 객체가 될 수 있음을 기억하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-28&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function addObjectProperty(obj1, propertyName, obj2) {
  // 여기에 코드를 작성합니다.
  obj1[propertyName] = obj2; 
  return obj1;
}
let person1 = {
  name: &#39;Joe&#39;,
  role: &#39;Team Member&#39;
};
let person2 = {
  name: &#39;Steve&#39;,
  role: &#39;CEO&#39;
};


addObjectProperty(person1, &#39;manager&#39;, person2);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-29&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeproperty&#34;&gt;removeProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeProperty&amp;rdquo;. (&amp;ldquo;removeProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;removeProperty&amp;rdquo; removes the given key from the given object. (객체와 키가 주어졌을때, &amp;ldquo;removeProperty&amp;rdquo; 함수는 주어진 키에 해당하는 객체의 속성값을 제거해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-29&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeProperty(obj, propertyName) {
  // 여기에 코드를 작성하세요
  delete obj[propertyName];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-30&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;ispersonoldenoughtovote&#34;&gt;isPersonOldEnoughToVote&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isPersonOldEnoughToVote&amp;rdquo;. (&amp;ldquo;isPersonOldEnoughToVote&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a &amp;ldquo;person&amp;rdquo; object, that contains an &amp;ldquo;age&amp;rdquo; property, &amp;ldquo;isPersonOldEnoughToVote&amp;rdquo; returns whether the given person is old enough to vote. (&amp;ldquo;age&amp;rdquo; 속성을 가지고 있는 &amp;ldquo;person&amp;rdquo; 객체가 주어졌을때, &amp;ldquo;isPersonOldEnoughToVote&amp;rdquo; 함수는 그 사람이 미국에서 합법적으로 투표를 할 수 있는 나이인지를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isPersonOldEnoughToVote(person) {
  // your code here
  // 1. if 사용해서 18세 이상일 경우 리턴 참
  // 2. 아닐경우 거짓
  if ( person.age &amp;gt;= 18 ) {
    return true;
  } else {
    return false;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-31&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removenumberslargerthan&#34;&gt;removeNumbersLargerThan&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeNumbersLargerThan&amp;rdquo;. (&amp;ldquo;removeNumbersLargerThan&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number and an object, &amp;ldquo;removeNumbersLargerThan&amp;rdquo; removes any properties whose values are numbers greater than the given number. (숫자와 객체가 주어졌을때, &amp;ldquo;removeNumbersLargerThan&amp;rdquo; 함수는 주어진 객체에서 주어진 숫자보다 큰 모든 숫자 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-30&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let obj = {
  a: 8,
  b: 2,
  c: &#39;montana&#39;,
  d: 10,
  e: 4,
  f: 5
}

function removeNumbersLargerThan(num, obj) {
  // your code here
  for (let key in obj){
    if ( obj[key] &amp;gt; num ) {
    delete obj[key];
    }
  }
return obj;
}

removeNumbersLargerThan(3,obj)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-32&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeoddvalues&#34;&gt;removeOddValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeOddValues&amp;rdquo;. (&amp;ldquo;removeOddValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeOddValues&amp;rdquo; removes any properties whose values are odd numbers. (객체가 주어졌을때, &amp;ldquo;removeOddValues&amp;rdquo; 함수는 주어진 객체의 속성값이 홀수인 속성을 모두 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-31&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let obj = {
  a: 2,
  b: 3,
  c: 4,
  d: 7
};
function removeOddValues(obj) {
  // your code here
  // 1. value 을 불러온다
  // 2. value 홀수 있지 짝수 인지 구분한다.
  // 3. value 가 홀수 일때 삭제한다.
  for ( let key in obj ) {
    if ( obj[key] % 2 === 1 ) {
      delete obj[key];
    }
  }
  return obj;
  }
  removeOddValues(obj)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-33&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;countnumberofkeys&#34;&gt;countNumberOfKeys&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;countNumberOfKeys&amp;rdquo;. (&amp;ldquo;countNumberOfKeus&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;countNumberOfKeys&amp;rdquo; returns how many properties the given object has. (객체가 주어졌을때, &amp;ldquo;countNumberOfKeys&amp;rdquo; 함수는 객체안에 있는 속성들의 갯수를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-32&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function countNumberOfKeys(obj) {
  // 여기에 코드를 작성하세요
  // 1.숫자출력할 변수를 0으로 초기화한다.
  // 2.for 문을 이용해 객체를 나열한다.
  // 3. 나열한 객체를 변수안에 넣는다.
  let count = 0;
  for ( let key in obj ) {
    count = count + 1 ;
    }
    return count;
}

let obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4
};
countNumberOfKeys(obj)



// * Model Solutions

function countNumberOfKeys(obj) {
  return Object.keys(obj).length;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-34&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;printobject&#34;&gt;printObject&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;객체를 파라미터로 받는 printObject 함수는 객체 안에 정의된 키와 값 쌍을 조합한 문자열을 리턴합니다. 문자열은 한 줄에 하나의 키/값 쌍을 콜론(:) 및 공백문자와 함께 표시하며, 또다른 키/값 쌍 사이에는 줄바꿈 문자가 포함되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-33&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
let obj = { name: &#39;Steve&#39;, age: 13, sex: &#39;Male&#39; };

function printObject(obj) {
  let ret = &amp;quot;&amp;quot;
  for ( let key in obj ) {
    ret = ret + key +&amp;quot;: &amp;quot; + obj[key]+ &amp;quot;\n&amp;quot;;
  }
  return ret;
};
printObject(obj);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-35&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;extends&#34;&gt;extends&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;extend&amp;rdquo;. (&amp;ldquo;extend&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two objects, &amp;ldquo;extend&amp;rdquo; adds properties from the 2nd object to the 1st object. (객체 두개가 주어졌을때, &amp;ldquo;extend&amp;rdquo; 함수는 두번째 객체의 속성을 첫번째 객체에 추가해야 합니다.)&lt;/p&gt;

&lt;p&gt;Add any keys that are not in the 1st object. (첫번째 객체에 없는 모든 키를 추가하세요.)&lt;/p&gt;

&lt;p&gt;If the 1st object already has a given key, ignore it (do not overwrite the property value). (만약 첫번째 객체에 이미 있는 키라면, 값을 덮어쓰지 말고 무시하세요.)&lt;/p&gt;

&lt;p&gt;Do not modify the 2nd object at all. (두번째 객체는 수정하지 마세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-34&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
et obj1 = {
  a: 1,
  b: 2
};
let obj2 = {
  b: 4,
  c: 3
};

function extend(obj1, obj2) {

  // 여기에 코드를 작성하세요
  // 1. obj2 의 key들을 반복합니다.
  // 2. obj2 안에 있는 key 가  obj1 key 안에에 포함 되어있는지 if 문을 써서 확인한다.
  // 4. 포함되어있지 않으면 ob1에 추가한다.
  
  for ( let key in obj2 ) {
      if (!( key in obj1 )) {
        obj1[key] = obj2[key];
      }
    }
  }
  

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-36&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;countallcharacters&#34;&gt;countAllCharacters&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;countAllCharacters&amp;rdquo;. (&amp;ldquo;countAllCharacters&amp;rdquo; 함수를 작성하세요&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Given a string, &amp;ldquo;countAllCharacters&amp;rdquo; returns an object where each key is a character in the given string. The value of each key should be how many times each character appeared in the given string. (문자열이 주어졌을때, &amp;ldquo;countAllCharacters&amp;rdquo; 함수는 주어진 문자열의 각각의 문자를 키로 가지는 객체를 반환합니다. 각 키의 값은 해당 문자가 주어진 문자열에서 몇번 나오는지를 나타냅니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function countAllCharacters(str) {
  let obj = {};
  for (let i = 0; i &amp;lt; str.length; i++) { // input으로 받은 문자열에서 하나의 character씩 loop를 돕니다.
    
    if (obj[str[i]] === undefined) { 
// 그런데 obj란 객체에 character가 들어 있지 않다면 새로운 문자열이기 때문에 객체에 char를 추가하고 0으로 만들어 줍니다.
      obj[str[i]] = 0;
    }
    obj[str[i]]++;  // 그 이후 이 곳에서 char key의 value 값을 1 더해줍니다.
  }
  return obj;
}

let output = countAllCharacters(&#39;banana&#39;);
console.log(output); // --&amp;gt; {b: 1, a: 3, n: 2}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-37&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removestringvalues&#34;&gt;removeStringValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeStringValues&amp;rdquo;. (&amp;ldquo;removeStringValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeStringValues&amp;rdquo; removes any properties on the given object whose values are strings. (객체가 주어졌을때, &amp;ldquo;removeStringValues&amp;rdquo; 함수는 속성값이 문자열인 모든 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-35&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeStringValues(obj) {
  // 여기에 코드를 작성하세요.
  // 객체안에 있는 속성값이 문자열인지 판별한다.
  // 문자열이라면 삭제한다.
  for ( let prop in obj ) {
    if ( typeof obj[prop] === &amp;quot;string&amp;quot; ) {
      delete obj[prop]
    }
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-38&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removenumbervalues&#34;&gt;removeNumberValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeNumberValues&amp;rdquo;. (&amp;ldquo;removeNumberValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeNumberValues&amp;rdquo; removes any properties whose values are numbers. (객체가 주어졌을때, &amp;ldquo;removeNumberValues&amp;rdquo; 함수는 속성값이 숫자인 모든 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;my-soultion-36&#34;&gt;My_Soultion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let obj = {
  a: 2,
  b: &#39;remaining&#39;,
  c: 4
};


function removeNumberValues(obj) {
  // 여기에 코드를 작성하세요.
  // prop 을 불러온다.
  // 불러온 prop 값을 숫자인지 판별한다/
  // 숫자이면 제거한다
  for ( let prop in obj ) {
    if ( typeof obj[prop] === &amp;quot;number&amp;quot; ) {
      delete obj[prop]
    }
  } 
  return obj;
}

removeNumberValues(obj);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-39&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removearrayvalues&#34;&gt;removeArrayValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeArrayValues&amp;rdquo;. (&amp;ldquo;removeArrayValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeArrayValues&amp;rdquo; removes any properties whose values are arrays. (객체가 주어졌을때, &amp;ldquo;removeArrayValues&amp;rdquo; 함수는 속성값이 배열인 모든 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-37&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let obj = {
  a: [1, 3, 4],
  b: 2,
  c: [&#39;hi&#39;, &#39;there&#39;]
}
function removeArrayValues(obj) {
  // 여기에 코드를 작성하세요
  // prop 값을 불러온다
  // prop 값이 배열에 속하는지 판별한다
  // 배열에 속하면 제거한다.
  for ( let prop in obj ) {
    if (Array.isArray(obj[prop])) {
      delete obj[prop];
    }
  }
  return obj
}
removeArrayValues(obj)



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-40&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getfirstelement&#34;&gt;getFirstElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getFirstElement&amp;rdquo;. (&amp;ldquo;getFirstElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getFirstElement&amp;rdquo; returns the first element of the given array. (배열이 주어졌을때, &amp;ldquo;getFirstElement&amp;rdquo; 함수는 주어진 배열의 첫번째 요소를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-38&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getFirstElement(array) {
  // 여기에 코드를 작성하세요.
  // 배열을 0번째 숫자를 불러온다.
  if ( array.length === 0 ) {
    return undefined;
  } else
  return array[0];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-41&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlastelement&#34;&gt;getLastElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLastElement&amp;rdquo;. (&amp;ldquo;getLastElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getLastElement&amp;rdquo; returns the last element of the given array. (배열이 주어졌을때, &amp;ldquo;getLastElemeent&amp;rdquo; 함수는 주어진 배열의 마지막 요소를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-39&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getLastElement(array) {
  // 여기에 코드를 작성하세요
  // 만약 배열의 길이가 0 이라면 undefinded 출력
  // 아니라면 return 마지막 배열숫자 출력
  if ( array.length === 0 ) {
    return undefined;
  } else {
    let lastNum = array[array.length -1]
    return lastNum;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-42&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getnthelement&#34;&gt;getNthElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getNthElement&amp;rdquo;. (&amp;ldquo;getNthElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an integer, &amp;ldquo;getNthElement&amp;rdquo; returns the element at the given integer, within the given array. (배열과 숫자가 주어졌을때, &amp;ldquo;getNthElement&amp;rdquo; 함수는 주어진 배열에서 n번 인덱스의 요소를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-40&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getNthElement(array, n) {
  // 여기에 코드를 작성하세요
  // 만약 배열에 길이가 0보다 크면 코드 진행실행 아니면 undefinded
  // 배열에 n번째 있는 숫자를 변수에 저장
  // 배열안에 있는 n 번째의 숫자 출력
  if ( array.length &amp;gt; 0 ) {
    let ret = array[n];
    return ret;
  } else {
    return undefined;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-43&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addtofront&#34;&gt;addToFront&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;addToFront&amp;rdquo;. (&amp;ldquo;addToFront&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an element, &amp;ldquo;addToFront&amp;rdquo; adds the given element to the front of the given array, and returns the given array. (배열과 요소가 주어졌을때, &amp;ldquo;addToFront&amp;rdquo; 함수는 주어진 요소를 배열의 맨앞에 추가하고 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-41&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function addToFront(arr, element) {
  arr.unshift(element);
  return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-44&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addtoback&#34;&gt;addToBack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;addToBack&amp;rdquo;. (&amp;ldquo;addToBack&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an element, &amp;ldquo;addToBack&amp;rdquo; returns the given array with the given element added to the end. (배열과 요소가 주어졌을때, &amp;ldquo;addToBack&amp;rdquo; 함수는 주어진 요소를 배열의 맨뒤에 추가하고 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-42&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function addToBack(arr, element) {
  // 여기에 코드를 작성하세요.
  // push 사용해 element 값을 뒤에 추가한다.
  arr.push(element);
  return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-45&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;joinarrays&#34;&gt;joinArrays&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;joinArrays&amp;rdquo;. (&amp;ldquo;joinArrays&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two arrays, &amp;ldquo;joinArrays&amp;rdquo; returns an array with the elements of &amp;ldquo;arr1&amp;rdquo; in order, followed by the elementsin &amp;ldquo;arr2&amp;rdquo;. (두 배열이 주어졌을때, &amp;ldquo;joinArrays&amp;rdquo; 함수는 첫번째 배열(arr1)과 두번째 배열(arr2) 순서로 합쳐진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-43&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function joinArrays(arr1, arr2) {
  // your code here
  // 변수를 만들어 배열1에 배열2를 집어넣는다.
  // 출력한다.
  let arrRet = arr1.concat(arr2);
  return arrRet
  
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-46&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementsafter&#34;&gt;getElementsAfter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementsAfter&amp;rdquo;. (&amp;ldquo;getElementsAfter&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an index, &amp;ldquo;getElementsAfter&amp;rdquo; returns a new array with all the elements after (but not including) the given index. (배열과 인덱스가 주어졌을때, &amp;ldquo;getElementsAfter&amp;rdquo; 함수는 주어진 배열의 인덱스 이후 요소들을 (자신은 포함하지 않고) 새로운 배열로 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-44&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementsAfter(array, n) {
  // your code here
  // 새로운 빈배열을 만든다.
  // 초기값을 n+1을 한 for 문을 이용해 배열인덱스를 불러온다.
  // 불러온 값을 새로운 배열에 push를 사용해 담는다.
  // 출력한다.
  let newArr = [];
  for (let i = n + 1;  i &amp;lt; array.length; i = i + 1 ) {
    newArr.push(array[i]);
  }
  return newArr;
}
getElementsAfter([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], 1);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-47&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementsupto&#34;&gt;getElementsUpTo&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementsUpTo&amp;rdquo;. (&amp;ldquo;getElementsUpTo&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and a index, &amp;ldquo;getElementsUpTo&amp;rdquo;, returns an array with all the elements up until, but not including, the element at the given index. (배열과 인덱스가 주어졌을때, &amp;ldquo;getElementsUpTo&amp;rdquo; 함수는 주어진 배열의 인덱스 이전 요소들을 (자신은 포함하지 않고) 새로운 배열로 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-45&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementsUpTo(array, n) {
  let newArr = array.slice(0,n);
  return newArr
}
getElementsUpTo([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], 3);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-48&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallelementsbutfirst&#34;&gt;getAllElementsButFirst&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllElementsButFirst&amp;rdquo;. (&amp;ldquo;getAllElementsButFirst&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getAllElementsButFirst&amp;rdquo; returns an array with all the elements but the first. (배열이 주어졌을때, &amp;ldquo;getAllElementsButFirst&amp;rdquo; 함수는 첫번째 요소를 제외한 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-46&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getAllElementsButFirst(array) {
  // your code here
  // shift 를 이용해서 앞에 있는 요소를 뺀다.
  // 그리고 기존에 배열을 출력한다. 
  array.shift();
  return array;
}

getAllElementsButFirst([1,2,3,4])


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-solution&#34;&gt;model solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getAllElementsButFirst(array) {
  return array.slice(1, array.length);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-49&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallelementsbutlast&#34;&gt;getAllElementsButLast&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllElementsButLast&amp;rdquo;. (&amp;ldquo;getAllElementsButLast&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getAllElementsButLast&amp;rdquo; returns an array with all the elements but the last. (배열이 주어졌을때, &amp;ldquo;getAllElementsButLast&amp;rdquo; 함수는 마지막 요소를 제외한 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-47&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getAllElementsButLast(array) {
  // your code here
  // slice 를 이용해서 마지막 숫자를 삭제한다.
  // 출력한다.
  array.pop()
  return array
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-50&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removefromfront&#34;&gt;removeFromFront&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeFromFront&amp;rdquo;. (&amp;ldquo;removeFromFront&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;removeFromFront&amp;rdquo; returns the given array with its first element removed. (배열이 주어졌을때, &amp;ldquo;removeFromFront&amp;rdquo; 함수는 첫번째 요소를 삭제한 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-48&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeFromFront(arr) {
  // your code here
  // 메소드 사용해서 첫번째요소 자르기 
  arr.shift();
  return arr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-51&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removefromback&#34;&gt;removeFromBack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeFromBack&amp;rdquo;. (&amp;ldquo;removeFromBack&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;removeFromBack&amp;rdquo; returns the given array with its last element removed. (배열이 주어졌을때, &amp;ldquo;removeFromBack&amp;rdquo; 함수는 마지막 요소를 삭제한 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-49&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeFromBack(arr) {
  // your code here
  //배열 메소드 이용해서 뒤에 있는거 자르기
  arr.pop();
  return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-52&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removefrombackofnew&#34;&gt;removeFromBackOfNew&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeFromBackOfNew&amp;rdquo;. (&amp;ldquo;removeFromBackOfNew&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;removeFromBackOfNew&amp;rdquo; returns a new array containing all but the last element of the given array. (배열이 주어졌을때, &amp;ldquo;removeFromBackOfNew&amp;rdquo; 함수는 마지막 요소를 제외한 모든 요소를 가지고 있는 새로운 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-50&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeFromBackOfNew(arr) {
  // your code here
  // 빈 배열을 만든다. 
  // 배열을 가져오는데 length를 이용해 마지막숫자를 뺀수를 가져온다
  // 가져온 숫자를 새로운 배열에 넣는다. 
  // arrNew 를 출력한다. 
  let arrNew = [];
  for (let i = 0; i &amp;lt; arr.length -1; i = i + 1 ) {
    arrNew.push(arr[i]);
  }
  return arrNew
  }


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-solution-1&#34;&gt;model solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function removeFromBackOfNew(arr) {
  // your code here
  // 마지막 숫자를 뺀 배열값을 변수에 담는다.
  // 담은 변수를 출력한다.
  let sliced = arr.slice(0,arr.length-1)
  return sliced; 
  
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-53&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addtobackofnew&#34;&gt;addToBackOfNew&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;addToBackNew&amp;rdquo;. (&amp;ldquo;addToBackNew&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an element, &amp;ldquo;addToBackNew&amp;rdquo; returns a clone of the given array, with the given element added to the end. (배열과 요소가 주어졌을때, &amp;ldquo;addToBackNew&amp;rdquo; 함수는 주어진 배열의 복사본 끝에 주어진 요소가 추가된 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-51&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function addToBackOfNew(arr, element) {
  // your code here
  arr = arr.concat(element);
  return arr;
  }
  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-soultion&#34;&gt;model soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function addToBackOfNew(arr, element) {
  const newArr = arr.slice();
  newArr.push(element);
  return newArr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-54&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;joinarrayofarrays&#34;&gt;joinArrayOfArrays&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;joinArrayOfArrays&amp;rdquo;. (&amp;ldquo;joinArrayOfArrays&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of arrays, &amp;ldquo;joinArrayOfArrays&amp;rdquo; returns a single array containing the elements of the nested arrays. (배열들의 배열이 주어졌을때, &amp;ldquo;joinArrayOfArrays&amp;rdquo; 함수는 배열들의 요소를 모두 담고 있는 단일 배열을 반환합니다.)&lt;/p&gt;

&lt;p&gt;it is used by reduce and concat&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-52&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function joinArrayOfArrays(arr) {

  output = arr.reduce(function(acc,cur) {
    return acc.concat(cur); 
    })
    return output;
  }


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-55&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallletters&#34;&gt;getAllLetters&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllLetters&amp;rdquo;. (&amp;ldquo;getAllLetters&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;getAllLetters&amp;rdquo; returns an array containing every character in the word. (단어가 주어졌을때, &amp;ldquo;getAllLetters&amp;rdquo; 함수는 주어진 단어에 포함된 모든 문자를 담고 있는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-53&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getAllLetters(str) {
  // your code here
  // 만약 빈문자 열이라면 빈 배열을 리턴한다.
  // 만약 빈배열이 아니라면 문자를 split method 사용한다.
  if ( str === &amp;quot;&amp;quot; ) {
    return str = [];
  } else {
    return str.split(&amp;quot;&amp;quot;)
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-56&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallwords&#34;&gt;getAllWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllWords&amp;rdquo;. (&amp;ldquo;getAllWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a sentence, &amp;ldquo;getAllWords&amp;rdquo; returns an array containing every word in the sentence. (문장이 주어졌을때, &amp;ldquo;getAllWords&amp;rdquo; 함수는 주어진 문장에 포함된 모든 단어를 담고 있는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-54&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
 
 function getAllWords(str) {
  if (str === &#39;&#39;) {
    return [];
  } else {
    return str.split(&#39; &#39;);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-57&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeelement&#34;&gt;removeElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeElement&amp;rdquo;. (&amp;ldquo;removeElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of elements, and a &amp;ldquo;discarder&amp;rdquo; parameter, &amp;ldquo;removeElement&amp;rdquo; returns an array containing the items in the given array that do not match the &amp;ldquo;discarder&amp;rdquo; parameter. (배열과 &amp;ldquo;discarder&amp;rdquo; 매개변수가 주어졌을때, &amp;ldquo;removeElement&amp;rdquo; 함수는 주어진 배열에서 &amp;ldquo;discarder&amp;rdquo; 매개변수와 일치하지 않는 모든 요소를 포함하는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-55&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

unction removeElement(array, discarder) {
  // your code here
   /* 
  1. 빈배열이면 빈배열을 반환
  2. 새로운 빈배열을 만든다. newArr
  3. 모든 element를 조사한다.
  4. element가 discarder와 다르다면 newArr에 push로 넣는다.
  5. 위에경우가 아니라면 newArr을 반환
   */

  if ( array === [] ) {
    return [];
  }
  let newArr = [];
  for (let i = 0; i &amp;lt; array.length; i = i + 1 ) {
    if ( discarder !== array[i] ) {
      newArr.push(array[i])
    } 
  }
  return newArr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-58&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;keep&#34;&gt;keep&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;keep&amp;rdquo;. (&amp;ldquo;keep&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and a keeper element, &amp;ldquo;keep&amp;rdquo; returns an array containing the items that match the given keeper element. (배열과 &amp;ldquo;keeper&amp;rdquo; 매개변수가 주어졌을때, &amp;ldquo;keep&amp;rdquo; 함수는 &amp;ldquo;keeper&amp;rdquo; 매개변수와 일치하는 모든 요소&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-56&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function keep(array, keeper) {
  // your code here
  // 만약 배열이 비워있다면 빈배열 리턴
  // 새로운 빈배열을 만든다.
  // for 문을 사용해 배열을 조사
  // 만약 keeper라는 매개변수가 있는지 조사
  // 만약 있다면 push를 사용해 새로운 배열에 투입
  // 새로운 배열 출력
  if ( array === []) {
    return [];
  }
  let newArr = [];
  for ( let i = 0; i &amp;lt; array.length; i = i + 1 ) {
    if ( array[i] === keeper ) {
      newArr.push(array[i]);
    }
  }
  return newArr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-59&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;findsmallestelement&#34;&gt;findSmallestElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;findSmallestElement&amp;rdquo;. (&amp;ldquo;findSmallestElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;findSmallestElement&amp;rdquo; returns the smallest number within the given array. (숫자의 배열이 주어졌을때, &amp;ldquo;findSmallestElement&amp;rdquo; 함수는 주어진 배열에서 가장 작은 수를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution&#34;&gt;My_solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// It is used by sort();



function findSmallestElement(arr) {

  만약 arr 비워있다면 빈배열 리턴
  메소드 slice()이용해 복사 
  복사한 배열을 sort()를 이용해 작은숫자가 앞으로 올수 있도록 정렬
  0번째 있는 요소 출력


  if ( arr.length === 0 ){ 
    return 0;
  }
  let newArr = arr.slice();
  let sortArr = function(a,b) {
    return a-b;
  }
  newArr.sort(sortArr); 
  return newArr[0];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by reudce and if 

function findSmallestElement(arr) {
  if (arr.length &amp;lt; 1) {  // satisfies Notes requirement
    return 0;
  }
  var newNum = arr[0];  // create number placeholder (start with first number of array)
  for (let i in arr) {  // iterate thru array
    if (arr[i] &amp;lt; newNum) {  // if element is larger than current placeholder number
      newNum = arr[i];  // make that element the new placeholder number
    }
  }
  return newNum;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by reudce and if ????? 


function findSmallestElement(arr) {
  
  if(arr.length === 0) {
    return 0;
  } else {
    var smallestNum = arr.reduce(function(a,b) {
      return a &amp;lt; b ? a: b;
    });
    return smallestNum;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// it is used by reudce and Math method

function findSmallestElement(arr) {

  if ( arr.length === 0 ) {
    return 0;
  }

  output = arr.reduce(function(acc,cur){
    return Math.min(acc,cur);

  })  
  return output;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// it is used by reudce and Math method

function findSmallestElement(arr) {

  if ( arr.length === 0 ) {
    return 0;
  }

  return Math.min(...arr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-60&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computesumofallelements&#34;&gt;computeSumOfAllElements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeSumOfAllElements&amp;rdquo;. (&amp;ldquo;computeSumOfAllElements&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;computeSumOfAllElements&amp;rdquo; returns the sum of all the elements in the given array. (숫자의 배열이 주어졌을때, &amp;ldquo;computeSumOfAllElements&amp;rdquo; 함수는 주어진 배열의 모든 요소의 합을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-1&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function computeSumOfAllElements(arr) {
  
  // your code here.
  // 빈 배열을 만든다.
  // count 변수 초기화 한해서 만든다.
  // arr 안에 값들을 조사한다.
  // count 변수안에 조사한 값들을 더해서 넣는다.
  let sum = 0;
  for ( let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
    sum = sum + arr[i];
  }
  return sum
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// it used by reduce 


function computeSumOfAllElements(arr) {
  if ( arr.length === 0 ) {
    return 0;
  }
  return arr.reduce(function(acc,val){
    return acc + val;
  })
  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-61&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeproductofallelements&#34;&gt;computeProductOfAllElements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeProductOfAllElements&amp;rdquo;. (&amp;ldquo;computeProductOfAllElements&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;computeProductOfAllElements&amp;rdquo; returns the products of all the elements in the given array. (숫자의 배열이 주어졌을때, &amp;ldquo;computeProductOfAllElements&amp;rdquo; 함수는 주어진 배열의 모든 요소의 곱을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-2&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;



function computeProductOfAllElements(arr) {
  
  // 먄약 배열이 비워있다면 0 리턴;
  // 0으로 된 마지막에 출력할 변수 생성;
  // for 문을 사용해 배열안에 있는 요소 조사
  // 생성한 변수 안에 조사한 요소들을 곱셈하여 넣는다.
  // 변수 출려
  
  if ( arr.length === 0 ) {
    return 0;
  }
  let ret = 1;
  for ( let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
    ret = ret * arr[i];
  } 
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// It is used by redcue method
function computeProductOfAllElements(arr) {
    
    
    if ( arr.length === 0 ) {
    return 0;
  }
  return arr.reduce(function(acc,cur) {
    return acc * cur;
  })

}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-62&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlengthoflongestelement&#34;&gt;getLengthOfLongestElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLengthOfLongestElement&amp;rdquo;. (&amp;ldquo;getLengthOfLongestElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getLengthOfLongestElement&amp;rdquo; returns the length of the longest string in the given array. (배열이 주어졌을때, &amp;ldquo;getLengthOfLongestElement&amp;rdquo; 함수는 주어진 배열에서 가장 긴 문자열의 길이를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-3&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// it is used by sort()


function getLengthOfLongestElement(arr) {

  if ( arr.length === 0 ){
    return 0;
  } 
  sortArr = function (a, b) { 
    return b.length - a.length;
    }
    let ret = arr.sort(sortArr)[0]
    return ret.length;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by for loop and if


function getLengthOfLongestElement(arr) {
  
  if ( arr.length === 0 ) {
    return 0;
  } 

  let lgth = 0; // =&amp;gt; 3  =&amp;gt;5
  let longest;  // =&amp;gt;&amp;quot;one&amp;quot; =&amp;gt; &amp;quot;three&amp;quot; 
  
  for ( let i = 0; i &amp;lt; arr.length; i = i + 1) {
    if(arr[i].length &amp;gt; lgth) {
      // 첫번째 요소는 &amp;quot;one&amp;quot; 길이는 3 &amp;gt; 0
      // 두번째 요소는 &amp;quot;two&amp;quot; 길이는 3 &amp;gt; 3 : 실행이 안됨
      // 세번째 요소는 &amp;quot;three&amp;quot; 길이는 5 &amp;gt; 3 : 실행되면서 최종적으로 longest변수에 &amp;quot;three&amp;quot;가 담긴다. 
        lgth = arr[i].length;
        longest = arr[i].length;
    }      
  } 
  return longest;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


/*


it is used by reduce method

comment

return a.length or return b.length 하면 안되는 이유. length를 리턴에 넣으면 다음  a 와 b.length의 길이를 비교하기 때문에 안되는거더라구요. 그래서 함수 밖에 붙여주면 숫자로 반환되는 거구요.




*/

function getLengthOfLongestElement(arr) {

 
 return arr.reduce(function(a,b) {
      if (a.length &amp;gt;= b.length) {
        return a;
      } else {
        return b;
      }
  }).length
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-63&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;filteroddlengthwords&#34;&gt;filterOddLengthWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;filterOddLengthWords&amp;rdquo;. (&amp;ldquo;filterOddLengthWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of string, &amp;ldquo;filterOddLengthWords&amp;rdquo; returns an array containing only the elements of the given array whose lengths are odd numbers. (문자열의 배열이 주어졌을때, &amp;ldquo;filterOddLengthWords&amp;rdquo; 함수는 주어진 배열의 요소 중 문자열의 길이가 홀수인 문자열만을 요소로 가지는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-57&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


unction filterOddLengthWords(words) {

  // it passed test
  // it&#39;s good to practice useing filter 

  // your code here
  // output 빈 배열을 만든다.
  // for 문을 이용해 배열안에 있는 요소를 조사한다.
  // 만약 배열안에 있는 각각의 요소가 홀수라면 ture
  // ture 인 값을 output 배열에 넣는다.
  // 넣은 값을 출력한다.
  
  let output = [];
  for  ( let i = 0; i &amp;lt; words.length; i = i + 1 ) {
    if ( words[i].length % 2 !== 0 ) { 
      output.push(words[i]);
    }
  }
  return output;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;modle-soultion&#34;&gt;modle_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


// input: an array of strings
// output: return an array containing only the elements of the given array whose lengths are odd numbers

function filterOddLengthWords(arr) {  // HoF
  return arr.filter(function(i) {  // filters each even length elements to its own array
    return i.length % 2 !== 0;
  });
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-64&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementofarrayproperty&#34;&gt;getElementOfArrayProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementOfArrayProperty&amp;rdquo;. (&amp;ldquo;getElementOfArrayProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, a key, and a numerical index, &amp;ldquo;getElementOfArrayProperty&amp;rdquo; returns the value of the element at the given index of the array located within the given object at the given key. (객체와 키, 그리고 숫자로된 인덱스값이 주어졌을때, &amp;ldquo;getElementOfArrayProperty&amp;rdquo; 함수는 주어진 키에 위치한 배열의 인덱스에 해당하는 값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-58&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementOfArrayProperty(obj, key, index) {
  // your code here
 
   if (!Array.isArray(obj[key])){
    return undefined;
  } 
  return obj[key][index]; 
} 
let obj = {
  key: [&#39;Jamil&#39;, &#39;Albrey&#39;]
};

getElementOfArrayProperty(obj,&#39;key&#39;,0);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-65&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;select&amp;rdquo;. (&amp;ldquo;select&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an object, &amp;ldquo;select&amp;rdquo; returns a new object whose properties are those in the given object AND whose keys are present in the given array. (배열과 객체가 주어졌을때, &amp;ldquo;select&amp;rdquo; 함수는 주어진 객체의 키값 중 주어진 배열에 포함된 키값만을 속성으로 가지는 새로운 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-59&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function select(arr, obj) {
  // your code here
  let newObj = {};
  for (let key in obj ) {
    for (let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
      if (key === arr[i] ) {
       newObj[key] = obj[key]
      }

    }

  } 
  return newObj;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-66&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getnthelementofproperty&#34;&gt;getNthElementOfProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getNthElementOfProperty&amp;rdquo;. (&amp;ldquo;getNthElementOfProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getNthElementOfProperty&amp;rdquo; returns the nth element of an array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getNthElementOfProperty&amp;rdquo; 함수는 주어진 키에 위차한 배열의 n번째 요소를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-60&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getNthElementOfProperty(obj, key, n) {
  // your code here
  // 만약 주어진 키에 위차하는 속성값이 배열이 아니라면 undefinded 
  // 만약 그게 아니라면 주어진 키값의 인덱스 번호 리턴
  if ( !Array.isArray(obj[key])) {
    return undefined;
  } else {
    return obj[key][n];
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-67&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementslessthan100atproperty&#34;&gt;getElementsLessThan100AtProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo;. (&amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo; returns an array containing all the elements of the array located at the given key that are less than 100. (객체와 키값이 주어졌을때, &amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo; 함수는 주어진 키에 위치하는 배열에서 100 보다 작은 값으로만 이루어진 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-61&#34;&gt;MY_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementsLessThan100AtProperty(obj, key) {
  for (let prop in obj) {
    if (! Array.isArray(obj[key])){
    return [];
    } else if ( !prop in obj ) {
      return [];
    }
  }
    let retArr = [];
    for ( let prop2 in obj ) {
    for ( let i = 0; i &amp;lt; obj[prop2].length; i = i + 1) {
      if ( obj[prop2][i] &amp;lt; 100 ) {

        retArr.push(obj[prop2][i]);
      }

  }
    }
    return retArr;
  }



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-re-soultion&#34;&gt;My_Re_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getElementsLessThan100AtProperty(obj, key) {

  if ( ! Array.isArray(obj[key])) {
    return [];
  } else {
  return obj[key].filter(cur =&amp;gt; cur &amp;lt; 100);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-68&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlastelementofproperty&#34;&gt;getLastElementOfProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLastElementOfProperty&amp;rdquo;. (&amp;ldquo;getLastElementOfProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getLastElementOfProperty&amp;rdquo; returns the last element of an array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getLastElementOfProperty&amp;rdquo; 함수는 주어진 키에 위치한 배열의 마지막 요소를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-4&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getLastElementOfProperty(obj, key) {
  
  // 1. 만약 key의 값에 prop 배열이 아니라면 undefined 출력
  // 2. 배열에 있는 마지막 요소 pop 메소드 이용해서 빼서 변수안에 넣기
  // 3. 변수 리턴 

  if (!Array.isArray(obj[key])) {
    return undefined;
    } else {
      let lastNum = obj[key].pop()
      return lastNum
  } 
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;modle-solution&#34;&gt;modle_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1.마지막 배열에 요소 가져오기 위해 length - 1 이라는 방법을 썻다.

function getLastElementOfProperty(obj, key) {
  let prop = obj[key];
  if (!Array.isArray(prop)) {
    return undefined
  }

  return prop[prop.length - 1]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-69&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getsquaredelementsatproperty&#34;&gt;getSquaredElementsAtProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getSquaredElementsAtProperty&amp;rdquo;. (&amp;ldquo;getSquaredElementsAtProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getSquaredElementsAtProperty&amp;rdquo; returns an array containing all the squared elements of the array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getSquaredElementsAtProperty&amp;rdquo; 함수는 주어진 키에 위치하는 배열의 요소들의 제곱을 요소로 가지는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-62&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getSquaredElementsAtProperty(obj, key) {


  
  // 1. 만약 주어진 key 의 값이 배열이 아니라면 빈배열 출력
  // 2. 만약 주어진 key 의 값이 길이가 0 같이 않다면 빈배열
  // 3. 마지막에 출력할 새로운 변수 생성
  // 4. 곱셈할 값을 넣기 위한 새로운 변수 또 생성 
  // 5. 배열안에 있는 요소들 곱하기
  // 6. 곱한값을 arr 이라는배열에 넣는다.    


 if (!Array.isArray(obj[key])) {
    return [];
 } else if (obj[key].length === 0 ){
   return [];
 }
  let arr = [];
  let conut;
  for ( let i = 0; i &amp;lt; obj[key].length; i = i + 1 ) {
    conut = obj[key][i]*obj[key][i];
    arr.push(conut);
  }
 return arr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion&#34;&gt;other Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function getSquaredElementsAtProperty(obj, key) {
  var arr = [];
  if(Array.isArray(obj[key])){
    for(var i in obj[key]){
      var squared =obj[key][i]*obj[key][i];
      arr.push(squared);
    }
  }
  return arr;
}

var obj = {
  key: [2, 1, 5]
};
var output = getSquaredElementsAtProperty(obj, &#39;key&#39;);
console.log(output);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-70&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallbutlastelementofproperty&#34;&gt;getAllButLastElementOfProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllButLastElementOfProperty&amp;rdquo;. (&amp;ldquo;getAllButLastElementOfProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getAllButLastElementOfProperty&amp;rdquo; returns an array containing all but the last element of the array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getAllButLastElementOfProperty&amp;rdquo; 함수는 주어진 키에 위치하는 배열의 마지막 요소를 제외한 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-5&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getAllButLastElementOfProperty(obj, key) {
  
  
  // 1.마지막에 출력할 arr 빈배열 생성
  // 2.만약 key의 값의 prop 가 배열이 아니라면 빈배열 리턴
  // 3.만약 key의 값의 prop 의 길이가 0 과 같이 않다면 빈배열 리턴
  // 4.선언된 arr 안에 obj[key] 값을 넣는다.
  // 5.pop()메소드 사용해 마지막 요소 제거
  // 6.arr 리턴


  let arr = [];
  if (!Array.isArray(obj[key])) {
    return [];
  } else if ( obj[key].length === 0 ) {
    return [];
  } else {
    arr = obj[key];
    arr.pop()
  }
  return arr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-71&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getproductofallelementsatproperty&#34;&gt;getProductOfAllElementsAtProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo;. (&amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo; returns the product of all the elements in the array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo; 함수는 주어진 키에 위치한 배열의 요소의 곱을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-63&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by for 


function getProductOfAllElementsAtProperty(obj, key) {

  // 1. arr 변수 만들어 key값의 prop 값을 넣는다
  // 2. 곱한값을 담을 sum 이라는 변수 생성 
  // 3. 만약 key의 prop 배열이 아니라면 0을 리턴
  // 4. 만약 key의 prop 길이가 0 과 같다면  0;
  // 5. for 문사용해 arr안에 있는 숫자를 곱한값을 sum 안에 저장
  // 6. sum 출력 
  
  
  let arr = obj[key];
  let sum = 1;
  if ( !Array.isArray(obj[key])) {
    return 0;
  } else if ( obj[key].length === 0 ) {
    return 0;
  }
  for ( let n = 0 ; n &amp;lt; arr.length ; n = n + 1 ) {
    sum = sum * arr[n];
  }
  return sum;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by reduce

function getProductOfAllElementsAtProperty(obj, key) {
  if (! Array.isArray(obj[key] )) {
    return 0; 
  } else if ( obj[key].length === 0 ){
    return 0;
  }
  let arr = obj[key];
  return arr.reduce(function(acc,cur) {
    return acc * cur;
  }) 
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__Algorithm_2</title>
      <link>/tutorial/2019-11-14-javascript-daliy-coding-level-2/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2019-11-14-javascript-daliy-coding-level-2/</guid>
      <description>

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;gcd-최대-공약-알고리즘-함수-작성&#34;&gt;gcd(최대 공약 알고리즘) 함수 작성&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;주어진 두 숫자에 대한 최대공약수(greatest common divisor)를 구하세요&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;outPut&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
gcd(22, 24) // 2

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function gcd(num1, num2) {
  // code goes here   

  //num1 = 12,num 2 = 8
  let num1Arr = [];
  let num2Arr = [];
  for (let i =0; i &amp;lt;= num1; i ++) {
    num1Arr.push(i);
  }
  for (let i =0; i &amp;lt;= num1; i ++) {
    num2Arr.push(i);
  }
  
  let filteredArr1 = num1Arr.filter((ele)=&amp;gt;{
    return num1 % ele === 0;
  })
  let filteredArr2 = num2Arr.filter((ele)=&amp;gt;{
    return num2 % ele === 0;
  })

  let totalArr = filteredArr1.filter(function(val) {
  return filteredArr2.indexOf(val) !== -1;
});

  return Math.max(...totalArr);

}





&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1&#34;&gt;Other_Soultion 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getGCD(value1, value2) {
  if (typeof value1 !== &amp;quot;number&amp;quot; || typeof value2 !== &amp;quot;number&amp;quot;) {
    return;
  }
  // value1과 value2 중 큰 값을 기준으로 값을 선택
  let num = value1 &amp;gt; value2 ? value1 : value2;
  let max;

  for (let i = 1; i &amp;lt;= num; i++) {
    if (value1 % i === 0 &amp;amp;&amp;amp; value2 % i === 0) {
      max = i;
    }
  }

  return max;
}
console.log(getGCD(280, 30)); // 10
console.log(getGCD(12, 4)); // 4


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-2-1&#34;&gt;Other_Soultion 2-1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function gcd(num1, num2) {
  if(num2 === 0) { 
    return num1;
  }
    let c = num1 % num2 // 0나머지값이 나올때까지 계속 num1 % num2 실행
    // 자리를 바꾼다.
    num1 = num2 // num1 은 num2 가 되고 
    num2 = c //  num2 는 c 가 된다.  
    return gcd(num1, num2) // 계속 실행시킨다. 
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-2-2&#34;&gt;Other_Soultion 2-2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function gcd(num1, num2) {
  return num2 ? gcd(num2, num1 % num2) : num1;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;약수-공약-알고리즘&#34;&gt;약수 공약 알고리즘&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;export function getDivisor(value) {
  if (typeof value !== &amp;quot;number&amp;quot;) {
    return;
  }
  let result = [];

  for (let i = 1; i &amp;lt;= value; i++) {
    if (value % i === 0) {
      result.push(i);
    }
  }

  return result.toString();
}

console.log(getDivisor(30)); // 1,2,3,5,6,10,15,30
console.log(getDivisor(12)); // 1,2,3,4,6,12


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-1&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;findmissingnumber&#34;&gt;findMissingNumber&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;성준이는 1부터 n까지 숫자를 적던 중 깜빡하고 하나의 숫자를 빼먹었다. 그 빼먹은 숫자를 찾으시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;outPut&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
findMissingNumber(&#39;1 6 2 4 3&#39;) // =&amp;gt; 5


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-1&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMissingNumber(str) {

  // code goes here
  let strArr = str.split(&amp;quot; &amp;quot;).map(Number);
  let x = function(a,b){
	return a-b;
  }
  let orderArr = strArr.sort(x); 
  let arr = orderArr.filter(function(ele,index){
		return ele -1 !== index;
	})
	return arr[0]-1
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quesiton&#34;&gt;Quesiton&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;+, -, 그리고 괄호를 가지고 길이가 최대 50인 식을 만들었다. 그리고 나서 성준 이는 괄호를 모두 지웠다. 그리고 나서 괄호를 적절히 쳐서 이 식의 값을 최소로 만드려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;output&#34;&gt;output&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;findMinByBracket(&#39;55-50+40&#39;) // -35



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-2&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function findMinByBracket(str) {
  let arr = str.split(&amp;quot;-&amp;quot;)
  let sumPlus = 0;
  let sum = 0;
  for (let i = 0; i &amp;lt; arr.length; i ++ ) {
    if (arr[i].split(&amp;quot;+&amp;quot;).length &amp;gt; 1 )	 { // [55-50+40]
    sumPlus = arr[i].split(&amp;quot;+&amp;quot;).map(Number).reduce(function(a,c){
	    return  a + c
      });
      arr.splice(i,1,sumPlus.toString());
      }
      // 현재  arr = [&amp;quot;50&amp;quot;,&amp;quot;90&amp;quot;];	
      sum = arr.map(Number).reduce(function(a,c){
        return  a - c;
      });
  }
      return sum;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quesiton-1&#34;&gt;Quesiton&lt;/h3&gt;

&lt;h2 id=&#34;findmaxonmultiplesofthirty&#34;&gt;findMaxOnMultiplesOfThirty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;어느날, 성준이는 우연히 길거리에서 양수 N을 보았다. 성준이는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다. 성준이를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라. (그 수가 존재한다면)&lt;/p&gt;

&lt;p&gt;출력 : 성준이가 만들고 싶어하는 수가 존재한다면 그 수를 출력하라. 그 수가 존재하지 않는다면, -1을 출력하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;outPut&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

findMaxOnMultiplesOfThirty(4095)  // 9540
findMaxOnMultiplesOfThirty(1023)  // 3210
findMaxOnMultiplesOfThirty(4800)  // 8400
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-3&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMaxOnMultiplesOfThirty(num) {
  // your code here
  let num2 = num.toString().split(&amp;quot;&amp;quot;).map(Number);
  let num3 = num2.sort().reverse().join(&amp;quot;&amp;quot;);

  let num4 = Number(num3);
  if (num4 % 30 === 0 ){
    return num4; 
  } else {
    return -1;
  }

}





&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-2&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;threefivemultiples&#34;&gt;threeFiveMultiples&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;숫자가 주어졌을때, threeFiveMultiples(num) 함수는 해당 숫자보다 작은 3 혹은 5의 배수들의 총합을 반환합니다.&lt;/p&gt;

&lt;p&gt;예시: 만약 10이 주어졌다면, 10 보다 작은 3과 5의 배수들은 3, 5, 6, 9 가 있으며 해당 숫자들을 모두 더하면 23 이 나오므로 여러분이 작성하진 함수는 23 을 반환해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-4&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function threeFiveMultiples(num) {
  // 여기에 코드를 작성하세요 
  let result = 0;
  for(let i = 0; i &amp;lt; num; i++ ) { 
    if(i % 3 === 0 || i % 5 === 0){
       result = result + i;
    } 
  }
  return result;

}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quesiton-2&#34;&gt;Quesiton&lt;/h3&gt;

&lt;h2 id=&#34;runlength&#34;&gt;runLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;3시간 반 소요&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;문자열이 주어졌을때, runLength(str) 함수는 Run-length 인코딩 알고리즘을 사용하여 주어진 문자열을 압축하여 반환합니다.&lt;/p&gt;

&lt;p&gt;해당 알고리즘은 반복되는 글자가 있을경우 반복되는 수와 해당 글자를 조합하여 문자열을 압축시킵니다.&lt;/p&gt;

&lt;p&gt;예시: wwwggopp 는 3w2g1o2p 로 압축됩니다. 주어지는 문자열은 숫자나, 구두점이나, 문자를 포함하고 있지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-5&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function runLength(str) {
   

   // 같은 char 끼리 묶기 위해 우선 각배열안에 담아서 newArr안에 넣느다 .
   // newArr = (4) [Array(3), Array(5), Array(6), Array(8)]
   
   // (3) [&amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;]
   // (5) [&amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;]
   // (6) [&amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;o&amp;quot;]
   // (8) [&amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;p&amp;quot;]
   
    var strArr = str.split(&amp;quot;&amp;quot;);
    var newArr = [];
    var index = 0;
    for (let i = 0; i &amp;lt; strArr.length ; i ++  ) {
        let copeArr = strArr.slice(); 
        if(strArr[i] !== strArr[i + 1]) {
            // i = 2 , 4, 5, 7
            copeArr.splice(i+1,0,&amp;quot;-&amp;quot;); // [&amp;quot;w&amp;quot;, &amp;quot;w&amp;quot;,&amp;quot;w&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;p&amp;quot;]
            newArr.push(copeArr.slice(index,i+1));
        }
    }

    // retArr 안에  같은 char 끼리 모아 놓는다.
    // retArr = (4) [&amp;quot;www&amp;quot;, &amp;quot;gg&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;pp&amp;quot;]
    var retArr = [];
    var filtered = [];
    retArr.push(newArr[0].join(&amp;quot;&amp;quot;))
    for (let i = 0; i &amp;lt; newArr.length- 1; i ++ ) {
        retArr.push(newArr[i+1].slice(newArr[i].length).join(&amp;quot;&amp;quot;))
	
    }
    
    // map 을 이용하여 outPut 변수안에 숫자와 char각각요소를 합쳐 배열로 만든다.
    // outPut[&amp;quot;3w&amp;quot;, &amp;quot;2g&amp;quot;, &amp;quot;1o&amp;quot;, &amp;quot;2p&amp;quot;]
    
    let outPut = retArr.map(function(val) {
	return  val.length + val[0];
	})

    // 문자열로 만들고 리턴한다. 
    return outPut.join(&amp;quot;&amp;quot;);

}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-3&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;numbersearch&#34;&gt;numberSearch&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;문자열이 주어졌을때, numberSearch(str) 함수는 주어진 문자열에서 숫자를 모두 찾아 더한 뒤 해당 값을 (숫자, 공백 등을 제외한) 알파벳의 길이의 길이로 나눈 값을 정수로 반올림하여 반환합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
예시: 만약 문자열 Hello6 9World 2, Nic8e D7ay! 이 주어졌다면, 결과값은 2 입니다.

우선 모든 숫자를 더하면 6 + 9 + 2 + 8 + 7 = 32 가 나오게됩니다.

그 후 (숫자, 공백 등을 제외한) 알파벳의 길이가 17이기 때문에 32/17 = 1.882 가 나오게 되며, 가까운 정수로 반올림을 하게되면 정답인 2가 나오게 됩니다.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultoin&#34;&gt;My_Soultoin&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function numberSearch(str) {
  // your code here

  let strLength = str.replace(/[^a-z]/gi, &#39;&#39;).length;
  let sum = str.match(/\d/g).map(Number).reduce(function(a,c){
	return a + c;
})

  return Math.round(sum / strLength);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-4&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;findmaxonmultiplesofthirty-1&#34;&gt;findMaxOnMultiplesOfThirty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;어느날, 성준이는 우연히 길거리에서 양수 N을 보았다. 성준이는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다. 성준이를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라. (그 수가 존재한다면)&lt;/p&gt;

&lt;p&gt;출력 : 성준이가 만들고 싶어하는 수가 존재한다면 그 수를 출력하라. 그 수가 존재하지 않는다면, -1을 출력하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

findMaxOnMultiplesOfThirty(4095)  // 9540
findMaxOnMultiplesOfThirty(1023)  // 3210
findMaxOnMultiplesOfThirty(4800)  // 8400

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-6&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function findMaxOnMultiplesOfThirty(num) {
  
  // your code here
  
  // 4095 --&amp;gt; 9540
  // 1023 --&amp;gt; 3210
  // 4800 --&amp;gt; 8400


  str = String(num); // num 를 문자열로 바꾼다.

  let sum = str.split(&#39;&#39;).map(Number).reduce(function(acc,curr){ // 
    return acc + curr;
  });
    
  if ( sum % 3 === 0 &amp;amp;&amp;amp; str.includes(&#39;0&#39;)) {
    return Number(str.split(&#39;&#39;).map(Number).sort(function(a,b){
      return b - a;
    }).join(&#39;&#39;));
  } else {
    return -1;
  }
  }




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quesiton-3&#34;&gt;Quesiton&lt;/h3&gt;

&lt;h2 id=&#34;threefivemultiples-1&#34;&gt;threeFiveMultiples&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;숫자가 주어졌을때, threeFiveMultiples(num) 함수는 해당 숫자보다 작은 3 혹은 5의 배수들의 총합을 반환합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
예시: 만약 10이 주어졌다면, 10 보다 작은 3과 5의 배수들은 3, 5, 6, 9 가 있으며 

해당 숫자들을 모두 더하면 23 이 나오므로 여러분이 작성하진 함수는 23 을 반환해야 합니다.



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-7&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function threeFiveMultiples(num) {

  // 여기에 코드를 작성하세요

  let sum3 = 0; // 3의 배수들이 담긴다.
  let sum5 = 0; // 5의 배수들이 담긴다. 

  for ( let i = 1; i &amp;lt; num; i = i + 1 ) { // 10(Num) 보다 작을때까지 돌린다. 
    if (i % 3 === 0 ) {   // i 값이 3 6 9 가 되면 통과
      sum3 = sum3 + i;  //  3 + 6 + 9 = 18 
    } else if ( i % 5 === 0) { // i 값이 5 가 되면 통과
      sum5 = sum5 + i;  // 0 + 5 = 5
    }
  }
  return sum3 + sum5; // 18 + 5 = 23

}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-5&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;runlength-1&#34;&gt;runLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;문자열이 주어졌을때, runLength(str) 함수는 Run-length 인코딩 알고리즘을 사용하여 주어진 문자열을 압축하여 반환합니다.&lt;/p&gt;

&lt;p&gt;해당 알고리즘은 반복되는 글자가 있을경우 반복되는 수와 해당 글자를 조합하여 문자열을 압축시킵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;예시: wwwggopp 는 3w2g1o2p 로 압축됩니다. 
주어지는 문자열은 숫자나, 구두점이나, 문자를 포함하고 있지 않습니다.


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-8&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function runLength(str) {
  // Your code here

 let result = new Array(); // &amp;lt;&amp;lt; new Array() 와 [] 차이점 
 let count = 1; // 숫자를 계산하기위해 1로 초기값설정
 for ( let i = 0; i &amp;lt; str.length; i = i + 1 ) {
   if ( str[i] === str[i + 1]) {
     count = count + 1;
   } else {
     result.push(count);
     result.push(str[i]);
     count = 1;
   }
 }
 return result.join(&#39;&#39;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;thirdgreatest&#34;&gt;thirdGreatest&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;문자열로 이루어진 배열이 주어졌을때, thirdGreatest(strArr) 함수는 주어진 배열에서 세번째로 긴 단어를 반환합니다. 그 중, 동률일때는 뒤에 있는 단어를 반환해줘야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
예를 들어, 주어진 배열이 [&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;all&amp;quot;] 라면, 결과값은 world 가 될것입니다. 

왜냐하면 before는 6글자이고 hello와 world 둘다 5글자 이지만 world가 더 뒤에 나온 5글자 단어이기 때문입니다.

만약 주어진 배열이 [&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, &amp;quot;after&amp;quot;, &amp;quot;all&amp;quot;] 이라면 결과값은 after가 될것입니다. 

왜냐하면 앞에 세 단어가 모두 5글자이기 때문에 마지막 단어를 반환하기 때문입니다. 

배열은 항상 적어도 문자열 세개를 가지고 있으며, 각각의 문자열은 오직 글자만을 포함하고 있습니다.


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-9&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function thirdGreatest(arr) {
  
  // 여기에 코드를 작성하세요

  // 1. sort() 메소드를 이용해서 문자열의 길이가 가장 긴것들을 가장 처음으로 배열한다. 
  // 2. 3번째 배열에 있는 요소를 출력한다. 

   let lineUp = function (a,b) {
     if (a.length &amp;gt; b.length) {
       return -1;
     } else if (a.length === b.length){
       return 0;
     } else {
       return 1;
     }
  }
  return arr.sort(lineUp)[2];
}
  



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-6&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;superincreasing&#34;&gt;superIncreasing&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;숫자로 이루어진 배열이 주어졌을때, superIncreasing(arr) 함수는 해당 배열이 superIncreasing 조건을 만족하는지 반환합니다. 배열의 모든 요소들이 해당 요소들 앞에 있는 요소들 전체의 합보다 크면 superIncreasing 조건을 만족하는 배열이라 할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
//(예시: 만약 주어진 배열이 [1, 3, 6, 13, 54] 라면 superIncreasing 조건에 만족하기 때문에 여러분의 함수는 true를 반환해야 합니다. 

// 만약 superIncreasing 조건에 만족하지 않는다면 여러분의 함수는 false를 반환해야 합니

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-10&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function superIncreasing(arr) {

  // 1. arr 안에 0번째 요소를 비교할 대상으로 사용하기 위해 변수에 담는다.
  // 2. for 문을 사용하여 배안안에 길이가 끝날때까지 만큼 조건을 걸어둔다. 
  
  // [1, 3, 6, 13, 54] 
  
  let  num = arr[0]; // 1
  for (let i = 0; i &amp;lt; arr.length -1; i = i + 1 ) { // 4
    if (num &amp;gt; arr[i+1]) {  //  1 &amp;gt; 3 
      return false;
    } else {
      num = num + arr[i];
  
    }
  }
  return true
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quesiton-4&#34;&gt;Quesiton&lt;/h3&gt;

&lt;h2 id=&#34;multiplicativepersistence&#34;&gt;multiplicativePersistence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;양의 정수가 주어졌을때, multiplicativePersistence(num) 함수는 주어진 수의 각 자리의 숫자를 곱했을때 한 자릿수가 될때까지의 계산 횟수를 반환합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//예시: 만약 입력값이 39라면, 여러분의 함수는 3을 반환해야 합니다.

//왜냐하면

//3 * 9 = 27

//그리고 2 * 7 = 14

// 그리고 마지막으로 1 * 4 = 4 이므로 한 자리가 될 때까지 총 3번의 계산을 하기 때문입니다.


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-11&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function multiplicativePersistence(num) {
 /*
 0. 숫자를 문자열로 바꾼다.
 1. 입력값(숫자)가 한 자리인가?
 1-1. No -&amp;gt;
 한 글자씩 나눠서 배열로 만든다.
 배열을 도는 반복문을 만드는데,
 새 변수를 1로 저장하고 새 변수에 하나씩 곱해준다. (여기서 숫자로 바꿔줌)
 곱해준 값이 한 자리인지 다시 진단한다.
 */
 let count = 0;
 while(num.toString().length &amp;gt; 1){
   let resultVal = 1
   count = count + 1
   for (let i=0; i&amp;lt;num.toString().length; i++){
     resultVal = resultVal * Number(num.toString()[i]);
   }
   num = resultVal;
 }
 return count;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-7&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;lettercapitalize&#34;&gt;letterCapitalize&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;letterCapitalize(str)는 문자열을 parameter로 받는 함수로, 문자열의 각 단어의 첫번째 글자를 대문자로 만듭니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;output&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
letterCapitalize(&amp;quot;hello world&amp;quot;); // &amp;quot;Hello World&amp;quot;
letterCapitalize(&amp;quot;javascript is sexy&amp;quot;) // &amp;quot;Javascript Is Sexy



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-12&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function letterCapitalize(str) {
  // Your code here

  // &amp;quot;Hello World&amp;quot;
  let strArr = str.split(&amp;quot; &amp;quot;);
  let newArr = [];
  for (let i =0; i &amp;lt; strArr.length; i ++ ) {
  let element = strArr[i].replace(strArr[i][0],strArr[i][0].toUpperCase());
  newArr.push(element);
  }
  return newArr.join(&amp;quot; &amp;quot;);

  
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-8&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;poweroftwo&#34;&gt;powerOfTwo&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;powerOfTwo (num) 함수는 num parameter를 가져와서 정수이며, 동시에 2의 거듭제곱이면 true를 반환합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-13&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function powerOfTwo(num) {
 // 함수를 계속 실행해서 num 1이면 true
 // 정수이면, / 2 한 num 다시 poweroftwo()
 // 재귀함수로
 debugger; // 디버거
 if(num === 1) {
   return true;
 } else if(Number.parseInt(num / 2)) {
   num = num / 2;
   return powerOfTwo(num);   
 } return false;
}

powerOfTwo(16); // true가 반환되어야 함



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-9&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;json-stringfy-함수-만들기&#34;&gt;JSON.stringfy 함수 만들기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; * 2. stringfyJSON은 아래와 같이 작동합니다.
 * 
 * 
 * - Bolean이 input으로 주어졌을 경우
 * stringifyJSON(true);                // &#39;true&#39;
 * 
 * 
 * - String이 input으로 주어졌을 경우
 * stringifyJSON(&#39;foo&#39;);               // &#39;&amp;quot;foo&amp;quot;&#39;
 * 
 * 
 * - Array가 input으로 주어졌을 경우
 * stringifyJSON([1, &#39;false&#39;, false]); // &#39;[1,&amp;quot;false&amp;quot;,false]&#39;
 * 
 * 
 * - Object가 input으로 주어졌을 경우
 * stringifyJSON({ x: 5 });            // &#39;{&amp;quot;x&amp;quot;:5}&#39;
 * 
 * 
 * - undefind, function이 주어졌을 경우
 * stringifyJSON(undefined)            // undefined
 * stringifyJSON(function(){})         // undefined
 * 
 * 
 * stringifyJSON({ x: undefined, y: function(){} })   // &#39;{}&#39;
 * 
 * 3. spec/fixtures.js를 참고해서 테스트에서 어떤 input 값들이
 * 주어지고, 어떻게 stringify해 주어야할지 생각해 보세요.
 * 
 * 4. 그냥 테스트 통과를 하고 싶으시다면, 다음과 같이 구현하면 될거예요.
 *  const stringifyJSON = JSON.stringify;
 * 
 * 하지만 이 과제의 목적은 재귀를 공부하는 것이니, 처음부터 구현해봐야겠지요?:
 */

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-14&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

  

 function stringifyJSON(obj) {

  let result = []  ;

  // boolean or 숫자로 받는다면? 
 
  
  
 
  if(typeof obj === &#39;boolean&#39; || typeof obj === &#39;number&#39;) {
      return String(obj);
    }
    
    // 만약 값이 없다면 
    if (obj === null ) {
      return &#39;null&#39;;
    }

    // string으로 받는다면 
     else if (typeof obj === &amp;quot;string&amp;quot;) {
      return &#39;&amp;quot;&#39; + obj + &#39;&amp;quot;&#39;;
     }
     
     // 배열로 받는다면 
     else if (Array.isArray(obj)) {
      for( let i = 0; i &amp;lt; obj.length; i++ ) {
        // result.push(obj[i]);
        // 왜 여기서 push obj[i]를 안하고 
        // stringifyJOSN(obj[i])
        result.push(stringifyJSON(obj[i])) 
        
      }
      return &amp;quot;[&amp;quot; + result + &amp;quot;]&amp;quot;;
    } 
    // 객체로 받는다
      else if (typeof obj === &#39;object&#39;) {
      for (let propo in obj) {
        if(obj[propo] !== undefined &amp;amp;&amp;amp; typeof obj[propo] !== &#39;function&#39;){
          //  왜 이것은 안되고
          // result.push(&amp;quot;&#39;&amp;quot; + propo + &amp;quot;&#39;&amp;quot; + &#39;:&#39; + &amp;quot;&#39;&amp;quot; + obj[propo] + &amp;quot;&#39;&amp;quot;);
          // 이것은 될까요?
          result.push(stringifyJSON(propo) + &#39;:&#39; + stringifyJSON(obj[propo]));
        }
      }
      return &#39;{&#39; + result + &#39;}&#39;;

    }

  };
  


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-10&#34;&gt;Question&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Broswer에 존재하는 document.getElementsByClassName 함수를
 직접 구현해봅니다.&lt;/p&gt;

&lt;p&gt;getElementsByClassName 함수는 현재 documnet에서 주어진 className을 가지고 있는 모든 html element를 찾는 함수입니다.&lt;/p&gt;

&lt;p&gt;결과는 항상 배열의 형태로 리턴해줍니다.document.body, element.childNodes, element.classList를 사용해보세요&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-15&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  
  
// 이것을 다른 재귀로 구현하세요 
  function getElementsByClassName (className) {
    return document.getElementsByClassName(className);
  };


   // document.body.classList == &amp;gt; 배열형태  but typeof 는 object
   // document.body.childNodes == &amp;gt; 배열형태 but typeof 는 object
   // document.body.children   == &amp;gt; 배열형태 but typeof 는 object
  

function getElementsByClassName(className) {


  let result = [];
  let rootElement = document.body;

  function recursion(rootElement){

    if(rootElement.classList &amp;amp;&amp;amp; rootElement.classList.contains(className)) {
      result.push(rootElement);
    }
    
    if(rootElement.hasChildNodes()){
      // rootElement.children.length 사용해도됨 
      for(let i=0; i&amp;lt;rootElement.childNodes.length; i++){
        recursion(rootElement.childNodes[i]);
      }
    }
  }
  recursion(rootElement);  // 이것이 첫번째로 호출???
  return result;
};




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-11&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;shuffle-함수-만들기&#34;&gt;shuffle 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-16&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 배열 내용의 순서를 랜덤하게 변경합니다.
// TIP: 이 함수는 immutable해야 합니다.


function shuffle(array) {
    let shuffleArr = array.slice();
    let i,j,k;
    for ( i = shuffleArr.length-1; i &amp;gt; 0; i--) {
      j = Math.floor(Math.random()*(i+1));
      k = shuffleArr[i];
      shuffleArr[i] = shuffleArr[j];
      shuffleArr[j] = k;
    } return shuffleArr;
  };



// 더좋은 코드

function shuffle (array) {

  let newArr = [];
  let newArray = array.slice();
  while(newArray.length &amp;gt; 0) {
	let movingNum = newArray.splice(Math.floor(Math.random()*newArray.length),1)[0]
	newArr.push(movingNum);
   }
	return newArr;
  };

// other

function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}


// Another one

function shuffle(array) {
    
    let copy = array.slice();
    copy.sort(function(a, b){
      return Math.random() - 0.5;
    })
    return copy;
  };




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-12&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;flatten-함수-만들기&#34;&gt;flatten 함수 만들기&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;convert nested (2-dimensional) array to flatten array! (2차원 배열을 1차원 배열로 전환하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
flatten([1,2,[3],[4]]); // [1,2,3,4]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-17&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function flatten (array){
  //your solution here
  
  // 1. 재귀함수 사용 
  let ret = []; // 새로운 배열은 만든다. 

   // 재귀함수
    function filtered(array) {
      // (1).array 의 각각의 요소에 접근한다.  [1,2,[11,25,21,34],[4]]
      // (5). array 의 각각의 요소에 접근한다. [11,25,21,34]
      for(let i = 0 ; i &amp;lt; array.length; i ++ ) {
        // (2)만약 요소가 array 안에 array 가아니면  [1,2]
        // (6)만약 요소가 array 안에 array 가 아니면 [11,25,21,34]
        if (!Array.isArray(array[i])){
          // (3)새로만든 배열안에 합친다. ret = [1,2]
          // (7)새로만든 배열안에 합친다. ret = [1,2,11,25,21,34]
          ret = ret.concat(array[i]);
          // (4)만약 array 안에 array 가 발견되면
          // array는 array안에 있는 array로 담기고
          // filtered(array) 가 실행된다.  
        } else {
          filtered(array[i]);
        }
      }
    }
    filtered(array);
  return ret;
  }
  
  // reduece 사용해서 풀기
   
   return array.reduce(function(accu,curr){
     return accu.concat(curr)
   },[]);
  }
  



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-13&#34;&gt;Question&lt;/h3&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;buginapple&#34;&gt;bugInApple&lt;/h2&gt;

&lt;p&gt;Find out &amp;ldquo;B&amp;rdquo;(Bug) in a lot of &amp;ldquo;A&amp;rdquo;(Apple). (수많은 &amp;ldquo;A&amp;rdquo;(Apple) 사이에서 &amp;ldquo;B&amp;rdquo;(Bug)를 찾으세요.)&lt;/p&gt;

&lt;p&gt;There will always be one bug in apple, not need to consider the situation that without bug or more than one bugs. (사과(apple) 사이에는 언제나 항상 한개의 벌레(bug)가 있으므로 벌레가 없는 경우나 한개 이상인 경우는 고려하지 않으셔도 됩니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
//Note: 2-dimesional Array will be input. (노트: 2차원 배열이 매개변수로 주어집니다.)

input:

[[&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;]]

output:
[1,1]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-18&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let bugInApple = function(array) {
 var location = [];
  for ( var i = 0; i &amp;lt; array.length ; i++) {
    for ( var j = 0; j &amp;lt; array[i].length ; j++) {
      if (array[i][j] === &amp;quot;B&amp;quot;) {
        location.push(i);
        location.push(j);
      }
     }
  }
  return location;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-14&#34;&gt;Question&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;using the JavaScript language, have the function firstReverse(str) take the str parameter being passed and return the string in reversed order.&lt;/p&gt;

&lt;p&gt;(firstReverse(str) 함수를 작성하세요. 문자열(str)이 주어졌을때, firstReverse(str) 함수는 주어진 문자열을 역순으로 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;firstreverse&#34;&gt;firstReverse&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-19&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function firstReverse(str) {
  // code here ... :)
  // str = &amp;quot;code&amp;quot;
  // str.split(&#39;&#39;) // [&amp;quot;c&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]
  // str.split(&#39;&#39;).reverse(); //[&amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;c&amp;quot;]
  // str.split(&#39;&#39;).reverse().join(&#39;&#39;) // &amp;quot;edoc&amp;quot;
  return str.split(&#39;&#39;).reverse().join(&#39;&#39;);

}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-15&#34;&gt;Question&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Using the JavaScript language, have the function ABCheck(str) take the str parameter being passed and return the true if the characters a and b are separated by exactly 3 places anywhere in the string at least once Otherwise return the false.&lt;/p&gt;

&lt;p&gt;(ABCheck(str) 함수를 작성하세요. 문자열(str)이 주어졌을때, ABCheck(str) 주어진 문자열에서 함수는 문자 a 와 b 사이가 문자열 안에서 한번이라도 정확히 3글자 떨어져 있으면 true를 반환하고 그렇지 않은 경우는 모두 false 를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-20&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function ABCheck(str) {
  // code goes here

  // lane Borrowed // true otherwise false;
  
  // 대문자를 소문자로 바꾼다. 
  // str 의 각chr 를 접근한다. 
  // a 를 발견하면 인덱스 번호를 착출한다 변수에 담는다. .
  // b 를 발견하면 인덱스 번호를 착출한다 변수에 담는다/
  // 만약 a 와 b
  if (str === undefined) {
    return false;
  }
  str = str.toLowerCase();
  for (let i = 0; i &amp;lt; str.length; i ++ ) {
    if (str[i] === &amp;quot;a&amp;quot; &amp;amp;&amp;amp; str[i + 4] === &amp;quot;b&amp;quot;) {
      return true;
    } else if (str[i] === &amp;quot;b&amp;quot; &amp;amp;&amp;amp; str[i + 4] === &amp;quot;a&amp;quot; ) {
      return true;
    }
  }
  return false;
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-16&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;filteredarray&#34;&gt;filteredArray&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;return a new array that all elements passed testFunction without using filter method (filter 메소드를 사용하지 않고 testFunction 함수를 통과하는 요소로만 이루어진 배열을 반환하는 함수를 작성하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-21&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function filteredArray (array, testFunction) {
 
  let result = []; // 출력할 빈 배열을 만든다. 

  for (let i = 0; i &amp;lt; array.length; i ++ ) {
  // loop 를 돌면서 testFunction 안에 parameter 를 넣었을때 동작한다면
    if (testFunction(array[i])){
    // 그값을 새로운  array 넣어서 저장한다. 
      result.push(array[i])
    }
  }
  return result;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-1&#34;&gt;Qeustion&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;다차원 배열을 가져와서, 1차원 배열로 변환합니다.&lt;/p&gt;

&lt;p&gt;새 배열에는 다차원 배열의 모든 요소가 포함되어야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;flatten-함수-만들기-1&#34;&gt;flatten 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soution&#34;&gt;My_Soution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// for 문을이용한 것 

function flatten (nestedArray) {
    //[1, [2], [3, [[[4]]]]]
    //oneflat([1, [2], [3, [[[4]]]]])
    // result = [1, 2, 3, [[[4]]]]
    // result = [1, 2, 3, 4]
    let oneflat = function(array) {
      let resultArr = []
      for (let i in array) {
        if (Array.isArray(array[i])) {
          resultArr = resultArr.concat(array[i]);
        } else {
          resultArr.push(array[i]);
        }
      }
      return resultArr;
    }
    let isinArr = function(array) {
      for (let i in array) {
        if (Array.isArray(array[i])) {
          return true;
        }
      }
      return false;
    }
    while(isinArr(nestedArray)) {
      nestedArray = oneflat(nestedArray);
    }
    return nestedArray;
  };



function flatten (nestedArray, result) {


     // 재귀를 이용한것 

     result = [];
     function flatarr(nestedArray) {
       for(let i = 0; i &amp;lt; nestedArray.length; i++) {
         if(!Array.isArray(nestedArray[i])) {
           result = result.concat(nestedArray[i])
         } else {
           flatarr(nestedArray[i]);
         }
       }
     } flatarr(nestedArray);
     return result;
   };
 



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-2&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;delay-함수-만들기&#34;&gt;delay 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-22&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


  // 주어진 시간 (밀리초) 동안 함수를 지연한 다음 제공된 argument로 함수를 호출합니다.
  //
  // 원래 함수에 대한 argument는 wait parameter 뒤에 전달됩니다.
  // 예를 들어, 다음을 호출할 경우
  // _.delay(someFunction, 500, &#39;a&#39;, &#39;b&#39;);
  // someFunction(&#39;a&#39;, &#39;b&#39;) 은 500ms 이후에 호출됩니다.


  _.delay = function(func, wait, ...args) {

      setTimeout(function(){
        return func(...args);
      } ,wait);

  };




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-3&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;최대-한번만-호출할-수-있는-함수-만들기&#34;&gt;최대 한번만 호출할 수 있는 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-23&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
  function once(func) {
 
    // ... agrgs 사용한 함수 

    var alreadyCalled = false;
    let result;
    return function(...args) {
      if (!alreadyCalled) {
        alreadyCalled = true;
        result = func(...args);
      }
      return result;
    };
  };


// this 와 arguments 와 apply 를 사용한 함수 

    let alreadyCalled = false;

    let result;

  
    return function() {
      if(alreadyCalled) {
        return result 
    } else {
        alreadyCalled = true 
        return result = func.apply(this, arguments);
      }
    }
  };



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-4&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;갹채를-함쳐주는-함수-만들기-2-key-덮어쓰지-않기&#34;&gt;갹채를 함쳐주는 함수 만들기 2 (key 덮어쓰지 않기 )&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-24&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; // extend와 비슷하지만, 이번엔 이미 존재하는 key에 대해 값을 덮어쓰기 하지 않습니다.
  function defaults (obj,...objs) {
    
    for (let i = 0; i &amp;lt; objs.length; i ++ ) {
      for (let prop in objs[i]){
        // 만약 기존에있는 obj 의 키값이 새로 더해진 obj 에 없다면 
        if (!(prop in obj)) { 
          // 기존에 있는 obj 의 push 해준다. 
          obj[prop] = objs[i][prop];
        }
      }
    }
    return obj;
  }




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-5&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;갹채를-함쳐주는-함수-만들기&#34;&gt;갹채를 함쳐주는 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-souliton&#34;&gt;My_Souliton&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
extend = function(obj, ...objs) {
  
    //객체를 합쳐주는 함수를 만들어보자
  
    for (let i = 0; i &amp;lt; objs.length; i ++ ) {
      for (let prop in objs[i] ) {
        obj[prop] = objs[i][prop];
      }
    }
    return obj;
  }



// other_Soultion


    for(let i = 0; i &amp;lt; arguments.length; i++) {
      for(let key in arguments[i]) {
      obj[key] = arguments[i][key]
      }
    } return obj;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-6&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;some-함수-만들기&#34;&gt;some 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-25&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

  // element가 하나라도 iterator에 의해 truthy한지 체크합니다.
  // iterator가 없다면, element 그 자체가 truthy한지 체크하세요.
function some(collection, iterator) {

    if(iterator === undefined) { // 이것을 왜하는지 ?
      for(let i = 0 ; i &amp;lt; collection.length ; i++) {
        if(Boolean(collection[i]) === true) {
          return true;
        }  
      }
    } else if (iterator) { // 이것은 왜? 
      for (let j = 0 ; j &amp;lt; collection.length ; j++) {
        if (Boolean(iterator(collection[j])) === true) {
          return true;
        }
      }
    } return false;
  };






&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-7&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;every-함수-만들기&#34;&gt;every 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soultion-26&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 모든 element가 iterator에 의해 truthy한지 체크합니다.
  function every(collection, iterator) {
  
  // function every(collection,iterator)
  // collection.every(terator(value, key, collection)) ???
  
    if(iterator === undefined) { // 이것을 왜하는지 ?
      for(let i = 0 ; i &amp;lt; collection.length ; i++) {
        if(Boolean(collection[i]) === false) {
          return false;
        }  
      }
    } else if (iterator) { // 이것은 왜? 
      for (let j = 0 ; j &amp;lt; collection.length ; j++) {
        if (Boolean(iterator(collection[j])) === false) {
          return false;
        }
      }
    } return true;
  };




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qeustion-8&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;contains-함수-만들기&#34;&gt;contains 함수 만들기&lt;/h2&gt;

&lt;h3 id=&#34;my-soultoin-1&#34;&gt;My_Soultoin&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //배열 또는 객체가 주어진 값을 포함하는지 체크합니다. (`===` 연산자를 사용해서 판단합니다.)

  _.contains = function(collection, target) {
 

    for (let i in collection ) {
      if (collection[i] === target ){
        return true
        } 
      }
      return false;
  }

    // 다른 깔끔한 방법
    // each 방법을 써서..

    if (Array.isArray(collection)) {
       for (let i = 0; i &amp;lt; collection.length; i ++  ) {
         if (collection[i] === target) {  
           return true;
         } else {
           return false;
         }
       }
     } else {
       for (let prop in collection) {
         if (collection[prop] === target) { 
           return true;
         } else {  
           return false;
         }
       }
     } 
      



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-17&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;reduce&#34;&gt;reduce&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 각 항목에 대해 iterator(accumulator, item)를 반복적으로 호출하여, Reduces an array to a single value by repetitively calling
  // 하나의 값으로 줄입니다. accumulator는 누적값으로, 이전 iterator 호출의 반환값이어야 합니다.
  //
  // reduce에 대한 세번째 argument로 초기값을 전달 할 수 있습니다.
  // 만일 초기값이 전달되지 않으면, 첫번재 element가 accumulator로 사용되며, iterator에 전달되지 않습니다.
  // 즉, 초기값이 전달되지 않은 경우, iterator는 두번째 element로부터 시작합니다.
  //
  // 예제:
  //   const numbers = [1,2,3];
  //   const sum = _.reduce(numbers, function(total, number){
  //     return total + number;
  //   }, 0); // 6이 리턴됩니다
  //
  //   const identity = _.reduce([5], function(total, number){
  //     return total + number * number;
  //   }); // 5가 리턴됩니다, 전달한 iterator와 관계없이, 첫번째 element가 즉시 사용됩니다.
  


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-27&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


  _.reduce = function(collection, iterator, accumulator) {
     
     // 1. 내가 생각 방법
      let i=0;
      if (accumulator === undefined) {
        accumulator = collection[0];
        i++;
      }
      for(i; i&amp;lt;collection.length; i++) {
        accumulator = iterator(accumulator, collection[i]);
      }
      return accumulator;
    }
  // accumulator가 undefined면 : accumulator에게 첫 번째 collection값을 넣고,
  // 그 후 i++를 통해 collection[0]이 아닌 collection[1]부터 iterator가 돌아감
  // 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-18&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;billtotal&#34;&gt;billTotal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called billTotal that can be used to calculate the total to be paid at a restaurant &amp;ndash; including tip and tax &amp;ndash; given the subtotal (i.e. cost of food and drinks). We can assume that the tip will be 15% and tax will be 9.5%. Make sure that the tip does not include the tax!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;- input: a number representing the cost of food and drinks
- output: a number representing that cost plus an additional 15% tip and tax of 9.5%

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-28&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function billTotal(subtotal) {
  // YOUR CODE HERE

  // tip 15% = * 0.15
  // tax 9.5% = * 0.095
  
  // tip을 얼마 냈는지 조사후 변수에 저장
  // tax를 얼마나 냈는지 조사후 변수에 저장
  // tip &amp;amp; tax &amp;amp; subtotal 더한값을 출력
  
  let tip = subtotal * 0.15
  let tax = subtotal * 0.095
  
  return subtotal + tip + tax;
}

billTotal(10.00); // =&amp;gt; 12.45


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-19&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;multiplybetween&#34;&gt;multiplyBetween&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;multiplyBetween&amp;rdquo;. (&amp;ldquo;multiplyBetween&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 2 integers, &amp;ldquo;multiplyBetween&amp;rdquo; returns the product between the two given integers, beginning at num1, and excluding num2. (두 정수가 주어졌을때, &amp;ldquo;multiplyBetween&amp;rdquo; 함수는 첫번째 숫자부터 두번째 숫자 전까지 모든 수를 곱한 값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let output = multiplyBetween(2, 5);
console.log(output); // --&amp;gt; 24

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-29&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function multiplyBetween(num1, num2) {
  // your code here
	let arr = [];
    if (num2 &amp;lt; num1 || num1 === num2 ) {
    return 0;
  	} else {
	  
	  while( num1 &amp;lt; num2 ) {
		arr.push(num1);
		num1 = num1 + 1;
      	
     }
  }
console.log(arr);
  return arr.reduce(function(acc,cur){
      return acc * cur;
  })
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-20&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computesquareroot&#34;&gt;computeSquareRoot&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeSquareRoot&amp;rdquo;. (&amp;ldquo;computeSquareRoot&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;computeSquareRoot&amp;rdquo; returns its square root. (숫자가 주어졌을때, &amp;ldquo;computeSquareRoot&amp;rdquo; 함수는 해당 수의 제곱근 값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let output = computeSquareRoot(9);
console.log(output); // --&amp;gt; 3


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Do not use Math.sqrt(); for this problem. Instead, use this iterative way of solving the problem: (Math.sqrt()를 사용하지 말고, 아래 링크에서 나온 방법을 통해 해결하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-30&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
unction computeSquareRoot(num) {
  
  let square = 1;
  let i = 0;
  
  while(true){
      i = i + 1
      
      square = (num / square + square) / 2;
      if(i=== num + 1) { 
       break;
      }
  } 
  return Number(square.toFixed());
}


/*
- doc 파일에 있는 내용 정리
5 / 2 = 2.5 -&amp;gt; 다음줄 2.5에 5/2를 대입
(2 + 2.5) / 2 = 2.25 -&amp;gt;(2+ (5/2)) / 2 = 2.25 = x + (num/x) / 2
5 / 2.25 = 2.222...
(2.25 + 2.222...) / 2 = 2.36111...
5 / 2.236111... = result
*/

/* !질문란
9를 넣으면 3이 나오지만,
4를 넣으면 2.000000000000002 이 계속나오길래
.toFixed()를 이용해서 소수점을 제거하여 결과값은 잘나오는데
테스트는 계속 fail로 나옵니다ㅠㅠ
toFixed()를 지우면 4를 넣었을시만 통과가 안되구요!
어떻게 해야할까요?ㅠㅠ
*/


// 처음에 square를 1로 선언해주셨는데, square는 단순히 1이 아닌, 
// 저희가 input으로 받은 값보다 같거나 작은 제곱수 중 가장 큰 값을 만들 수 있는 수가 되어야할 것 같습니다.

// 예를들어 5가 주어졌을 때 5보다 작은 제곱수는 4 square는 2
// 10이라면 10보다 작은 제곱수는 9 square는 3이 되어야할 것 같습니다.


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-21&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;modulo&#34;&gt;modulo&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;modulo&amp;rdquo;. (&amp;ldquo;modulo&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 2 numbers, &amp;ldquo;modulo&amp;rdquo; returns the remainder after dividing num1 by num2. (두 숫자가 주어졌을때, &amp;ldquo;modulo&amp;rdquo; 함수는 첫번째 수를 두번째 수로 나눴을때 나머지 값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

let output = modulo(25, 4);
console.log(output); // --&amp;gt; 1


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-31&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function modulo(num1, num2) {
    // num1 = 25 num2 = 4
  
  if (isNaN(num2) || num2 === 0) {
    return NaN;
  }

  // plusMinus 변수는 만약 첫번째 숫자가 plus 이면 마지막에 플러스를 마이너스를 표시하기 위해
  // 미리 변수를 지정해둔다.
  // 만약 num1 이 0보다 크면 plusMinus = 1
  // 만약 num2 가 0 보다 작으면 plusMinus = -1
  let plusMinus = num1 &amp;gt; 0 ? 1 : -1; //  이부분이 이해가 안됨. 

  num1 = Math.abs(num1);
  num2 = Math.abs(num2);

  while (num1 &amp;gt;= num2) {  // 25 &amp;gt;= 4
    num1 = num1 - num2; //  24 - 4 계속 빼면 = num1 = 1 
  }
  return num1 * plusMinus;  // 1 * plusMinus ( 1 ) 
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-22&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;unique&#34;&gt;unique&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Return a duplicate-free version of the collection.
You don&#39;t need to care about non-primitive type elements.
Array will be contained only primitive type values. (string, number, boolean)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-32&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;unction unique(array) {
  // your code here


  let newArr = []

  for (let i = 0; i &amp;lt; array.length; i ++ ) {
    if (!newArr.includes(array[i])){
      newArr.push(array[i]);
    }
  }
    return newArr;
  }


  // 1. other_Soultion

  // function unique(array) {
  //   // your code here
  //   return array.reduce(function(acc, curr){
  //     if(!acc.includes(curr)){
  //       acc.push(curr);
  //       return acc;
  //     } else {
  //       return acc;
  //     }
  //   }, []);
  // }





 // 2. other_Soultion

//  function unique(array) {
//   // your code here
//   return Array.from(new Set(array))
// }






&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-23&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;tenthousandclub&#34;&gt;tenThousandClub&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
# tenThousandClub

Write a function, tenThousandClub, that takes in an array of information, salesTeam, and returns an array that lists the full names of each member of the sales team that has sales greater than $10,000.
Make sure the first and last names are separated by a space.

Hint: I recommend you write a helper function, salesToNumber, that converts the sales string to a number.
Feel free to look up parseInt() and slice() on MDN if you don&#39;t remember how they work.

- output: an array that lists the full names of each member of 10,000 club


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-33&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function tenThousandClub(salesTeam){
  // your code here

  // function salesToNumber(salesString){
  //   //get rid of dollar sign:
  //   let number = salesString.split(&#39;&#39;).splice(1)
  //   return parseInt(number.join(&#39;&#39;));
  // }
  let newobj = salesTeam.filter(function(ele){
    return salesToNumber(ele.sales) &amp;gt;= 10000; 
  }).map(function(ele){
    return `${ele.name.first} ${ele.name.last}`;
  });
  return newobj;
}


// &amp;quot;$1234&amp;quot;  string to Number 숫자로 바꾸기 바꾸기 

// it&#39;s me
function salesToNumber(salesString){
  //get rid of dollar sign:
  let number = salesString.split(&#39;&#39;).splice(1)
  return parseInt(number.join(&#39;&#39;));
}


// other&#39;s

// function salesToNumber(salesString){
//   //get rid of dollar sign:
//   return Number(salesString.slice(1));
// }

// other&#39;s

// function salesToNumber(obj){
//   return Number.parseInt(obj.sales.slice(1));
// }



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-24&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;sumconsecutives&#34;&gt;sumConsecutives&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

You are given a list/array which contains only integers (positive and negative). Your job is to sum only the numbers that are the same and consecutive. The result should be one list.

Examples:
[1,4,4,4,0,4,3,3,1] should return [1,12,0,4,6,1]

So as you can see sum of consecutives 1 is 1
sum of 3 consecutives 4 is 12
sum of 0... and
sum of 2 consecutives 3 is 6 ...

[1,1,7,7,3] should return [2,14,3]
[-5,-5,7,7,12,0] should return [-10,14,12,0]

- output: an reduced array

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-34&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function sumConsecutives(s) {
    // your code here


    //[1,4,4,4,0,4,3,3,1] should return [1,12,0,4,6,1]
  
    let ret = []; // 마지막에 출력할  result 배열을 만든다. 
    let sum = 0;  // sum 이라는 것을 0 으로 초기화 시킨다. 

    for(let i = 0; i &amp;lt; s.length; i++) {

        // 첫번째 loop sum =  0 + 1 
        // 두번째 loop sum = 0 + 4 
        // 3번째 loop sum = 4 + 4 // 초기화 되지 않은 sum 과 다음에 나오르 4 를 합한다. 
       
        
        sum = sum + s[i];  
       
       
        // 첫번째 loop 
        // 만약 0번째있는 숫자 1과  1번째의 숫자4가 같지 않다면 
        // 조건문 1 을 ret 에 집어넣는다 [1]
        //  조건문  sum 이라는 것을 다시 0으로 초기화 한다.
        // 두번째 loop  
        // 1번째 있는 4와 2번째 있는 4와 같으므로 조건문에 해당이 안된다. 
        // sum 이 초기화 되지 않은채 위로 올라간다.   

        if(s[i] !== s[i + 1]) {
            ret.push(sum)  //  위에있는 sum 을 우선 채우고 
            sum = 0;    //  sum 을 다시 초기화 한다. 
        }
    }
     
    return ret;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-25&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;oldest&#34;&gt;oldest&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
# oldest

Write a function, oldest, that takes in an array of information, salesTeam, and returns a sentence with the person&#39;s first and last name, e.g. &amp;quot;The oldest student is Tina Fey&amp;quot;.

If there is a tie for the oldest student, return the student whose name appears first in the salesTeam array.

- output: a string value with name of oldest person

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-35&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function oldest(salesTeam){
 
  // 먼저 배열안에 객체에 접근해서 모든 나이를 뽑아서 배열어 넣는다..
  // 나이중에 가장 높은 숫자를 변수에 담는다.
  // 변수에 담긴 가장 높은 숫자와 배열안에 객체에 나이가 같다면 first name  과 last name 을 가져온다. 
  
  var ageArr = salesTeam.map(function(ele){
    return ele.age;
  })
  var max = ageArr.reduce(function(a,c){
    return Math.max(a,c);
  });
  var fullName = [];
  salesTeam.forEach(function(ele){
    if ( ele.age === max) {
      fullName.push(`${ele.name.first} ${ele.name.last}`)
    }
  })
  return &amp;quot;The oldest student is &amp;quot; + fullName.join(&amp;quot; &amp;quot;);
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-26&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isagediverse&#34;&gt;isAgeDiverse&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
You will be given an array of objects representing data related to their age and total sales.

Your task is to return:
- `true` if members from all of the following age groups: teens, twenties, thirties, forties, fifties, sixties, seventies, eighties.
- `false` otherwise.

Your function should return true as there is at least one member from each age group.

- output: a boolean value representing whether the age range is diverse



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-36&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var isAgeDiverse = function(list) {
  
  // group 이 10-80 까지 는 true 리턴
  // 아니라면 false 리턴 
  
  var ageArr = list.map(function(ele){
    return ele.age; // [26, 55, 29, 53, 19, 25, 26]
  });
    for (let i = 0; i &amp;lt; ageArr.length; i = i + 1 ) {
      if (ageArr[i] &amp;gt;= 10 &amp;amp;&amp;amp; ageArr[i] &amp;lt; 90) {
      return true;
    } else {
    return false;
    }
  };
};

  // other code here
  // 팀원이 10대~80대 면 true를 반환해라.
  // function filtering(el){  // 클로져를 써보자
  //   return el.age &amp;gt;= 10 &amp;amp;&amp;amp; el.age &amp;lt; 90 
  // }
  // // every를 써서 모두가 맞는지 확인한다.
  // return list.every(filterin



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-27&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getteenager&#34;&gt;getTeenager&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function, &lt;code&gt;getTeenager&lt;/code&gt;, that takes in an array of information, salesTeam, and returns an array that lists the full names of each member of the sales team that is a teenager.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Make sure the first and last names are separated by a space.

Notes:
- moving through each element of the array.
- check if they are a teenager (&amp;lt; 20).
- if they&#39;re a teenager, store their full name, separated by a space into the array.

* * *

- output: an array that lists the full names of each member of the sales team that is a teenager

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-37&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getTeenager(salesTeam) {
  let teenager = [];

  
  for(let i=0; i &amp;lt; salesTeam.length; i++) {
    let fullName = salesTeam[i].name.first + &#39; &#39; + salesTeam[i].name.last;
    if(salesTeam[i].age &amp;lt; 20) {
      teenager.push(fullName)

    }
  }
  return teenager;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getTeenager(salesTeam) {
  // your code here
  let teenager = salesTeam.filter(function(ele){
    return ele.age &amp;lt; 20;
  });
  let result = [];
  teenager.forEach(function(ele){
    result.push(`${ele.name.first} ${ele.name.last}`);
  });
  return result;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-1&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getTeenager(salesTeam) {

// filter 와 map을 이용해서 


return salesTeam.filter((ele)=&amp;gt;{
	return ele.age &amp;lt; 20;  
}).map((ele)=&amp;gt;{
	return ele.name.first +&amp;quot; &amp;quot;+ ele.name.last;
})



}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-28&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;sumdigits&#34;&gt;sumDigits&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;sumDigits&amp;rdquo;. (&amp;ldquo;sumDigits&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;sumDigits&amp;rdquo; returns the sum of all its digits. (숫자가 주어졌을때, &amp;ldquo;sumDigits&amp;rdquo; 함수는 숫자의 각 자리수를 모두 더한 값을 반환합니다.)
k&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-38&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function sumDigits(num) {
  let sum = 0;
  let stringNumArr = num.toString().split(&#39;&#39;);

  for (let i = 0; i &amp;lt; stringNumArr.length; i++) {
    if (stringNumArr[0] === &#39;-&#39; &amp;amp;&amp;amp; i === 1) {
      sum = sum - Number(stringNumArr[1]);
    } else if (stringNumArr[i] !== &#39;-&#39;) {
      sum = sum + Number(stringNumArr[i]);
    }
  }

  return sum;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-29&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;offlineminimum&#34;&gt;offLineMinimum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Have the function &lt;code&gt;offLineMinimum(strArr)&lt;/code&gt; take the strArr parameter being passed which will be an array of integers ranging from 1&amp;hellip;n and the letter &amp;ldquo;E&amp;rdquo; and return the correct subset based on the following rules.&lt;/p&gt;

&lt;p&gt;The input will be in the following format: &lt;code&gt;[&amp;quot;I&amp;quot;,&amp;quot;I&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;I&amp;quot;,...,&amp;quot;E&amp;quot;,...,&amp;quot;I&amp;quot;]&lt;/code&gt; where the I&amp;rsquo;s stand for integers and the E means take out the smallest integer currently in the whole set.
When finished, your program should return that new set with integers separated by commas.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-39&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function offLineMinimum(strArr) {


  let numArr=[];
  let resultArr=[];
   
  // [&amp;quot;5&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;2&amp;quot;]
  
  for(let i=0; i&amp;lt; strArr.length; i++){
    // 만약 E와 같지 않다면 
    if (strArr[i] !== &#39;E&#39;) {
      // 이코드는 7번 실행된다 왜냐하면 E 가 3개만 있기 때문이다. 
      
      numArr.push(strArr[i]);
    
     
      //   (1) [&amp;quot;5&amp;quot;]
      //   (2) [&amp;quot;5&amp;quot;, &amp;quot;4&amp;quot;]
      //   (3) [&amp;quot;5&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;6&amp;quot;]
      //   (4) [&amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;1&amp;quot;]
      //   (5) [&amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;7&amp;quot;]
      //   (6) [&amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;3&amp;quot;]
      //   (7) [&amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;2&amp;quot;]   
      
      
      
      // // 만약 E와 같다면 
    } else if(strArr[i] === &#39;E&#39;) {
      
      
       let smallNum = numArr.reduce(function(acc,curr){
          
         // 첫번째 &amp;quot;E&amp;quot; 나오면  numArr = [&amp;quot;5&amp;quot;,&amp;quot;4&amp;quot;,6] 작은수 =&amp;gt; &amp;quot;4&amp;quot;
         // 두번째 &amp;quot;E&amp;quot; 나오면  numArr =  [&amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;7&amp;quot;] 작은수 =&amp;gt; &amp;quot;1&amp;quot;
         // 세번째 &amp;quot;E&amp;quot; 나오면  numArr = [&amp;quot;5&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;7&amp;quot;]  작은수 =&amp;gt; &amp;quot;5&amp;quot;

         // smallNum = [&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;5&amp;quot;] 3번에 담긴다 가장 작은수들이 coz E를 3번 찾았기 때문에
         
         if(acc &amp;lt; curr){
           return acc;
         } else {
           return curr;
         }
       });

      // 첫번째 &amp;quot;E&amp;quot; 나오면 smallNum = &amp;quot;4&amp;quot; 
      // 두번째 &amp;quot;E&amp;quot; 나오면 smallNum = &amp;quot;1&amp;quot;
      // 세번째 &amp;quot;E&amp;quot; 나오면 smallNum = &amp;quot;7&amp;quot;

      // resultArr 에 [&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;7&amp;quot;]; 담긴다.
       resultArr.push(smallNum); 
       
       // 첫번째 &amp;quot;E&amp;quot; 나오면 [&amp;quot;5&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;6&amp;quot;].splice(1,1) // &amp;quot;4&amp;quot; 삭제됨
       // 두번째 &amp;quot;E&amp;quot; 나오면 [&amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;7&amp;quot;].splice(2,1) // &amp;quot;1&amp;quot; 삭제됨
       // 세번째 &amp;quot;E&amp;quot; 나오면 [&amp;quot;5&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;7&amp;quot;].splice(0,1) // &amp;quot;5&amp;quot; // &amp;quot;5&amp;quot; 삭제됨  
       numArr.splice(numArr.indexOf(smallNum),1); 
   }
  }
    return resultArr.join(&#39;,&#39;); // 마지막으로 &amp;quot;4,1,5&amp;quot; =&amp;gt;&amp;gt;,나눠서 함친다.
 }


 
offLineMinimum([&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;3&amp;quot;]); // =&amp;gt; &#39;1,2&#39;
offLineMinimum([&amp;quot;4&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;E&amp;quot;]); // =&amp;gt; &#39;4,1,2,3&#39;
offLineMinimum([&amp;quot;5&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;2&amp;quot;]) // == &amp;gt; 
`4,1,5`



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-2&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function offLineMinimum(strArr) {
  
   
// offLinMininum은 배열에서 &#39;E&#39; 가 나오기 이전까지의 숫자들로 숫자의 set을 만들고 e가 등장 할 때 마다 숫자 set 중 가장 작은 수를 가지고와 리턴할 문자열에 포함시켜주는 함수이다.

    // 배열에서 &#39;E&#39;가 나오기 이전까지의 숫자들로 숫자의 Set을 만든다. --&amp;gt; numberSet
    // 배열에서 &#39;E&#39;가 등장하면, numberSet을 분류(작은 수~큰 수)하고 numberSet의 0번째 값(가장 작은 수)을 가지고와 result에 넣어준다.
    // 그리고 numberSet의 0번째 값은 제거해준다.
    // 그래야 다음 번에 &#39;E&#39;가 등장하면 그 요소를 제외한 나머지 값들 중에서 최소값을 구할 수 있기 때문이다.

    let numberSet=[];
    let result=[];

    for (let i = 0 ; i &amp;lt; strArr.length ; i++) {
        if (strArr[i] !== &#39;E&#39;) {
            numberSet.push(Number(strArr[i]));
        }
        else if (strArr[i] === &#39;E&#39;) {
            numberSet.sort();
            result.push(numberSet[0]);
            numberSet.shift();
        }
    }

    return result.join();
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-30&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;range&#34;&gt;range&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Complete the below function called range that takes two integers as parameters, start and end, and returns an array containing all the whole numbers between them starting with start and up to end (you can use a any loop)&lt;/p&gt;

&lt;p&gt;After you write your function, you can test it using the above inputs to make sure that it behaves correctly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-40&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function range(start, end) {
  // YOUR CODE HERE
  
  
    
  // 만약 strat 와 end 같다면 &amp;amp;&amp;amp; 만약 strat 가 end 보다 작으면 [] 반환
  // for 문을 사용해 start 를 초기값으로 지정하고 end 보다 작을때까지 숫자 반환
  
  let arr = [];
  
  if ( start === end || start &amp;gt;= end ) {
    return [];
  } else { 
    for ( let i = start; i &amp;lt; end; i = i + 1 ) {
      arr.push(i);
    }
  }
  return arr;
  }

range(0, 4); // =&amp;gt; [0, 1, 2, 3]
range(2, 7); // =&amp;gt; [2, 3, 4, 5, 6]
range(10, 10); // =&amp;gt; []
range(10, 2); // =&amp;gt; []



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-31&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;longestname&#34;&gt;longestName&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given the following array of people, write a function that, when passed people as a parameter, returns the person (that is, your function should return an object) with the longest name (first, middle &amp;amp; last).
You can re-use getFullName function.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soution-1&#34;&gt;My_Soution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var people = [
  {name: {first: &amp;quot;Alyssa&amp;quot;, middle: &amp;quot;P.&amp;quot;, last: &amp;quot;Hacker&amp;quot;}, age: 26},
  {name: {first: &amp;quot;Ben&amp;quot;, last: &amp;quot;Bitdiddle&amp;quot;}, age: 34},
  {name: {first: &amp;quot;Eva&amp;quot;, middle: &amp;quot;Lu&amp;quot;, last: &amp;quot;Ator&amp;quot;}, age: 40},
  {name: {first: &amp;quot;Lem&amp;quot;, middle: &amp;quot;E.&amp;quot;, last: &amp;quot;Tweakit&amp;quot;}, age: 45},
  {name: {first: &amp;quot;Louis&amp;quot;, last: &amp;quot;Reasoner&amp;quot;}, age: 21}
];


function longestName(people) {
  // TODO: Your code here
  // 심플하게 객체에 있는 키값을 prop  가져와 함친다. 
  return Object.values(people[0].name).join(&#39; &#39;);
 

}

longestName(people); //&amp;quot;Alyssa P. Hacker&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;### Question&lt;/p&gt;

&lt;h2 id=&#34;hammingdistance&#34;&gt;hammingDistance&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;have the function &lt;code&gt;HammingDistance(strArr)&lt;/code&gt; take the array of strings stored in &lt;code&gt;strArr&lt;/code&gt;, which will only contain two strings of equal length andreturn the Hamming distance between them.
The Hamming distance is the number of positions where the corresponding characters are different.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;For example:
if `strArr` is `[&amp;quot;coder&amp;quot;, &amp;quot;codec&amp;quot;]` then your program should return 1.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-41&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function hammingDistance(strArr) {
  // YOUR CODE HERE

  // count 변수에 0으로 초기화를 시켜놓는다.
  // arr1 변수를 만들어 strArr 첫번째 값을 넣어둔다.
  // arr2 변수를 많들어 strArr 두번째 값을 넣어둔다. 
  // while 문 이용해 arr1각각char arr2각각 Char 와 같이 않다면 count에 plus 1 증가 
  // 출력 count ;


  let count = 0;

  let str1 = strArr[0];
  let str2 = strArr[1];
  
  for (let i = 0; i &amp;lt; str1.length; i = i + 1 ) {
    if ( str1[i] !== str2[i] ) {
      count = count +  1;
    }
  }

  return count;
}

hammingDistance([&amp;quot;coder&amp;quot;, &amp;quot;codec&amp;quot;]); // =&amp;gt; 1
hammingDistance([&amp;quot;10011&amp;quot;, &amp;quot;10100&amp;quot;]); // =&amp;gt; 3
hammingDistance([&amp;quot;helloworld&amp;quot;, &amp;quot;worldhello&amp;quot;]); // =&amp;gt; 8




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-3&#34;&gt;Other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

strArr[0][0] !== strArr[1][0] count++
strArr[0][1] !== strArr[1][1] count++
strArr[0][2] !== strArr[1][2] count++
strArr[0][3] !== strArr[1][3] count++
strArr[0][4] !== strArr[1][4] count++


// 위를 잘 참고하여...구현해본다!
// 각각 비교하면서 다른 값을 배열에 담아 개수를 리턴한다.



function hammingDistance(strArr) {
  return strArr[0].split(&#39;&#39;).filter((char, i) =&amp;gt; char !== strArr[1][i]).length;
}

hammingDistance([&amp;quot;coder&amp;quot;, &amp;quot;codec&amp;quot;]); // =&amp;gt; 1
hammingDistance([&amp;quot;10011&amp;quot;, &amp;quot;10100&amp;quot;]); // =&amp;gt; 3
hammingDistance([&amp;quot;helloworld&amp;quot;, &amp;quot;worldhello&amp;quot;]); // =&amp;gt; 8
console.log(hammingDistance([&amp;quot;coder&amp;quot;, &amp;quot;codec&amp;quot;]))


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-32&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getfullname&#34;&gt;getFullName&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;lsquo;getFullName&amp;rsquo; that takes in an object which has this structure:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-42&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getFullName(obj) {
  // YOUR CODE HERE
  //  변수를 만들어 person에 있는 키의 값들을 가져와서 조합시킨다. 
  // 변수를 출력한다. 
  
  
let fullName = person.name.first + &amp;quot; &amp;quot; + person.name.middle + &amp;quot; &amp;quot; + person.name.last;  

  return fullName;
}

var person = {
  name : {
    first : &amp;quot;Alyssa&amp;quot;,
    middle: &amp;quot;P.&amp;quot;,
    last: &amp;quot;Hacker&amp;quot;
  },
  age : 26
};
getFullName(person); //&amp;quot;Alyssa P. Hacker&amp;quot;

var personB = {
  name: {
    first: &amp;quot;Ben&amp;quot;,
    last: &amp;quot;Bitdiddle&amp;quot;
  },
  age: 34
};
getFullName(personB); //&amp;quot;Ben Bitdiddle&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-4&#34;&gt;Other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

//함수 아래 케이스에 맞게 name값에 접근하여 fullName을 만든다.
//하나하나 따로 뽑기보다는 value를 배열로 받아서 합치는게 편하다 :)

function getFullName(obj) {
  return Object.values(obj.name).join(&#39; &#39;)
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-33&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;billtotal-1&#34;&gt;billTotal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called billTotal that can be used to calculate the total to be paid at a restaurant &amp;ndash; including tip and tax &amp;ndash; given the subtotal (i.e. cost of food and drinks). We can assume that the tip will be 15% and tax will be 9.5%. Make sure that the tip does not include the tax!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-43&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

- input: a number representing the cost of food and drinks
- output: a number representing that cost plus an additional 15% tip and tax of 9.5%


function billTotal(subtotal) {
  // YOUR CODE HERE

  // tip 15% = * 0.15
  // tax 9.5% = * 0.095
  
  // tip을 얼마 냈는지 조사후 변수에 저장
  // tax를 얼마나 냈는지 조사후 변수에 저장
  // tip &amp;amp; tax &amp;amp; subtotal 더한값을 출력
  
  let tip = subtotal * 0.15
  let tax = subtotal * 0.095
  
  return subtotal + tip + tax;
}

billTotal(10.00); // =&amp;gt; 12.45



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-5&#34;&gt;Other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 뭐 단순하게...팁 15%, 세금 9.5% 더해주면 된다고 한다 :)

function billTotal(subtotal) {
  return (subtotal * 1.15 + subtotal * 0.095)
}

billTotal(10.00); // =&amp;gt; 12.45





&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-34&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;primemover&#34;&gt;primeMover&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Have the function primeMover(n) return the n-th prime number. The range will be from 1 to 5 * 10^4; (숫자(n)가 주어졌을때, &amp;lsquo;primeMover(n)&amp;rsquo; 함수는 num 번째 소수를 반환합니다. 범위는 1에서 50,000 입니다.)&lt;/p&gt;

&lt;p&gt;For example: if n is 16 the output should be 53 as 53 is the 16th prime number. (예시: 만약 n 이 16이라면, 결과값은 16번째 소수인 53 입니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-44&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

let primeMover = function(n) {
  // your code here


  let arr = [1];
  for ( let i = 1; i &amp;lt;100; i++) {
    for ( let j = 2; j &amp;lt; 100; j++ ) {
      if (j % i !== 0 ) {
       arr.push(j);
      }
    }
  }
  return arr[n];
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-35&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isoddwithoutmodulo&#34;&gt;isOddWithoutModulo&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isOddWithoutModulo&amp;rdquo;. (&amp;ldquo;isOddWithoutModulo&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;isOddWithoutModulo&amp;rdquo; returns whether the passed in number is odd. (숫자가 주어졌을때, &amp;ldquo;isOddWithoutModulo&amp;rdquo; 함수는 주어진 숫자가 홀수인지를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-45&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 2. it is used by Math.floor 

function isOddWithoutModulo(num) { // floor 메소드로 참과 거짓을 출력할뿐만 아니라 정수로 만든다. 그것을 2로 나눠서 2로 다시 곱한값이 기존에 값과 일치하지 않는다면 홀수이므로 true 반환
  
  return Math.floor(num / 2) * 2 !== num;  

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;others-soultion&#34;&gt;Others_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isOddWithoutModulo(num) {
   // 예를 들어, num이 -17이라고 가정합니다. 
   num = Math.abs(num);
// num은 절대값이 되어 17이됩니다. 이를 통해 파라미터에 들어올 모든 음수를 커버할 수 있을 겁니다. 
   if( num === 0 )  // num은 현재 17로 0이 아니기 때문에 그 다음 else if로 넘어가게 됩니다. 
       return false;
   else if(num === 1) // num은 현재 17로 1이 아니기 때문에 그 다음 else로 넘어가게 됩니다. 
       return true;
   else { // 보통 홀수인지 아닌지를 판별하기 위해서 2로 나누었을 대 나머지값을 확인하는 방법을 씁니다. 
// 그 방법을 풀어보면 17 -2 -2 -2 -2 -2 -2...... 하여 0 혹은 1이 될 때까지 뻰다는 것을 의미합니다. 
       return isOddWithoutModulo(num-2); // 이 부분은 바로 위의 설명이 적용되는 부분입니다. 
// 자바스크립트는 재귀함수가 가능하여 함수 안에서 자기 자신을 호출할 수 있습니다.
// 이를테면 num이 17이었다면 위의 구문을 통해 다시  isOddWithoutModulo(17-2)를 호출하는 것입니다. 
// 위의 과정을 다시 반복하게 되면 isOddWithoutModulo(15) --&amp;gt; isOddWithoutModulo(13) --&amp;gt; isOddWithoutModulo(11).... 
// num이 0 혹은 1이 되어 if와 else if 구문에 걸려 return될 때까지 반복됩니다. 
   }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-36&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getstringlength&#34;&gt;getStringLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getStringLength&amp;rdquo;. (&amp;ldquo;getStringLength&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a string, &amp;ldquo;getStringLength&amp;rdquo; returns the length of the given string. (문자열이 주어졌을때, &amp;ldquo;getStringLength&amp;rdquo; 함수는 주어진 문자열의 길이를 반환합니다.)&lt;/p&gt;

&lt;p&gt;Do NOT use any native &amp;lsquo;length&amp;rsquo; methods. (- &amp;lsquo;length&amp;rsquo; 메소드를 사용하지 마세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-46&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getStringLength(string) {
  // your code here

  // 1. count 변수를 만들어 초기값을 지정한다. 
  // 2. while loop를 이용해 string[count] 값을 지정해 조건문을 만든다. 
  // 3. 참이면 count 에 1씩 증가시킨다. 그러면 조건문에 인덱스 번호가 넘어가면 조건문이 문자의 길이만큼 값이 count 에 저장된다. 

  let count = 0;

  while (string[count]) {
    count = count + 1;
  };
  return count;
};


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-37&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getindexof&#34;&gt;getIndexOf&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getIndexOf&amp;rdquo;. (&amp;ldquo;getIndexOf&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a character and a string, &amp;ldquo;getIndexOf&amp;rdquo; returns the first position of the given character in the given string. (문자와 문자열이 주어졌을때, &amp;ldquo;getIndexOf&amp;rdquo; 함수는 주어진 문자열에서 주어진 문자가 나타나는 첫번째 위치를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-47&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getIndexOf(char, str) {

      for (let i = 0; i &amp;lt; str.length;  i = i + 1 ) {
          if ( str[i] === char ) {  //  만약 str 에 있는 문자들중에 char 같다면 
            return i;  // 리턴 인덱스 번호 
          } 
        }
      return -1; //  아니면 -1  반환
    }



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-6&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getIndexOf(char, str) {
  // your code here
  let newStr = str.split(&amp;quot;&amp;quot;);
    if (newStr.every(el =&amp;gt;  el !== char )) {
      return -1;
    }
  let countArr = [];
  for (let i = 0; i &amp;lt; newStr.length; i ++ ) {
    if (newStr[i] === char) {
      countArr.push(i);
    }
  }
  return countArr[0];

}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-38&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;calculatebilltotal&#34;&gt;calculateBillTotal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;calculateBillTotal&amp;rdquo;. (&amp;ldquo;calculateBillTotal&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given the pre tax and pre tip amount of a meal, &amp;ldquo;calculateBillTotal&amp;rdquo; returns the total amount due after tax and tip. (팁과 세금을 제외한 식사값이 주어졌을때, &amp;ldquo;calculateBillTotal&amp;rdquo; 함수는 팁과 세금이 포함된 총 식사값을 반환합니다.)&lt;/p&gt;

&lt;p&gt;Assume that sales tax is 9.5% and tip is 15%. (- 세금은 9.5% 팁은 15% 로 계산하세요.)
Do NOT tip on the sales tax, only on the pre tip amount. (- 팁을 계산할때 세금을 포함하여 계산하지 마세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-48&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function calculateBillTotal(preTaxAndTipAmount) {
  // your code here

  // 1. salesTax 변수를 만들고 주어진 값의 0.095 곱한 값을 대입
  // 2. tip 변수를 만들고 주어진 값의 0.15 를 곱한 값을 대입
  // 3. 모든값을 더한후 리턴  
 

  let salesTax = preTaxAndTipAmount * 0.095;
  let tip = preTaxAndTipAmount * 0.15;

  return preTaxAndTipAmount + salesTax + tip;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-39&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertobjecttoarray3&#34;&gt;convertObjectToArray3&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;convertObjectToList&amp;rdquo; which converts an object literal into an array of arrays, like this: (객체를 입력으로 받고 해당 객체를 다음과 같이 2차원 배열로 변형 할 수 있는 함수 &amp;ldquo;convertObjectToList&amp;rdquo;를 작성하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-49&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function convertObjectToList(obj) {
  // your code here
  
  // 1. 마지막에 출력할 빈배열을 만든다. 
  // 2. for 문을 사용해서 객체안에 있는 key와 prop 값에 전근한다. 
  // 3. push 사용해 접근한 key값은 0번째 값에 넣고 prop 값은 1번째 값에 넣는다. 
  // 4. arr 리턴한다. 

  let arr = [];
  for ( let key in obj ) {
    arr.push([key,obj[key]]);
  }  
 return arr;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-40&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isodd&#34;&gt;isOdd&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called isOdd. (&amp;ldquo;isOdd&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an integer, isOdd returns whether the integer is odd or not. (숫자가 주어졌을때, &amp;ldquo;isOdd&amp;rdquo; 함수는 주어진 숫자가 홀수 인지 아닌지를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-50&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isOdd(num) {
  // your code here
  // 파라미터를 2로 나누었을때의 나머지를 판별별
  // 나머지가 1인경우, true를 리턴
  // 나머지가 0인경우, false를 리턴
  if (num % 2 === 1 ) {
    return true;
  } else {
    return false;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-refactoring-code&#34;&gt;My_Refactoring code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isOdd(num) {
  // your code here

  // 만약 num  % 2 의 나머지수가  0 이면 짝수 return false;
  // 그게 아니라면 true 리턴
  return num % 2 === 0 ? false : true;
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-41&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;sum&#34;&gt;sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Summation to n: Let&amp;rsquo;s implement the function sum that takes a single parameter n, and computes the sum of all integers up to n starting from 0, e.g.:&lt;/p&gt;

&lt;p&gt;(n까지의 총 합: n을 매개변수로 받아 0 부터 n 까지 모든 수의 총 합을 반환하는 함수를 작성하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-51&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function sum(n) {
  let result = 0;
  //반복문을 이용하여 0부터 n까지의 숫자를 더하여 출력
  for (let i = 0; i &amp;lt;= n; i++) {
    result = result + i;
  }
  return result;
  
  // your code here
}
sum(3);
sum(4);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-42&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;onlyevenelements&#34;&gt;onlyEvenElements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array of numbers, onlyEvenElements returns a new array of just the even numbers. (숫자로 이루어진 배열이 주어졌을때, &amp;ldquo;onlyEvenElements&amp;rdquo; 함수는 주어진 배열에 있는 짝수로만으로 이루어진 새로운 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-52&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function onlyEvenElements(arr) {
  //짝수값을 입력받을 빈배열을 선언한다.
  let result = [];
  //입력받은 배열안에 있는는 값을 판별하기위해 불러온다.
  for (let i = 0; i &amp;lt; arr.length; i++) {
    //값이 짝수인지를 if 문을 써서 판별한다. 
    if (arr[i] % 2 === 0) {
      //값이이 짝수인경우 빈배열에 집어넣는다.
      result.push(arr[i]);
    }
  }
  return result;
  // your code here
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-43&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeoddvalues&#34;&gt;removeOddValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function removeOddValues that takes an object as an argument and returns an object with all key/value pairs removed for which the value holds an odd number. (&amp;ldquo;removeOddValues&amp;rdquo; 함수를 작성하세요. 객체가 주어졌을때, &amp;ldquo;removeOddValues&amp;rdquo; 함수는 주어진 객체의 key/value 페어 중 value 가 홀수 숫자인 페어가 제거된 객체를 반환하세요.)&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need to use the &amp;ldquo;typeof&amp;rdquo; operator to first check that the values are numbers: (value가 숫자인지 확인하기 위하서는 &amp;ldquo;typeof&amp;rdquo; 연산자를 먼저 사용해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-53&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// first 

function removeOddValues(object) {
  // 1.홀수숫자인 페어가가 아닌 값들을 입력받을을 빈 객체를를 만든다.
  let object2 = {};
  // 2. value 값들을 판별하기 위해 키값을 반복시킨다.
  for (let k in object) {
  // 3. value 값이 숫자이고 짝수이면 빈객체에 대입한다. 
    if (typeof(object[k]) === &#39;number&#39; &amp;amp;&amp;amp; object[k] % 2 === 0) {
      object2[k] = object[k];
  //4. value 값이 문자형이면 객체에 대입한다. 
    } else if ( typeof(object[k]) === &amp;quot;string&amp;quot; ) {
      object2[k] = object[k];
    } 
  }
  return object2;
  // your code here
}



// Sceond 

function removeOddValues(input) {
	
// 1. 결과를 담을 객체를 만듭니다. 
	
  	let result = {};

// 2. input 으로 받은 object 안에 key 를 모두 반복합니다. 
  
  for (let key in input) {
	  let value = input[key];
	  let isNumber = typeof value === &#39;number&#39;;

	  if (isNumber ) {
	 
// key의 해당 하는 value가 짝수인지 확인합니다.
	 
    let isEven = value % 2 === 0;
    if (isEven) {
	 
// 만든 객체에 key, value를 추가합니다.
	 
    result[key] = value;
	    }
   }
// 숫자가 아니면
	
    else {
	
//만든 객체에 key, value 를 추가합니다.

  	result[key] = value;	
    }
  }
  return result;
}

removeOddValues({ a: 1, b: 2, c: 3, d: &#39;hello&#39; })




//third


function removeOddValues(object) {
  //1. value 값을 판별하기 위해 key 값을 반복한다.
  for (let k in object) {
  //2. value 값이 숫자이고 홀수이면 삭제한다. 
    if (typeof(object[k]) === &#39;number&#39; &amp;amp;&amp;amp; object[k] % 2 === 1) {
    delete object[k];
     }
  }
  return object;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-44&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;firstcharacter&#34;&gt;firstCharacter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;In this exercise, a string is passed to a method and a new string has to be returned with the first character of each word in the string (문자열이 주어졌을때, &amp;ldquo;firstCharacter&amp;rdquo; 함수는 문자열의 각 단어 첫글자들로 이루어진 문자열을 반환하여야 합니다.)&lt;/p&gt;

&lt;p&gt;Attention! In test case 5 userinput is one space input char as &amp;lsquo; &amp;lsquo;, please do not get confused with &amp;ldquo;, empty string (주의사항! 테스트 케이스 5 에서 주는 입력값은 띄어쓰기 한개(&amp;rsquo; &amp;lsquo;) 입니다. 빈 문자열(&amp;rdquo;) 과 혼동하지 마세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-54&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
unction firstCharacter (string) {
 // Your code here
 
 
 // for문 이용
 
 let output = [];
 let temp_arr = [];

 // 1. split으로 단어로 나눠서 배열 만들기
 
 temp_arr = string.split(&#39; &#39;);
 // 2. 각 인덱스의 첫번째 문자를 배열 output 에 담기
 for(let i=0;i&amp;lt;temp_arr.length;i++){
   output.push(temp_arr[i][0]);
 }
 
 // 4. 출력
 return output.join(&#39;&#39;);
 
 
 
 ////////////////////////////////////////////////////////////////////////
 
 // 2. Reduce 이용
 return string.split(&#39; &#39;).reduce(function(acc,cur){
   return acc+cur[0];
 
 },&#39;&#39;);
 
 // 3. Reduce이용 2
 return string.split(&#39; &#39;).reduce( (acc,cur)=&amp;gt;acc+cur[0] ,&#39;&#39;);
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-45&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;dashinsert&#34;&gt;dashInsert&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Have the function DashInsert insert dashes (&amp;lsquo;-&amp;rsquo;) between each two odd numbers in str. (문자열이 주어졌을때, &amp;lsquo;DashInsert&amp;rsquo; 함수는 문자열에 있는 두 홀수 사이에 대시(&amp;lsquo;-&amp;rsquo;)를 추가하여 반환합니다.)&lt;/p&gt;

&lt;p&gt;For example: if str is 454793 the output should be 4547-9-3. (예시: 주어진 문자열이 454793 이라면 결과값은 4547-9-3 입니다.) Don&amp;rsquo;t count zero as an odd number. (0 을 홀수로 간주하지 마세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1/for 문


function DashInsert(string) {
 


 let output = [];
 let tmp=string.split(&#39;&#39;);
 for(let i=0;i&amp;lt;tmp.length;i++){
   //홀수가 연속해서 나올때 =&amp;gt; i번째와 &#39;-&#39;을 넣는다.
   if(tmp[i]%2 &amp;amp;&amp;amp; tmp[i+1]%2){// 1,3
     output.push(tmp[i],&#39;-&#39;);//1,-,3
   }else{
     output.push(tmp[i]);
   }
 }
 return output.join(&#39;&#39;);
 }

///////////////////////////////////////////////////////////////////

// 1. reduce 

function DashInsert(string) {
 
 let output = &#39;&#39;;
 let tmp = string.split(&#39;&#39;);
 output = tmp.reduce(function(acc,cur){
   if((acc)%2===1 &amp;amp;&amp;amp; (cur)%2===1) return acc+&#39;-&#39;+cur;
   else return acc+cur;
 });
 return output;

}


////////////////////////////////////////////////////////////////////

// 2.splice

function DashInsert(string) {
  let arr = string.split(&#39;&#39;);
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if ( arr[i] % 2 === 1 &amp;amp;&amp;amp; arr[i + 1] % 2 === 1) {
      arr.splice(i +1,0,&#39;-&#39;);
    }
  }
  return arr.join(&#39;&#39;);
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-46&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;longestword&#34;&gt;longestWord&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;sing the JavaScript language, have the function LongestWord take the sen parameter being passed and return the largest word in the string. (문장이 주어졌을때, &amp;lsquo;LongestWord&amp;rsquo; 함수는 주어진 문장에서 가장 긴 단어를 반환합니다.)&lt;/p&gt;

&lt;p&gt;If there are two or more words that are the same length, return the first word from the string with that length. Assume sen will not be empty. (만약 가장 긴 단어가 두개 이상이라면, 첫번째로 등장하는 가장 긴 단어를 반환하세요. 문장은 빈 문자열이 아닙니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-55&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It&#39;s used by sort() 

function longestWord(string) {

 // 1. 주어진 문장을 배열로 만들기(split)
 let tmp = string.split(&#39; &#39;);
 //let sorted_tmp =[];
 // [&#39;I&#39;,&#39;love&#39;,&#39;codestates&#39;];
 // 2. sort() 사용 =&amp;gt; 성능 떨어짐
 let x = function(a,b){
   return b.length-a.length;
 };
 // 3. 0번째 요소 출력
 return tmp.sort(x)[0];
}

////////////////////////////////////////////////////////

// It&#39;s used by reudce(1)

function longestWord(string) {
 
 let tmp = string.split(&#39; &#39;);
 let max = tmp[0];
 for(let i =1;i&amp;lt;tmp.length;i++){
   if(tmp[i].length&amp;gt;max.length){
     max = tmp[i];
   }
 }
 return max;
}


/////////////////////////////////////////////////////////

// It&#39;s used by reudce(2) 화살표

function longestWord(string) {

return string.split(&#39; &#39;).reduce((acc,cur)=&amp;gt; acc.length&amp;lt;cur.length? cur:acc);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-47&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertarraytoobject1&#34;&gt;convertArrayToObject1&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function &amp;lsquo;transformFirstAndLast&amp;rsquo; that takes in an array, and returns an object with: (배열을 입력으로 받고 다음 조건에 만족하는 객체를 반환하는 함수 &amp;lsquo;transformFirstAndLast&amp;rsquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;the first element of the array as the object&amp;rsquo;s key, and (1. 배열의 첫번째 요소를 객체의 키로 가집니다.)
the last element of the array as that key&amp;rsquo;s value. (2. 배열의 마지막 요소를 해당 키의 값으로 가집니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-56&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function transformFirstAndLast(array) {
  // your code here

  // 1. 마지막으로 출력할 객체를 만든다.
  // 2. 배열의 첫번째 요소를 가져와 변수에 담는다.
  // 3. 배열의 마지막 요소를 가져와 변수에 담는다.
  // 4. 객체안에 첫번째 요소를 키로 설정한다.
  // 5. 객체안에 마지막 요소를 prop 설정한다. 

  let ret = {};
  ret[array[0]] = array[array.length -1 ];
  return ret;
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-48&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertobjecttoarray1&#34;&gt;convertObjectToArray1&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllKeys&amp;rdquo; which returns an array of all the input object&amp;rsquo;s keys. (객체를 입력으로 받고 해당 객체의 키들을 배열로 반환하는 &amp;ldquo;getAllKeys&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-57&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getAllKeys(obj) {
// your code here

// 1. 마지막에 출력할 새로운 배열을 만든다
// 2. for in key 값을 가져온다. 
// 3. 가져온 값을 새로 만든 배열에 넣는다.
let arr = [];
for ( key in obj ) {
  arr.push(key);
}
return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-49&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertarraytoobject2&#34;&gt;convertArrayToObject2&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function &amp;lsquo;fromListToObject&amp;rsquo; which takes in an array of arrays, and returns an object with each pair of elements in the array as a key-value pair. (2차원 배열을 입력으로 받고 배열안에 있는 배열의 요소 페어를 키-값 페어로 가지는 객체를 반환하는 함수 &amp;lsquo;fromListToObject&amp;rsquo; 함수를 작성하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-58&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function fromListToObject(array) {
  // your code here
  
  //  1. output 할 빈객체를 생성한다.  
  //  2. for 문으로 배열 안에 있는 배열을 조사한다.
  //  3. 배열안에 있는 배열의 0번째 를 키값 1번째를 prop 에 넣는다.
 
  
  let obj = {};

  for ( let i = 0; i &amp;lt; array.length; i = i + 1 ) {
    obj[array[i][0]] = array[i][1];
    }
    return obj
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;questoin&#34;&gt;Questoin&lt;/h3&gt;

&lt;h2 id=&#34;convertobjecttoarray2&#34;&gt;convertObjectToArray2&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;listAllValues&amp;rdquo; which returns an array of all the input object&amp;rsquo;s values. (객체를 입력으로 받고 해당 객체의 값들을 배열로 반환하는 &amp;ldquo;listAllValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-59&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function listAllValues(obj) {
  // your code here
  
  // 1. output 할 빈 배열을 생셩
  // 2. for in prop 값을 조사
  // 3. prop 값을 빈배열에 넣는다. 
  // 4. output 출력한다. 
  
  let arr = [];
  for ( prop in obj ) {
    arr.push(obj[prop]);
  } 
  return arr;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-50&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertarraytoobject3&#34;&gt;convertArrayToObject3&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;transformEmployeeData&amp;rdquo; that transforms some employee data from one format to another. (사원들의 정보를 다른 형태로 변형 할 수 있는 함수 &amp;ldquo;transformEmployeeData&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;The argument will look something like this: (사원들의 정보는 아래와 같은 배열로 주어질 수 있습니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-60&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function transformEmployeeData(array) {

  // 1. 맨 위 배열을 루프 데이터 가져온다.
  // 2. 가지고온 배열을 또 루프 를 돌려서 가져온다.
  // 3. 가지고온 배열을 0번째는 obj key 1번째는 value
  // 4. 만든 obj 를 배열에 푸시 
  
  
  let arr = [];
  
  for ( let i = 0; i &amp;lt; array.length; i = i + 1 ) {
    let data = {};
    for ( let n = 0; n &amp;lt; array[i].length; n = n + 1 ) {
      data[array[i][n][0]] = array[i][n][1];
    }
    arr.push(data);
  }
  return arr;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-7&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;




function transformEmployeeData(array) {
 
 // your code here
 // [key] start: firstName - last: role
 // return [{}] index0 key; index1 value;
  
 // 배열 안에 객체가 들어가 있는 것을 반환해야하니까
 // 빈배열 선언하고 빈 객체 선언 해서 빈 객체에 값 넣고
 //그 객체를 빈 배열에 넣어주고
 // 최종적으로 return 그 배열 해 주면 됨

  let result = [];

  for (let i of array){ // 여기서 i 는 [[&#39;firstName&#39;, &#39;Joe&#39;], [&#39;lastName&#39;, &#39;Blow&#39;], [&#39;age&#39;, 42], [&#39;role&#39;, &#39;clerk&#39;]]
    let obj = {};
   for (let j of i){ // 여기서 j는 [&#39;firstName&#39;, &#39;Joe&#39;]
     obj[j[0]] = j[1]; // j의 0번 elemente &#39;firstName&#39; , 1번 element &#39;Joe&#39;
    // obj[array[j][0]] = array[j][1];
   }
   result.push(obj);
  }

return result;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qutestion&#34;&gt;Qutestion&lt;/h3&gt;

&lt;h2 id=&#34;greetcustomers&#34;&gt;greetCustomers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;greetCustomer&amp;rdquo;. (&amp;ldquo;greetCustomer&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a name, &amp;ldquo;greetCustomer&amp;rdquo; returns a greeting based on how many times that customer has visited the restaurant. Please refer to the customerData object. (고객들의 방문 횟수를 가지고 있는 객체와 이름이 주어졌을때, &amp;ldquo;greetCustomer&amp;rdquo; 함수는 손님이 몇번 방문했는지에 따라 다른 인삿말을 반환합니다. customerData 객체를 참고해 주세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-61&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function greetCustomer(customerData, firstName) {
  let greeting = &#39;&#39;;
  // your code here

  // 1 . 객체의 속성의 객체의 속성값 접근한다.
  // 2.  객체의 속성의 객체의 속성값이 undefinded 이라면 1 greeting 대입
  // 3.  객체의 속성의 객체의 속성값이 1 이라면 2  greeting 대입
  // 4.  객체의 속성의 객체의 속성값이 1 보다 크다면 3 greeting 대입

    if (!customerData[firstName]) {
        greeting = `Welcome! Is this your first time?`;
    } else if (customerData[firstName].visits === 1  ) {;
        greeting = `Welcome back, ${firstName}! We&#39;re glad you liked us the first time!`
    } else if ( customerData[firstName].visits &amp;gt; 1 ) {
        greeting =  `Welcome back, ${firstName}! So glad to see you again!`;
    }
    return greeting;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-51&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertdoublespacetosingle&#34;&gt;convertDoubleSpaceToSingle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;convertDoubleSpaceToSingle&amp;rdquo;. (&amp;ldquo;convertDoubleSpaceToSingle&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a string, &amp;ldquo;convertDoubleSpaceToSingle&amp;rdquo; returns the passed in string, with all the double spaces converted to single spaces. (문자열이 주어졌을때, &amp;ldquo;convertDoubleSpaceToSingle&amp;rdquo; 함수는 주어진 문자열에 있는 띄어쓰기 두개(double spaces)를 띄어쓰기 한개(single space)로 변환한 뒤 해당 문자열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-62&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertDoubleSpaceToSingle(str) {
  
  // 1. 문자열을 split() 를 사용해서 str 변수에 배열로 저장한다.
  // 2. reduce 를 사용해서 배열에 담긴 문자의 single space로 만들어 출력한다. 

  let strArr = str.split(&amp;quot;  &amp;quot;);
  let output = strArr.join(&amp;quot; &amp;quot;);
  return output;
}


// Refactoing

function convertDoubleSpaceToSingle(str) {
  return str.split(&amp;quot;  &amp;quot;).join(&amp;quot; &amp;quot;);

}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-8&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertDoubleSpaceToSingle(str) {
  return str.replace( /  +/g,&#39; &#39;);
}
잘되긴 하는데.... ㅡ,.ㅡ

/ +/g 부분이 이해가 가지 않습니다...............
/(빈칸 두개)+/g 를 찾아서 &#39; &#39;로 바꿔준다는 것 같습니다.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion-1-9&#34;&gt;other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertDoubleSpaceToSingle(str) {

var array = str.split(&#39; &#39;); // 문자열 배열 만들기  [ &#39;string&#39;, &#39;&#39;, &#39;with&#39;, &#39;&#39;, &#39;double&#39;, &#39;&#39;, &#39;spaces&#39; ]

for (i = 0; i&amp;lt;=array.length; i++) { // for 문을 이용해 배열 접근 
  if (array[i] === &#39;&#39;) { //만약 각각의 요소가 &#39;&#39; 와 같다면
    array.splice(i,1); // splice 접근해서 삭제 
  }
}

return array.join(&#39; &#39;); // 각각의 문자열을 join &#39; &#39; 를 나눠서 출력 

}


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__Algorithm_3</title>
      <link>/tutorial/javascript_algorithm/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/javascript_algorithm/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Dictionary_files/javascriptt-light_870x220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;qeustion&#34;&gt;Qeustion&lt;/h3&gt;

&lt;h2 id=&#34;scrabble-word-calculator&#34;&gt;scrabble word calculator&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;implement the word_calc method to return the correct Scrabble word score. The scores are already set up for you to use and are managed within Dictionaries:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
one_point_values = [&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;t&amp;quot;];
two_point_values = [&amp;quot;d&amp;quot;, &amp;quot;g&amp;quot;];
three_point_values = [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;p&amp;quot;];
four_point_values = [&amp;quot;f&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;v&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;y&amp;quot;];
five_point_values = [&amp;quot;k&amp;quot;];
eight_point_values = [&amp;quot;j&amp;quot;,&amp;quot;x&amp;quot;];
ten_point_values = [&amp;quot;z&amp;quot;,&amp;quot;q&amp;quot;];


word_calc(&amp;quot;zoo&amp;quot;) // 12
word_calc(&amp;quot;bus&amp;quot;) // 5

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function word_calc(word) {



	var inputArr = word.split(&amp;quot;&amp;quot;);
	var countArr = [];
	var dataArr = [one_point_values,two_point_values,three_point_values,four_point_values,five_point_values,eight_point_values,ten_point_values];
	var total = 0;
	function sum(array) {
		var countArr = [];
		var sum = 0;
		if(array[0]=== one_point_values[0]) {
			 for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 1;
		   }
			countArr = [];
		} 
		else if (array[0]=== two_point_values[0]){
			 for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 2;
	  	 }
			countArr = [];	
		}
		else if (array[0]=== three_point_values[0]) {
			 for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 3;
	  	 }
			countArr = [];
		}
		else if (array[0]=== four_point_values[0]) {
			 for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 4;
	  	 }
      countArr = [];
		}
		else if (array[0]=== five_point_values[0]) {
			 for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 5;
       }
			countArr = [];
		}
		else if (array[0]=== five_point_values[0]) {
			 for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 8;
       }
			countArr = [];
		} 
		else if (array[0]=== ten_point_values[0]) {
			for (let i = 0; i &amp;lt; inputArr.length; i ++ ) {	
			 	if (array.includes(inputArr[i])) {
		  		countArr.push(inputArr[i])
		  	} 
		  	sum = countArr.length * 10;
		  }
			countArr = [];
    }
		total = total + sum;
    }
    
    dataArr.forEach((ele)=&amp;gt;{
    sum(ele);
    })


 return total;


}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion&#34;&gt;Other_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
const char_points = {
  &amp;quot;a&amp;quot;: 1,
  &amp;quot;e&amp;quot;: 1,
  &amp;quot;i&amp;quot;: 1,
  &amp;quot;o&amp;quot;: 1,
  &amp;quot;u&amp;quot;: 1,
  &amp;quot;l&amp;quot;: 1,
  &amp;quot;n&amp;quot;: 1,
  &amp;quot;r&amp;quot;: 1,
  &amp;quot;s&amp;quot;: 1,
  &amp;quot;t&amp;quot;: 1,
  &amp;quot;d&amp;quot;: 2,
  &amp;quot;g&amp;quot;: 2,
  &amp;quot;b&amp;quot;: 3,
  &amp;quot;c&amp;quot;: 3,
  &amp;quot;m&amp;quot;: 3,
  &amp;quot;p&amp;quot;: 3,
  &amp;quot;f&amp;quot;: 4,
  &amp;quot;h&amp;quot;: 4,
  &amp;quot;v&amp;quot;: 4,
  &amp;quot;w&amp;quot;: 4,
  &amp;quot;y&amp;quot;: 4,
  &amp;quot;k&amp;quot;: 5,
  &amp;quot;j&amp;quot;: 8,
  &amp;quot;x&amp;quot;: 8,
  &amp;quot;z&amp;quot;: 10,
  &amp;quot;q&amp;quot;: 10
};


const reducer = (accumulator, currentValue) =&amp;gt; accumulator + currentValue;


function word_calc(w) {
  // convert your string array to relevant numbers 
  const splitted_array = w.split(&amp;quot;&amp;quot;).map(function(item) {
    return char_points[item]
  });

  // You can use simple loop to sum up or reduce to reduce and sum the array
  const total = splitted_array.reduce(reducer);
  console.log(total)
}


word_calc(&amp;quot;zoo&amp;quot;) // 12
word_calc(&amp;quot;bus&amp;quot;) // 5


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function word_calc(w) {
  let total=0;
  // convert your string array to relevant numbers and add it to the total
  w.split(&amp;quot;&amp;quot;).map(function(item) {
    total += char_points[item];
  });
  console.log(total)
}


word_calc(&amp;quot;zoo&amp;quot;) // 12
word_calc(&amp;quot;zoozoo&amp;quot;) // 24
word_calc(&amp;quot;bus&amp;quot;) // 5


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;4칙연산-함수-만들기&#34;&gt;4칙연산 함수 만들기&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Create a basic calulator with the following functions add,subtract,multiply and divide, implement the correct code to return correct mathematical value the functions should take two arguments&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 파이썬 문제이지만 자바스크립트로 풀어보았습니다. 

// 이렇게 출력하게 만드는 문제입니다. 
Answer.add(2,2) // 4
Answer.subtract(2,2) // 0
Answer.multiply(2,2)// 4
Answer.divide(2,2)// 1.0

// 저는

answer.call(add,2,2) // 4
answer.call(subtract,2,2) // 0
answer.call(multiply,2,2) // 4
answer.call(divide,2,2) // 1.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soultion-1&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var add = {
	add: 0
}
var subtract = {
	
}
var multiply = {
	multiply: 0
}
var divide = {
	divide: 0
}





var answer = function (first,second) {
  if(this === add) {
	return this.add = first + second; 
  } else if ( this === subtract) {
	return this.subtract = first - second;
  } else if (this === multiply) {
  	return this.multiply = frist * second;
  } else if ( this === divide ) {
	return this.divide = first / second;
  }
}


/*

better code

var answer = {
  add:function(fir, sec){
    return fir+sec;
  },
  subtract:function(fir, sec){
    return fir-sec;
  },
  multiply:function(fir, sec) {
    return fir*sec;
  },
  divide:function(fir, sec) {
    return fir/sec;
  }
}

*/


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nonuniqueelements-data&#34;&gt;nonUniqueElements(data)&lt;/h2&gt;

&lt;h3 id=&#34;question-1&#34;&gt;Question&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;You are given a non-empty list of integers (X). For this task, you should return a list consisting of only the non-unique elements in this list. To do so you will need to remove all unique elements (elements which are contained in a given list only once). When solving this task, do not change the order of the list. Example: [1, 2, 3, 1, 3] 1 and 3 non-unique elements and result will be [1, 3, 1, 3].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Input: A list of integers.

Output: An iterable of integ

var assert = require(&#39;assert&#39;);

if (!global.is_checking) {
    assert.deepEqual(nonUniqueElements([1, 2, 3, 1, 3]), [1, 3, 1, 3], &amp;quot;1st example&amp;quot;);
    assert.deepEqual(nonUniqueElements([1, 2, 3, 4, 5]), [], &amp;quot;2nd example&amp;quot;);
    assert.deepEqual(nonUniqueElements([5, 5, 5, 5, 5]), [5, 5, 5, 5, 5], &amp;quot;3rd example&amp;quot;);
    assert.deepEqual(nonUniqueElements([10, 9, 10, 10, 9, 8]), [10, 9, 10, 10, 9], &amp;quot;4th example&amp;quot;);
    console.log(&amp;quot;Coding complete? Click &#39;Check&#39; to review your tests and earn cool rewards!&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-soulion&#34;&gt;My_Soulion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function nonUniqueElements(data) {
    let overLap = data.filter((ele,index)=&amp;gt;{
        return data.indexOf(ele) !== index
        })
    overLap = Array.from(new Set(overLap));
    
    return data.filter(function(val) {
        return overLap.indexOf(val) !== -1;
    })
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function checkio(data) {
    return data.filter(function(a){
        return data.indexOf(a) !== data.lastIndexOf(a)    
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;check-point-1-scope&#34;&gt;Check_Point_1 Scope&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;8번에 result인 x 가 10인 이유는 이해가 되는데&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;10번에 함수밖에있는 result 인  x 가 어떻게 outer(),inner()함수에 변수 x 를 가져왔는지&lt;/strong&gt; 이해가 잘안되어 질문을 드립니다..  제가 이해하기로는 단순히 var 이 함수안에서 다시 선언되지 않아서 인가요?&lt;/p&gt;

&lt;p&gt;부탁드립니다.&lt;/p&gt;

&lt;h3 id=&#34;8번문제&#34;&gt;8번문제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var x = 10;

function outer () {
  var x = 20;
  function inner () {
    x = x + 10;
    return x;
  }
  inner();
}

outer();

var result = x;  // 10


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10번-문제&#34;&gt;10번 문제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var x = 10;

function outer () {
  x = 20;
  function inner () {
    x = x + 20;
  }
  inner();
}

outer();

var result = x; // 40


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;해답&#34;&gt;해답&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;8 번 문제 함수안에 변수가 let var const 선언되면 함수범위(스코프 범위)를 벗어나서 변수를 쓸수가 없다&lt;/p&gt;

&lt;p&gt;10번 문제  함수 안에 변수가 선언되지 않고 전역에 선언되었기 때문에 함수안에 x는 전역에 있는 것을 할당 하게 되어 가져온후 그것을 어니서나 쓸수 있는 변수가 되어버린것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;check-point-2-closure&#34;&gt;check_point 2 _Closure&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;클로저를 정의한다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;함수안에 또다른 함수를 실행 외부함수가 실행 &lt;code&gt;종료된 뒤에도&lt;/code&gt; 여전히 내부함수가 계속 외부함수였던 스코프에 접근할수 있다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;qeustion-1&#34;&gt;Qeustion&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var add = function(x) {
   function sum (y) {
      return x + y;
  }
  return sum;
}

var foo = add(1) // 이렇게 하면 x는 1로 저장된다. 

foo(2) // 1 + 2 되어서 3 

var total1 = foo(10) // 1 + 10 = 11
var total2 = foo(11) // 1 + 11 = 12

var total3 = foo(12) // 1 + 12 = 13
var total4 = foo(13) // 1 + 13 = 14

var total5 = foo(14) // 1 + 14 = 15
var total6 = foo(15) // 1 + 15 = 16

var total7 = foo(16) // 1 + 16 = 17
var total8 = foo(17) // 1 + 17 = 18

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;check-point-4&#34;&gt;check_point-4&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1번 - What message will eventually be alerted? After how long?

&lt;ul&gt;
&lt;li&gt;setTimeout(function(){jj.sayHi()},1000)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2번 - What message will eventually be alerted? After how long?

&lt;ul&gt;
&lt;li&gt;setTimeout(jj.sayHi,1000)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3번 - What message will eventually be alerted? After how long?

&lt;ul&gt;
&lt;li&gt;setTimeout(jj.sayHi.bind(jj), 1000);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;5번 - What message will eventually be alerted? After how long?

&lt;ul&gt;
&lt;li&gt;setTimeout(jj.sayHi.bind(tim), 1000);
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var esther = &amp;quot;eshter&amp;quot;;
var jj = {
  name: &amp;quot;jj&amp;quot;,
  sayHi: function() {
    alert(this.esther + &amp;quot; says hi&amp;quot;);
  }
}; this 값이 바껴버린다. 

var tim = {
  name : &amp;quot;tim&amp;quot;
}

//1.After how long?

setTimeout(function(){jj.sayHi()},1000) //  jj say hi 
// this 값이 jj되서 jj.name 원하는 바되로 jj say hi 가 나온다. 


//2. After how long?
// 하지만 
setTimeout(jj.sayHi,1000) // esther says hi

// 이렇게 콜백 함수를 넣는다면 this 값이 window 가 되어서
// jj.sayHi를 불렀지만 esther. says hi 가 나온다. 

//3. Ater how long?

setTimeout(jj.sayHi.bind(jj), 1000); // jj say hi
 
// 이렇게 하면 2번에서 나오는 esther  say hi 를 방지할수 있다 
// 한마디로 this값을 원래 의도대로 jj 를 가르키게 하여 1초 후에 jj.name 되어 jj say hi  가 된다. 

//4. Ater how long?

setTimeout(jj.sayHi.bind(tim), 1000); // tim say hi

 // this 는 tim  bind(tim) 으로 인해 this 값을 정해줬다. 
  // 출력 

var sayHiTim = jj.sayHi.bind(tim) // 이렇게 묶어서 사용할수 있다. 

sayHiTim // tim.name + &amp;quot;says hi &amp;quot; 묶인채로 저장된다.  

// ƒ () {
//    alert(this.name + &amp;quot; says hi&amp;quot;);
//  }


sayHiTim() //  tim say hi
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;5번 - After the following code runs, what will be the value of result?
6번 - After the following code runs and all setTimeout callbacks run, what will be the value of result?&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
//5 번

function foo () {

  var data = 10;

  bar(function (players) {
    data = players;
  });

  return data;
}

//1.
///////////////////////////////////  
// bar 함수는 callback 함수를 받아서 인자값을 20으로 한다. 
function bar (callback) {
  callback(20);
}

var result = foo(); // 20

//2

setTimout() // 안에 넣고 callback(20) 을 실행한다. 

///////////////////////////////////
///////////////////////////////////


function foo () {

  var data = 10;

  bar(function (players) {
    data = players;
  });

  return data;
}

function bar (callback) {
  setTimeout(function () {
    callback(20);
  }, 500);
}

var result = foo(); //  값이 변하지 않아서 10 이다 



&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;result 값이 42 가 되게 exercise 함수를 작성하라&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function exercise (???) {
  ???
}

var a = exercise(10, function (x) {
  return x + 2;
});

var b = exercise(15, function (x) {
  return x * 2;
});

var result = a + b;



function exercise (x,f) {
  return f(x);
}


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__DS &amp; OOP</title>
      <link>/tutorial/2019-12-21-spint2/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2019-12-21-spint2/</guid>
      <description>

&lt;h2 id=&#34;opp-란&#34;&gt;OPP 란?&lt;/h2&gt;

&lt;h4 id=&#34;객체-지향-프로그래밍이란-oop-object-oriented-programming&#34;&gt;객체 지향 프로그래밍이란(OOP: Object Oriented Programming)?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;객체들의 &lt;code&gt;모임&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;객체-지향-프로그래밍-장점&#34;&gt;객체 지향 프로그래밍 장점&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;코드의 재사용성 제공
*객체의 특성이나 속성을 한 번 정의해 놓으면 해당 객체에 소속되어 있는 모든 객체들의 속성으로 사용할 수 있으므로 재사용성이 높아진다.&lt;/li&gt;
&lt;li&gt;유지보수의 용이 : 한 번만 정의한 것을 수정하면 모든 객체의 속성을 수정할 수 있다.&lt;/li&gt;
&lt;li&gt;신뢰성 증대 : 다양하게 사용된 속성들에 경험이 쌓이면서 신뢰가 축적되기 쉽고 그것을 다시 사용한다면 에러(버그)의 가능성이 줄어든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;oop의-기본-구성-요소&#34;&gt;OOP의 기본 구성 요소&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;클래스(Class)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;객체(Object)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메서드(Method)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;opp-기본-컨셉-4-가지-있다&#34;&gt;OPP 기본 컨셉 4 가지 있다.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1. 캡슐화(Encapsulation)&lt;/li&gt;
&lt;li&gt;2. 상속(Inheritance)&lt;/li&gt;
&lt;li&gt;3. 추상화(Abstraction)&lt;/li&gt;
&lt;li&gt;4. 여러가지 형태 (Polymorphism)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-캡슐화란&#34;&gt;1.캡슐화란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;속성들(properties)들을  object안에 넣어서 활용한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예시&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;employee라는 객체 안에 객체들을 넣어서 사용한다. 이것이 캡슐화이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let baseSalary = 3001;
let overTime = 10;
let rate = 20;

function getwage(baseSalary,overTime,rate) {
return baseSalary + (overTime * rate);
}

getwage() // NaN 
getwage(baseSalary,overTime,rate) // 3200


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;캡슐화 한 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

let employee = {
	baseSalary : 3000,
	overTime : 10,
	rate: 20,
	getWage: function() {
	return this.baseSalary + (this.overTime * this.rate);
	}
 }
 
 employee.getWage();// 3200


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-상속&#34;&gt;2.상속?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;상속은 쉽게 말하면 상위 클래스의 모든 것, 행동을 하위 클래스가 가지고 있으며 그대로 사용할 수도 있고 원하면 Customizing을 할 수 있다는 것이다.&lt;/li&gt;
&lt;li&gt;부모 클래스가 가지고 있는 속성(프로퍼티, 메소드) 등을 그대로 자식 클래스가 물려 받아 재사용이 가능하다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-추상화란&#34;&gt;3.추상화란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;속에는 복잡하게 되어있지만 사용자가 쓰기에는 굉장히 간단하다.&lt;/li&gt;
&lt;li&gt;인터페이스가 간단해진다.&lt;/li&gt;
&lt;li&gt;복잡한걸 알지않아도 사용자 입장에서는 사용 가능
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-여러가지-형태-다양성&#34;&gt;4.여러가지 형태 다양성 ?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;다형성은 상속을 받은 기능을 변경하거나 확장하는 것&lt;/li&gt;
&lt;li&gt;코드의 재사용성이 높아져 코드의 길이가 감소하고 유지보수가 용이해짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;prototype-무엇이냐&#34;&gt;prototype 무엇이냐?&lt;/h2&gt;

&lt;h3 id=&#34;자바스크립트는-프로토타입-기반-객체지향-프로그래밍-언어이다&#34;&gt;자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다.&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ES6 문법이 도입되기 전에는 JavaScript에는 클래스(Class)가 없었음 그래서 객체 생성을 위해서 prototype을 사용했다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;객체를 생성하면, 프로토타입이 결정되고, 우리는 그 프로토타입을 변경할 수 있습니다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;첫번째-알아야-할것&#34;&gt;첫번째 알아야 할것&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;함수를 만들어 변수에 담을때 new 라는 것을 같이 담으면 객체가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function Person() {}

let x = new Person(); //  x 라는 변수는 객체가 된다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;두번째-알아야할-것&#34;&gt;두번째 알아야할 것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;객체(object)는 함수(function)로부터 시작된다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function Book() { }                // 함수 &amp;lt;&amp;lt;생성자 함수
var jsBook = new Book();           // 객체 생성


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;두가지 방식을 객체를 생성할수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var jsBook = new Book(); // 첫번째 방식 (생성자 함수) // 객체 

var jsBook = {}          // 두번째 방식(생성자 선언 없이 ) // 객체 


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;세번째-알아야-할것&#34;&gt;세번째 알아야 할것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;함수 생성시 발생하는 것을 알아야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.함수를 정의하면 함수가 생성되며 &lt;code&gt;Prototype object&lt;/code&gt;가 같이 생성 됩니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;생성된 Prototype object는 함수의 prototype 속성을 통해 접근할 수 있습니다.
(Prototype object같은 경우 &lt;code&gt;함수 생성시&lt;/code&gt;(var jsBook = new Book())에만 됩니다. 일반 객체 생성시에는 생성되지 않습니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;2.함수의 생성과 함께 생성된 Prototype object는 constructor와 &lt;strong&gt;proto&lt;/strong&gt;를 갖고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;constructor는 &lt;code&gt;생성된 함수&lt;/code&gt;를 가리키며(여기서는 function Book을 가리킵니다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;는 Prototype Link로서 객체가 생성될 때 사용된 생성자(함수)의 &lt;code&gt;Prototype object&lt;/code&gt;를 가리킵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;네번째-알아야-하는것&#34;&gt;네번째 알아야 하는것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;객체(object) 생성시 발생하는 일&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;생성하는 순간 jsBook 이라는 객체는 &lt;strong&gt;proto&lt;/strong&gt; 라는 &lt;code&gt;_proto__&lt;/code&gt;라는 프로퍼티를 갖고있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function Book() { }

Book.prototype.name = &amp;quot;john&amp;quot; 

var jsBook = new Book() // jsBook 은 객체이다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;prototype property(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 &lt;strong&gt;proto&lt;/strong&gt;는 객체라면 모두 갖고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-11-26-js-post_files/Screen Shot 2019-12-16 at 2.39.56 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;prototype property&lt;/code&gt;(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 &lt;code&gt;__proto__&lt;/code&gt;는 객체라면 모두 갖고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;예제&#34;&gt;예제)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1.일반적인 함수 패턴
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function Name(_name){
    var oName = {
        name : _name,
        getName : function(){
            return this.name;
        }
    }

    return oName;
}

Name(&#39;john&#39;); // Object{name: &#39;siwa&#39;, getName:function()} 리턴
var x = Name(&#39;john&#39;);
x.getName(); // &#39;john&#39; 리턴


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.객체 생성자 함수의 활용 - &lt;code&gt;모듈화&lt;/code&gt;,&lt;code&gt;프로토타입&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;new Key word 를 사용한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이는 객체지향적인 언어를 표방하는 기능, 클래스를 만드는 것과 비슷하다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(&lt;code&gt;new&lt;/code&gt;라는 키워드는 자바에서 클래스를 호출해서 인스턴스를 만드는 것과 비슷하다)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
 function Name(_name){
		console.log(&#39;this is&#39;,this);
		this.name = _name;
		this. getName = function(){
        return this.name;
    }
}

// 함수 를 그냥 호출했을때 와 new 키워드와 같이 호출했을때의 차이점 을 할수 있다. 

// 1. 함수를 그냥 호출했을때
Name(&#39;john&#39;); // this is window, undefined 리턴

// 2. new 키워드와 함께 함수를 호출했을 때
new Name(&#39;john&#39;); // this is Name{}, Name{name:&#39;monkey&#39;, getName()} 리턴



var x = new Name(&#39;john&#39;);

x.getName(); // &#39;john&#39;




&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.객체 생성자 함수의 활용 - &lt;code&gt;모듈화&lt;/code&gt; 와  &lt;code&gt;프로토타입&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*기능별로 모듈화 시킨 독립적인 클래스 단위로 그루핑할때 생성자 함수를 활용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;예를 들어 구글지도 UI를 만들 때, 화면에 보이는 기능 단위 즉 의미적으로 다른 기능이라면 (ex. 사진, 공유, 검색, 지도화면, 설정) 각각의 기능을 별도 모듈(클래스 단위)로 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 모듈화 수도코드 예시
// 지도를 표현하는 영역 클래스

function Map(name){
    this.name = &amp;quot;john&amp;quot;
    }
    
// 지도를 검색하는 영역 클래스
function SearchMenu(){}

// 사진을 슬라이드 하는 영역 클래스
function ViewCurrentPhotos(){}


var oMap = new Map(&amp;quot;john&amp;quot;);

 // 여기서 setDraw 를 설정해준다.
Map.prototype.setDraw = function (){
    console.log(name + &amp;quot;그림을 그리네 ?&amp;quot;);
}

oMap.setDraw() // john 그림을 그리네?


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3.객체 생성자 함수의 활용 - &lt;code&gt;모듈화&lt;/code&gt; 와  &lt;code&gt;프로토타입&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function Car(band,name,color) {
    // 인스턴스가 만들어 질때  실행될 코드들... 
}

// new 키워드를 통해 클라스의 인스턴스를 만들어낼 수 있습니다. 



// 1. 속성  : band,name,color , currentFuel,maxSpeed
// 2. 메소드  : refuel() ,setSpeed(), drive()



// ex


// 1. 클라스 함수 와 인스턴스 생성 

function Car(brand,name,color) { // Car() 는 클라스
	
	this.what_brand = brand; // 여기서 this 는 인자값이 드러갈 변수이름 (avante)
	this.what_name = name;	
	this.what_color = color;
}

// 2. 클라스 함수를 변수에 담고 파라미터 들어갈 값들 넣는다. 

let avante = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;); // 변수를 만든다 (인스턴스값으로 들어갈 )

// 3. 추가로 인스턴스를 생성 

Car.prototype.what_drive = function () { // Car() 인스턴스 생성 그리고 function 는 인스턴스 값  
    console.log(this.name + &amp;quot;가 운전을 합니다. &amp;quot;);
}


avante.what_name // 인스턴스 값 출력
// &amp;quot;avante&amp;quot;
avante.what_brand
// &amp;quot;GM&amp;quot;
avante.what_color
// &amp;quot;black&amp;quot;

avante.what_drive()  // 새로 생성한 what_drive 출력 
// jj 가 운전을 합니다. 

`tip`

let arr = [1,2,3,4,5]     // 배열 만들기 
let arr = new Array(1,2,3,4,5) // 배열 만들기  // Array클라스 안에 (인자값들) 




// ES6  에서는 클라스라는 키워드를 이용해서 정의 할수 있다. 


class car {
	constructor(brand,name,color) {
	
	// 인스턴스가 만들어질 때 실행되는 코드
		}
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;instantiation-patterns&#34;&gt;Instantiation Patterns&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;자바스크립트에 Class가 나오기 전에 사용하던 4가지 class 선언 방식 이것이 바로 &lt;code&gt;Instantiation Patterns&lt;/code&gt; 방식이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;함수를 이용한 객체 생성 방식을 이용한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Object 를 생성하는 4가지 방법&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. Functional&lt;/li&gt;
&lt;li&gt;2. Functional Shared&lt;/li&gt;
&lt;li&gt;3. Prototypal&lt;/li&gt;
&lt;li&gt;4. Pseudoclassical&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-functional&#34;&gt;1. Functional&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let Car = function() {
  let printingInstance = {};
  printingInstance.position = 0;
  printingInstance.move = function() {
    this.position ++;
  }
  return printingInstance;
}

let car1 = Car();

car1 {position: 0, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 1, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 2, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 3, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 4, move: ƒ} 


// position 초기값을 정해줄 수도 있다


let CarType2 = function(position) {
  let printingInstance = {};
  printingInstance.position = position;
  printingInstance.move = function() {
    console.log(this); 
    this.position ++;
  }
 return printingInstance;
}
 
var car2 = CarType2(2);
car2.move();
car2 // { position: 2, move: ƒ }
car2.move(); 
car2 // // { position: 3, move: ƒ }



&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-functional-shared&#34;&gt;2. Functional Shared&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Functional Shared라는 방식을 사용한다면, someMethods라는 객체에 있는 메소드들의 메모리 주소만을 참조하기 때문에 메모리 효율이 좋아진다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 3. // someInstance와 someMethods를 합치는 extend 함수를 만들어 Car 함수 내부에 넣는다. 

let extend = function(to, from) { 
  for(let key in from) {
    to[key] = from[key];
  }
}


// 2.메소드를 담아줄 객체를 생성.

let someMethods = {}; 
someMethods.move = function() {  // 모든 메소드는 someMethods에 담긴다. 
  this.position ++;
}


//  1. 먼저 Car 함수를 선언해 줍니다. 

let Car = function(position) { 
  let printingInstance = {
    position : position,
  }
   
  extend(printingInstance, someMethods); // Car함수 내부에서 합쳐준다 
  return printingInstance;
}


var car1 = Car(5); // 공장처럼 찍어낸다.
var car2 = Car(10); // 공장처럼 찍어낸다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Prototypal&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;왜 이방식을 쓰냐? 귀찬게? 이전의 Functional 방식은 인스턴스를 생성할 때마다 모든 메소드를 someInstance에게 할당하므로, 각각의 인스턴스들이 메소드의 수 만큼의 메모리를 더 차지하기 때문입니다.&lt;/p&gt;

&lt;p&gt;However, Functional Shared라는 방식을 사용한다면, someMethods라는 객체에 있는 메소드들의 메모리 주소만을 참조하기 때문에 메모리 효율이 좋아진다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1. 먼저 Functional Shared 비슷하게 메소드를 담아둘 객체 생성 

var someMethods = {};
someMethods.move = function() {
 this.position += 1;
};


// 2. Car 라는 함수 선언해 준다. 

var Car = function(position) {
	var printingInstance = Object.create(someMethods);  //기존에 만든 someMethods를 상속해버린다. 어디에? 여기에
    printingInstance.position = position;
    return printingInstance;
};

var car1 = Car(10);
car1 // {position: 10} // 이렇게 나온다.

// 메소드 move 는 어디갔냐? 
console.dir(car1) // 하면 
// position: 10
//__proto__:
//	move: f()

car1.move() 
car1 //  {position: 11}
car1.move() 
car1 //  {position: 12}
car1.move() 
car1 //  {position: 13}


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;4. Pseudoclassical&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 1.먼저 Car 함수 생성
var Car = function(position) {
    this.position = position
    }

// 2. 그다음 prototype 에 메소드를 추가한다. 

Car.prototype.move = function (){
    this.position ++;
 }



var car1 = new Car(10) // 꼭 new operater 를 붙여야 한다. 
car1 // {position: 10} // 이렇게 나온다.

// 메소드 move 는 어디갔냐? 
console.dir(car1) // 하면 
// position: 10
//__proto__:
//	move: f()

car1.move() 
car1 //  {position: 11}
car1.move() 
car1 //  {position: 12}
car1.move() 
car1 //  {position: 13}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;자료구조란&#34;&gt;자료구조란 ?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;데이터에 편리하게 접근하고, 변경하기 위해서 데이터를 저장하거나 조직하는 방법 을 말한다. 모든 목적에 맞는 자료구조는 찾기 어렵다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;stack&#34;&gt;Stack&lt;/h2&gt;

&lt;h4 id=&#34;stack-이란&#34;&gt;Stack 이란 ?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;마지막에 쌓인것이 먼저 먼저 나오는 자료구조&lt;/li&gt;
&lt;li&gt;Last In First Out  =&amp;gt; &lt;code&gt;L I F O&lt;/code&gt; 이렇게 표현된다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 4.43.04 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;property&#34;&gt;Property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* top : 가장 최근에 들어간, 맨 위의 값
* maxSize : 스택의 최대 할당 크기
* storage : 스택이 가지고 있는 데이터들의 모음
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method&#34;&gt;method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* 1. push : 맨 뒤에(위에) 삽입
* 2. pop : 맨위 제거
* 3. size : 크기 확인
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;오류&#34;&gt;오류&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;stack이  꽉차있는데 데이터를 삽입하려고 하면  Stack Overflow가 발생해 데이터가 들어가는 것을 차단한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;재귀함수가 멈추지 않을떄 자바스크립상에서 이를 방지하기 위해 &lt;code&gt;Maximum call stack size exceeded&lt;/code&gt; 발생 시킨다 이것은 &lt;code&gt;Stack Overflow&lt;/code&gt;에 기반한 오류로 볼 수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stack이 없는데 값을 꺼내려고 하면 &lt;code&gt;Stack underflow&lt;/code&gt;가 발생한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;queue&#34;&gt;Queue&lt;/h2&gt;

&lt;h4 id=&#34;queue-이란&#34;&gt;Queue 이란 ?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;먼저 들어간 데이터가 먼저 나오는 자료 구조.&lt;/li&gt;
&lt;li&gt;First In First Out =&amp;gt; &lt;code&gt;F I F O&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 4.47.58 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;property-1&#34;&gt;property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* front : 가장 먼저 들어간, 맨 밑의 값
* rear : 새로운 데이터가 들어갈 인덱스 (가장 최근의 인덱스 + 1)
* storage : 큐가 가지고 있는 데이터들의 모음
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-1&#34;&gt;method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* 1. enqueue : 맨 뒤에(위에)삽입
* 2. dequeue : 제일 앞에 빼기
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;오류-발생&#34;&gt;오류 발생&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;만약 큐데이터가 비워있는데  삭제한다고 하면 오류가 발생한다.
&lt;code&gt;Queue Underflow&lt;/code&gt; 라고 한다.&lt;/li&gt;
&lt;li&gt;만약 큐데이터가 꽉 차있을 경우 삽일 하려고 한다면 오류가 난다.
&lt;code&gt;Queue Overflow&lt;/code&gt; 라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linked-list&#34;&gt;Linked List&lt;/h2&gt;

&lt;h4 id=&#34;linked-list-란&#34;&gt;Linked List 란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;연결리스트는 각 데이터들을 포인터로 연결하여 관리하는 자료구조&lt;/li&gt;
&lt;li&gt;데이터값이 앞과 뒤로 연결되있다.&lt;/li&gt;
&lt;li&gt;노드들의 모임&lt;/li&gt;
&lt;li&gt;배열은 추가삭제가 느리지만 인덱스 조회가 빠르고 Linked List 는 추가삭제는 빠르지만 인덱스의 조회가 느리다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.03.37 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;연결-리스트를-사용할-때의-장점&#34;&gt;연결 리스트를 사용할 때의 장점&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;데이터를 차례대로 순회하면서 연산하기 좋음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;순회 도중에 새로운 데이터의 삽입, 삭제에 용이함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;배열과는 달리 데이터의 개수를 모르는 경우에도 별도의 비용없이 추가할 수 있음&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;연결-리스트를-원형으로-연결할-때의-장점&#34;&gt;연결 리스트를 원형으로 연결할 때의 장점&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;반복적인 순회에서 연결리스트의 끝을 체크해야할 필요가 없음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;head같은 메타데이터가 필요하지 않음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이로인해 시간, 메모리, 코드 모두 이득을 볼 수 있음&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;property-2&#34;&gt;Property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;HEAD : 첫 번째 노드를 지정하는 값
TAIL : 마지막 노드를 지정하는 값
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-2&#34;&gt;Method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;addToTail 추가 : 마지막 번째 노드에 데이터를 삽입
removeHead 삭제  : 첫 번째 노드를 삭제
contains 탐색 : 연결 리스트가 주어진 값을 포함하고 있는지 확인
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;graphs&#34;&gt;Graphs&lt;/h2&gt;

&lt;h4 id=&#34;graphs-란&#34;&gt;Graphs 란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;노드(node)와 노드를 연결하는 간선(edge)로 이루어진 비선형 자료 구조&lt;/li&gt;
&lt;li&gt;버텍스(vertex)와 노드를 연결하는 아크로 이루어진 비선형 자료 구조&lt;/li&gt;
&lt;li&gt;그래프에서는 노드를 &lt;code&gt;버텍스&lt;/code&gt;, 엣지를 &lt;code&gt;아크&lt;/code&gt;라고 부릅니다.&lt;/li&gt;
&lt;li&gt;예를 들어 지도, 지하철 노선도의 최단 경로, 전기 회로의 소자들, 도로(교차점과 일방통행길), 선수 과목 등이 있다.&lt;/li&gt;
&lt;li&gt;오일러 문제(다리 건너기), 길찾기 알고리즘, 최단거리 알고리즘(다익스트라,벨만포드)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.35.39 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;graphs-종류&#34;&gt;Graphs 종류&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* 무방향 그래프
* 정방향 그래프
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 1.34.31 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;property-3&#34;&gt;Property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;node : 그래프를 구성하는 노드들
edge : 노드들을 연결하고 관계짓는 간선들
nodes : 노드들을 담고 있는 데이터 배열
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-3&#34;&gt;Method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;addNode : 그래프에 노드를 추가한다.
removeNode : 그래프에서 노드를 제거한다.
addEdge : 노드와 노드 사이에 간선을 추가한다.
removeEdge : 노드와 노드 사이의 간선(관계)를 제거한다.
hasEdge : 노드와 노드 사이에 간선(관계)가 있는지 확인한다.
contains : 그래프가 주어진 값의 노드를 포함하고 있는지 확인한다.
forEachNode : 주어진 함수를 그래프가 가지고 있는 노드 각각에 대해 실행한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;그래프를-코드로-표현하는-2가지-방법&#34;&gt;그래프를 코드로 표현하는 2가지 방법&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1. 인접 행렬 그래프&lt;/li&gt;
&lt;li&gt;2. 인접 리스트 그래프의 두가지로 나눌 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;인접-행렬-그래프&#34;&gt;인접 행렬 그래프&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;장점: 직관적이며 쉽게 구현 가능
단점: 불필요한 정보의 저장이 많으며, 그래프의 크기가 커지면 메모리 초과가 발생할 수 있음
구현: int형의 2차원 배열을 주로 이용하며, 이동할 수 있으면 1, 없으면 0으로 표기함
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;인접-리스트-그래프-갈-수-있는-곳만-저장&#34;&gt;인접 리스트 그래프 - &amp;ldquo;갈 수 있는 곳만 저장&amp;rdquo;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;장점: 필요한 정보만 저장하여 메모리 절약 가능
단점: 인접행렬에 비해 다소 어려움
구현: 리스트(List)나 벡터(Vector)등의 자료구조를 이용하여 각 정점에서 이동가능한 정점들을 저장(List나 Vector를 이용한 2차원 배열이라 생각하면 이해하기 쉬움)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;길찾기-알고리즘&#34;&gt;길찾기 알고리즘&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-04 at 2.17.29 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;tree&#34;&gt;Tree&lt;/h2&gt;

&lt;h4 id=&#34;tree-란&#34;&gt;Tree 란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨&lt;/li&gt;
&lt;li&gt;부모-자식 관계를 이루는 노드들로 구성된 자료 구조&lt;/li&gt;
&lt;li&gt;컴퓨터 directory 구조 비슷 특정한 파일을 찾을때 폴더안에 폴더가 있고 그안에 파일이 있다 이러한 구조를 Tree 구조라고 한다.(조직도)
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.10.35 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;tree-종류에는-4가지가-대표적으로-있다&#34;&gt;Tree 종류에는 4가지가 대표적으로 있다.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1.이진 트리 (binary Tree) 란?&lt;/li&gt;
&lt;li&gt;2.편향 이진트리(skewed binary tree)란?&lt;/li&gt;
&lt;li&gt;3.포화 이진트리(full binary tree)란?&lt;/li&gt;
&lt;li&gt;4.완전 이진트리(complete binary tree)란?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-04 at 2.52.31 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.이진 트리 (binary Tree) 란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;이진 트리에서 각 노드는 &lt;code&gt;최대 2&lt;/code&gt;개의 자식을 가진다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이진트리인 경우 &lt;code&gt;왼쪽&lt;/code&gt;서브트리와 &lt;code&gt;오른쪽&lt;/code&gt; 서브트리로 구성된다.  여기서 &lt;code&gt;중요한점&lt;/code&gt;은 왼쪽과 오른쪽 서브트리를 확실하게 구분한다는 것이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2 편향 이진트리(skewed binary tree)란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;한쪽으로만 되어있는 한쪽 자식만 가지고 있는 것&lt;/li&gt;
&lt;li&gt;liked list 와 같이 생각할수 있다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;포화 이진 트리(Full Binary Tree) ?&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;모든 레벨이 꽉 찬 이진 트리&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;완전 이진 트리(Complete Binart Tree) 란?&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;포화 이진 트리처럼 모든 레벨이 꽉 찬 상태는 아니지만, 차곡차곡 빈 틈 없이 노드가 채워진 이진 트리



&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;용어&#34;&gt;용어&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  루트 노드(root node) : 부모가 없는 노드. 트리는 하나의 루트 노드만을 가진다.
  단말 노드(leaf node) : 자식이 없는 노드이다.
  내부(internal) 노드 : 리프 노드가 아닌 노드.
  링크(link) : 노드를 연결하는 선 (edge, branch 라고도 부름).
  형제(sibling) : 같은 부모를 가지는 노드.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;property-4&#34;&gt;Property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nodes : 값과 자식들로 이루어진, 노드들의 모임
edge : 노드들을 서로 연결하는 간선
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-4&#34;&gt;Method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;addChild() : 주어가 되는 노드에 자식 노드를 추가한다.
removeNode() : 주어진 값을 가진 노드를 삭제한다.
contains() : 주어진 값을 트리에 있는 노드들이 가지고 있는지 확인한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;binary-search-tree&#34;&gt;binary search tree&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;이진 탐색 트리(binary search tree)는 이진 트리 기반의 &lt;code&gt;탐색&lt;/code&gt;을 위한 자료 구조이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이진 탐색 트리는 4개의 조건이 있다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;바이너리 서치 트리는 세 가지 특징을 가지고 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;트리의 각 노드가 갖는 자식 노드의 수가 &lt;strong&gt;2개 이하&lt;/strong&gt;가 되어야 합니다.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;부모 노드의 &lt;strong&gt;왼쪽 하위 트리&lt;/strong&gt;에 있는 모든 노드의 데이터는 부모의 데이터보다 &lt;strong&gt;작거나 같아야&lt;/strong&gt; 합니다.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;부모 노드의 &lt;strong&gt;오른쪽 하위 트리&lt;/strong&gt;에 있는 모든 노드의 데이터는 부모의 데이터보다 &lt;strong&gt;커야&lt;/strong&gt; 합니다.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.16.03 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;바이너리 서치 트리를 순회하는 방법에는 두 가지가 있습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DFS (깊이 우선 탐색, Depth-First Search):&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;루트를 시작으로 점차 깊이 들어갔다가, 가장 깊은 depth에 도달했을 때 다시 나오고, 또 다시 깊이 들어가는 방식을 반복하며 전체 트리를 순회합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;BFS (너비 우선 탐색, Breadth-First Search):&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;sibling을 먼저 탐색하고, 그 후 다음 depth로 들어가 해당 depth의 slibling을 탐색하는 식으로 전체 트리를 순회합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;알고리즘-방법-추가학습&#34;&gt;알고리즘 방법 (추가학습)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;탐색 알고리즘&amp;gt;
&amp;lt;삽입 알고리즘&amp;gt;
&amp;lt;삭제 알고리즘&amp;gt;
이진 탐색 트리의 시간복잡도 분석
이진 탐색 트리에서는 최상의 경우 시간복잡도가 O(logn)인 탐색을 할 수 있다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;property-5&#34;&gt;Property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;left :  루트노드의 왼쪽에 있는 노드들  오른쪽보다 작은 
right : 루트 노드 의 오른쪽에 있는 노드들 왼쪽보다 큰 
value : 노드의 값
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-5&#34;&gt;Method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;insert : 주어진 값으로 노드를 만들어, 맞는 위치에 삽입
contains : 트리를 반복하여 주어진 값이 있는지 확인
delete : 노드를 삭제하고 트리 위치를 조정 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;삭제하는-3가지-방법&#34;&gt;삭제하는 3가지 방법&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.맨밑에 지울때 리프한번의 연산 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.자식이 한개인노드를 지울때 두번의 연산 일어난다. &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.자식이 2개이상인 노드를 지울때 이자리에 올려줄 친구를 찾는다.??? &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hash-table&#34;&gt;Hash Table&lt;/h2&gt;

&lt;h4 id=&#34;hash-table-란&#34;&gt;Hash Table 란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이 때 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)라고 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;값을 가공하기 위해서는 해쉬 함수가 필요하다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;해쉬 함수란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;키값을 (Dog)  을 넣으면 고유의 값(!@#1)이 나와서 hi 를 찾게 해준다.&lt;/li&gt;
&lt;li&gt;0 부터 key를 담은 값의 length 만큼만 반환시켜줄수 있어야 한다.&lt;/li&gt;
&lt;li&gt;언제든지 key 를 넣었을때 같은 값이 나와야 한다.&lt;/li&gt;
&lt;li&gt;어떠한 저장도 할수 없다. 기억을 가지고 있지않고 그때그때 값을 내밷어야 한다.&lt;/li&gt;
&lt;li&gt;근데 만약 fox 를 넣었는데 Dog 을 넣었을때 고유의 값 고유의 값(!@#1) 가 나온다면 충돌이 난다.&lt;/li&gt;
&lt;li&gt;그래서 고유의 값(!@#1)이 저장되에 있는곳에 0번째에 Dog &amp;gt; 1번째의 hi 를 가르키게 해주고 저장해놓고  0번째의 fox &amp;gt; 1번째의 hello  를 저장해놓게 된다면 고유의 값(!@#1) 값에서 0번째들안에 fox 를 찾아 value 값을 반환해주게 하면 된다 !
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;특징&#34;&gt;특징&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;key,value를가지고 있는 것&lt;/li&gt;
&lt;li&gt;어떤 특정 값을 받으면 그 값을 해시 함수에 통과시켜 나온 인덱스(index)에 저장하는 자료구조&lt;/li&gt;
&lt;li&gt;O(1)의 시간복잡도로 해결할 수 있다&lt;/li&gt;
&lt;li&gt;고유에 인댁스로 바로 접근할수 있기  때문에 빠르게 검색할수 있다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;해시 테이블은 사전을 구현하는 가장 효율적인 자료구조이다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;주의&#34;&gt;주의&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;해쉬 테이블은 원래 O(1) 를 자랑하는데 O(n) 이 될수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;내가 insert 한 값이 same bucket 에 들어가게 된다면 O(n) 이 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;when a hash table is growing, it resizes itself  and every element must be rehashed&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.53.57 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;스토리지 ?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;튜퓰 ?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;bucket ?
&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-05 at 12.36.09 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;property-6&#34;&gt;Property&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;limit : 한 슬롯(버킷) 안에 들어갈 수 있는 데이터의 최대 갯수이다.
storage : 데이터들이 저장되는 테이블이다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-6&#34;&gt;Method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;insert : 주어진 index로 테이블에 데이터를 추가한다.
retrieve : 주어진 Index로 데이터 값을 찾아 리턴한다.
remove : 주어진 키값에 해당하는 index에 들어 있는 값을 제거한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Complexity Analysis : 복잡도 분석이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;복잡도 분석이란 무엇이냐?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;알고리즘이 문제를 해결하는데 얼마나 시간과 공간을 차지 하는지 나타내는 지표이다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;시간복잡도에서는-big-o표기-할수-있다&#34;&gt;시간복잡도에서는 Big-O표기 할수 있다.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;O(1) – 상수 시간 :
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거친다.&lt;/p&gt;

&lt;p&gt;예 ) array lookup, hash table insertion&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;O(log n) – 로그 시간 :&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.&lt;/p&gt;

&lt;p&gt;예 ) binary search(tree)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;O(n) – 직선적 시간 :&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다.&lt;/p&gt;

&lt;p&gt;예 ) linked list, array search&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;O(n^2) – 2차 시간 :&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.&lt;/p&gt;

&lt;p&gt;예 ) constant time operation inside two nested for-loops&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;O(C^n) – 지수 시간 :&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱이다.&lt;/p&gt;

&lt;p&gt;예 ) recursion 피보나치 수열 등등&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 11.35.18 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 11.35.32 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;시간복잡도의-예시&#34;&gt;시간복잡도의 예시&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 11.33.25 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Arrays&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lookup O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;인덱스를 알고있기때문에 바로찾을수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Assign O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;인덱스를 알고있기 때문에 바로 바꿔버릴수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;insert O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;값을 추가하고 나머지 값들의 인덱스가 바꿔지기 때문에 시간복잡도가 늘어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Remove O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;특정값을 제거하면 나머지 값을을 땡겨서 인덱스를 맞춰야 하기 때문에 시간복잡도가 늘어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;find(value) O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;값이 어디에있는지 찾으려면 모든 인덱스값에 접근해야 하기때문에 시간복잡도가 늘어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Linked Lists&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lookup(Position) O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;특정 위치 를 찾으려고 한다.&lt;/p&gt;

&lt;p&gt;인덱스를 알수가 없다 무조건 head 부터 시작해야 한다. head 부터 시작해서 차례대로 찾는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Find (value )O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;특정 값을 를 찾으려고 한다.&lt;/p&gt;

&lt;p&gt;인덱스를 알수가 없다 무조건 head 부터 시작해야 한다. head 부터 시작해서 차례대로 찾는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Assign O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;값을 바꿔주려고 할때 그값을 찾으러 갈때 head부터 차례대로 가기 때문에 시간복잡도가 O(n) 이 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;insert O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;만약 내가 어디에 추가하고싶은지 알고있다면 O(n) 된다.&lt;/p&gt;

&lt;p&gt;왜냐하면 기존 에 값의 next pointer 를 알고있기때문에  next pointer 를 내가 추가하고자 하는 값에 연결시켜주고 내가 많든 값의 next pointer 를 다음 값에 연결시켜주면 되는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Removal O(n)  or O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 처음에 값을 제거하려면  O(1)된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;midle&lt;/code&gt; 중간에 값을 제거하려면 O(n) 된다.&lt;/p&gt;

&lt;p&gt;왜냐하면 값을 제거하기위 next-poniter 를 옮겨주면 되지만 뒤에 poniter 를 가지고 있지 않기 때문이다. 그래서 찾아야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;하지만 Doubly_linked lists&lt;/code&gt; 에서는 &lt;code&gt;insert&lt;/code&gt; 와 &lt;code&gt;remove&lt;/code&gt; 는 O(1) 이된다
왜냐하면 이전에 pointer 와 다음에 poniter 둘다를 가지고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Array % Singly-Linked List &amp;amp; Doubly-Linked Lists&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;array&#34;&gt;array&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  O(1) : lookUp
  O(n) : insert/remove
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;singly-linked-list&#34;&gt;Singly-Linked List&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  O(1) : insert
  O(n) : lookup, remove
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;doubly-linked-lists&#34;&gt;Doubly-Linked Lists&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  O(1) : insert/remove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;여기서 주의해야하는 것이&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Doulbly-linked Lists 는 각각의 노드들이 이전 다음 pointers 를 가지고 있기 때문에 &lt;code&gt;공간 복잡도&lt;/code&gt;에서 조금 늘어나는 차이가 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Trees&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;각각의 노드를 검색해야하기 때문에 시간복잡도가 늘어난다.&lt;/p&gt;

&lt;p&gt;루트부터 쫙 찾야아 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Binary Search Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;특정조건이 가지고 있다.&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;find O(log n)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;특정값을 찾겠다고 하면&lt;/p&gt;

&lt;p&gt;3번만에 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;빠른것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;만약 &lt;code&gt;linked-list&lt;/code&gt; 처럼 형태가 만들어진다면 (일자형 ) &lt;code&gt;find O(n)&lt;/code&gt; 되버린다.&lt;/p&gt;

&lt;p&gt;이런경우를 방지하기 위해 &lt;code&gt;Tree 구조&lt;/code&gt;를 틀어버린다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 8.09.06 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림에 나와있는 것처럼 추가할때마다 벨런스를 에 맞겠 조정을 해주면 다시&lt;/p&gt;

&lt;p&gt;find O(log n) 의 구조를 유지할수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;정렬된 구조에서 배열을 쓰지않고 binary  search 구조를 쓰는 이유가 있을까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Array 는 메모리를 계속 차지한다.&lt;/p&gt;

&lt;p&gt;Trees 구조는  linked-list 도 쓸수 있기때문에 구석구속 메모리를 쓸수 있어 효율적이다.&lt;/p&gt;

&lt;p&gt;메모리 효율적인면에서 BST 가 더낳다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>__Iheritance</title>
      <link>/tutorial/2020-01-05-spint-3/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2020-01-05-spint-3/</guid>
      <description>

&lt;h2 id=&#34;프로토타입-상속의-관한개념&#34;&gt;프로토타입 상속의 관한개념&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2020-01-05-spint-3_files/Screen Shot 2020-01-09 at 11.05.49 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;prototype-proto-constructor-관계&#34;&gt;&lt;code&gt;prototype&lt;/code&gt; || &lt;code&gt;__proto__&lt;/code&gt; || &lt;code&gt;constructor&lt;/code&gt; 관계&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.&lt;code&gt;Parent&lt;/code&gt;생성자 함수가 생성되는순간 Parent의 프로토타입 객체 (&lt;code&gt;Parent.prototype&lt;/code&gt;) 가 형성 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.Parent.protoype 안에는 &lt;code&gt;__proto__&lt;/code&gt; 와 &lt;code&gt;constructor&lt;/code&gt; 가 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.&lt;code&gt;__proto__&lt;/code&gt; 는 위에 부모객체를 가르키고 연결되어있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.모든 객체는 &lt;code&gt;__proto__&lt;/code&gt;가지고 있다. &lt;code&gt;프로토타입 객체&lt;/code&gt;에 접근할수 있게 해준다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.&lt;code&gt;constructor&lt;/code&gt; 는 자기 자신을 가르킨다. Parent === Parent.prototype.constructor // true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;5.생성자 함수 &lt;code&gt;Parent&lt;/code&gt;의 인스턴스로 &lt;code&gt;Son1,2,3,4&lt;/code&gt;을 생성했습니다.  &lt;code&gt;Son 들은&lt;/code&gt;은 &lt;code&gt;__proto__&lt;/code&gt; 프로퍼티를 가지고, &lt;code&gt;Son.__proto__&lt;/code&gt;는 자신의 부모인 &lt;code&gt;Parent.prototype&lt;/code&gt; 을 가리키고 있습니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;prototype-chaining&#34;&gt;&lt;strong&gt;Prototype Chaining?&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;자바스크립트 엔진이 어떤 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에서 프로퍼티나 메소드를 찾지 못하면, &lt;code&gt;__proto__&lt;/code&gt;가 가리키는 링크를 따라 부모 역할을 하는 프로토타입 객체를 살펴보는 것을 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;보무객체를-상속받는-예제&#34;&gt;보무객체를 상속받는 예제&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;생성자 함수 Parent 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 

function Parent(){
  this.money = 1000;
  this.car = &amp;quot;car&amp;quot;
    
    }

// 생성자 함수 Parent 의 메소드 massage 생성 

Parent.prototype.message = function(){
    return &amp;quot;밥먹어라 아들아&amp;quot;
    
    }
    
//new 키워드로 parent 생성자 함수 생성
    
var parent = new Parent()     

// 메소드 message 는 안보이지만 parent의 프로토타입 객체 (parent.prototype) 안에 message 가 저장되어있다.  

parent // Parent {money: 1000, car: &amp;quot;car&amp;quot;} 

parent.message() // &amp;quot;밥먹어라 아들아&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;object-create-사용해서-parent의-모든-프로퍼티-가져오기&#34;&gt;Object.create 사용해서 Parent의 모든 프로퍼티 가져오기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;생성자 함수 Son&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Son 함수는 이제 위에 Parent.prototype 의 접근해서{money: 1000, car: &amp;ldquo;car&amp;rdquo;}  와  &lt;code&gt;message()&lt;/code&gt; 를 상속받을 것이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Son 생성자 함수&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function Son(){ 
  Parent.call(this) // 1.Parent.call(this) 연결 시켜준다. 
  this.name = &amp;quot;jj&amp;quot;
    

Son.prototype = Object.create(Parent); // 2.Object.creat() 사용해서 상속
Son.prototype.constructor = Son; // 3. Son 함수가 constructor: ƒ Son() 자기자신을 가르키게 설정해준다. 

// 결과
console.dir(Son); // Son {money: 1000, car: &amp;quot;car&amp;quot;, name: &amp;quot;jj&amp;quot;}
//money: 1000
//car: &amp;quot;car&amp;quot;
//name: &amp;quot;jj&amp;quot;
// __proto__: Parent  &amp;lt;&amp;lt; Parent 과 연결 되어있다
// constructor: ƒ Parent()



// 3. Son.prototype.constructor = Son 을 하는 이유는?

// Son.protoype = Object.create(Parent) 하는 순간 

// Son.protoype.constructor = Parent 를 가르키게 된다. 

// 그렇게 되면 Son 함수가 자기 자신을 가르키지 않고 constructor: ƒ Parent() 가르키게 된다.  

// Son.prototype.constructor = Son 를 하지않는다면 
// 결과 
console.dir(Son); // Son {money: 1000, car: &amp;quot;car&amp;quot;, name: &amp;quot;jj&amp;quot;}

// money: 1000
//car: &amp;quot;car&amp;quot;
//name: &amp;quot;jj&amp;quot;
// __proto__: Parent  &amp;lt;&amp;lt; Parent 과 연결 되어있다
// constructor: ƒ Parent() // 하지만 Son 의 construtor 는 Parent()를 가르키게 된다. 
 




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;es6-class-키워드&#34;&gt;ES6 class 키워드&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;위에 있는 Parent() 와 Son() 의 상속관계를 예제로 바꿔보자&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parent class 함수 만든다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
class Parent {
  constructor() { // constructor키가 추가되었다. constructor(Parameter) 넣을수 있다. 
    this.money = 1000
    this.car = &amp;quot;car&amp;quot;
    }
  mesaage(){ // 메소드를 이렇게 정의한다. 
    return &amp;quot;밥먹어라&amp;quot;;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Son class 함수를 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 엄청 간단해졌다. 
class Son extends Parent{  // extentds 키워드 추가 
  constructor(){
    super()               // super()추가 Parent.call() 대체 
    this.name = &amp;quot;jj&amp;quot;    
  }
       eat(){             // 메소드 추가 
    return &amp;quot;맛있다.&amp;quot;
    } 
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;es5-와-es6-차이점&#34;&gt;ES5 와 ES6 차이점&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;What we&amp;rsquo;ll cover&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Destructuring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spread operator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rest Parameters&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Default Parameters&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Template Literals&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arrow Functions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;for &amp;hellip; of Loop&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;변수 할당 (Destructuring)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ES5

var user = {
  first: &amp;quot;john&amp;quot;,
  last : &amp;quot;jung&amp;quot;,
  age: 33
}

var first = user.first
var last = user.last

first // &amp;quot;john&amp;quot;
last // &amp;quot;jung&amp;quot;


// ES6
var user = {
  first: &amp;quot;john&amp;quot;,
  last : &amp;quot;jung&amp;quot;,
  age: 33
}

var {first,last} = user;

first // &amp;quot;john&amp;quot;
last // &amp;quot;jung&amp;quot;


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__Immersive Prep</title>
      <link>/tutorial/2019-12-21-sprint1/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2019-12-21-sprint1/</guid>
      <description>

&lt;h2 id=&#34;runtime&#34;&gt;Runtime&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;런타임란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;프로그래밍 언어가 실행되는 곳
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;node-js&#34;&gt;Node.js&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Node 란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;자바스크립트 런타임, V8엔진 등장(속도 향상, 크롬 브라우저의 V8 기반으로  nodejs사용해서 주로 웹서버 구축할수 있는 플랫폼 이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;V8 크롬 자바스크립트엔진?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자바스크립트를 기계어로 컴파일 해주는 역활을 해주는것이 V8&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;실행 시키는 법&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;node.js 환경에서 &lt;code&gt;node &amp;lt;file.name&amp;gt;&lt;/code&gt; 명령을 하면 작성한 코드가 작동합니다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1.&lt;code&gt;runNode.js&lt;/code&gt; 파일을 만든다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
const testFunction = function(arg){
  console.log(&amp;quot;Arg is : &amp;quot;, arg);
}

testFunction(20);

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2. &lt;code&gt;node&lt;/code&gt; 를 명령어 입력&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
$ node runNode.js

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nvm-node-version-manage&#34;&gt;NVM(Node Version Manage)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NVM 이란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;다양한 Node version를 설치하고 관리할 수 있는 프로그램&lt;/li&gt;
&lt;li&gt;버전 관리를 위해  NVM 이라는 도구를 사용&lt;/li&gt;
&lt;li&gt;NVM역시 하나의 프로그램이므로 설치해야 합니다.
*
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;실행 하는 법&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
nvm ls // 현재 버전 알아보기

nvm install 10.13.0 // 새로운 node version 을 설치하고 싶다면  이렇게 입력

nvm use 12.13.0 //  12.13.0 버전을 사용하고 싶다면 이렇게 * 버전이 이미 설치되어있어야함*


// 정리해보면 NVM은 다양한 Node version를 설치하고 관리할 수 있는 프로그램 입니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;npm-node-package-manager&#34;&gt;NPM (Node Package Manager)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NPM 이란 ?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;일종의 앱스토어입니다. 필요한 모듈을 다운로드할 수 있는, 모듈들이 모여있는 모듈 스토어입니다.&lt;/li&gt;
&lt;li&gt;자바스크립트 패키지 매니저이다.&lt;/li&gt;
&lt;li&gt;하나의 명령어 처럼 사용된다.&lt;/li&gt;
&lt;li&gt;예) npm start
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;패키지 설치&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node.js에서 사용할 수 있는 모듈인 패키지를 설치할 때에는 npm install 명령어 뒤에 설치할 패키지 이름을 지정한다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 이렇게 명령 한다. 
$ npm install &amp;lt;package&amp;gt;


// 예 emoji package 를 설치한다고 가정하자.
// Node.js 환경에서 emoji를 지원하는 node-emoji를 설치해 보자. 



// 1.먼저 적당한 위치에 프로젝트 디렉터리를 생성하고 프로젝트 디렉터리로 이동한다.

$ mkdir emoji &amp;amp;&amp;amp; cd emoji

// 2. npm install 명령어로 node-emoji 패키지를 설치한다.

$ npm install node-emoji


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;지역 설치와 전역 설치&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;npm install 명령어에는 &lt;code&gt;지역&lt;/code&gt;(local) 설치와 &lt;code&gt;전역&lt;/code&gt;(global) 설치 옵션이 있다&lt;/li&gt;
&lt;li&gt;옵션을 별도로 지정하지 않으면 지역으로 설치되며, 프로젝트 루트 디렉터리에 node_modules 디렉터리가 자동 생성되고 그 안에 패키지가 설치된다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;지역으로 설치된 패키지는 해당 프로젝트 내에서만 사용할 수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;지역 설치&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
$ npm install &amp;lt;package&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;전역 설치&lt;/li&gt;
&lt;li&gt;전역에 설치하는것을 권장하지 않음&lt;/li&gt;
&lt;li&gt;npm 을 적용할 디렉토리 안에 설치한다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
$ npm install -g &amp;lt;package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;전역에 설치된 패키지는 OS에 따라 설치 장소가 다르다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;macOS의 경우&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
/usr/local/lib/node_modules 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;윈도우의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
c:\Users\%USERNAME%\AppData\Roaming\npm\node_modules

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자주 사용하는 npm 명령어&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
 패키지 설치

//# 로컬 설치
$ npm install &amp;lt;package-name&amp;gt;

//# 전역 설치
$ npm install -g &amp;lt;package-name&amp;gt;

//# 개발 설치
$ npm install --save-dev &amp;lt;package-name&amp;gt;

//# package.json의 모든 패키지 설치

$ npm install

//패키지 제거

# 로컬/개발 패키지 제거
$ npm uninstall &amp;lt;package-name&amp;gt;

# 전역 패키지 제거
$ npm uninstall -g &amp;lt;package-name&amp;gt;


// 패키지 업데이트

$ npm update &amp;lt;package-name&amp;gt;

// 전역 설치 패키지 확인

$ npm ls -g --depth=0

// package.json scripts 프로퍼티의 start 실행
$ npm start

// package.json scripts 프로퍼티의 start 이외의 scripts 실행

$ npm run &amp;lt;script-name&amp;gt;

// 전역 패키지 설치 폴더 확인
$ npm root -g

/usr/local/lib/node_modules


# 파인더 오픈

$ open /usr/local/lib/node_modules

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;package-json&#34;&gt;package.json&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;package.json 란?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;프로그램을 실행시키기 위해 필요한 모듈들이 무엇인지 적어놓는 공간이다.&lt;/li&gt;
&lt;li&gt;내가 개발한 프로그램에서 필요한 모듈를 package.json에 작성해놓으면, 사용자는 파일을 보고 필요한 모듈만 설치하면 되기 때문에 효율적으로 작업할 수 있다. 카달로그와 같은 역할을 한다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;dependencies
*이 프로젝트가 돌아가기위해 반드시 필요한 모듈들이 무엇인지가 적혀 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;quot;dependencies&amp;quot;: {
&amp;quot;react&amp;quot;: &amp;quot;^16.8.6&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;devDependencies
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이 프로젝트를 개발하는 환경에서 필요한 모듈들이 무엇인지가 적혀 있습니다. 예를 들면 코드 모양을 잡아주는 lint나 테스팅 모듈처럼, 실제 프로젝트 동작에 직접적으로 영향을 주지 않는 모듈들을 명시합니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;devDependencies&amp;rdquo;: {
    &amp;ldquo;jest&amp;rdquo;: &amp;ldquo;^2.3.0&amp;rdquo;,
  	&amp;ldquo;eslint&amp;rdquo; : &amp;ldquo;^2.0.0&amp;rdquo;
  }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 3. scripts

  * npm 으로 실행시킬 수 있는 명령어를 정의합니다. 명령어를 입력하면 어떤 동작을 해야하는지가 적혀 있습니다. 예를들면 npm test 명령어를 입력하면 &amp;quot;test파일을 node 에서 실행시켜라!&amp;quot; 하는 내용들이 들어있습니다. 만약 npm test와 같은 명령어를 실행시켰는데 정의되지 않은 명령어 라는 오류 메시지가 나오면, package.json 파일 scripts 에 해당 명령어가 정의되어 있는지를 확인해 보시면 됩니다.

```js

&amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node app.js&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;node test.js&amp;quot;,
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-linting&#34;&gt;Testing &amp;amp; Linting&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;코드 퀄리티를 높이기 위해 testing 과 Linting 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;testing목적은?
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;코드가 맞게 작성되어있는지 확인하기 위해 test 를 한다.&lt;/li&gt;
&lt;li&gt;- &lt;strong&gt;Testing?&lt;/strong&gt; 작성한 코드가 의도대로 동작하는지, 결함은 없는지 확인하기 위해 반드시 필요한 과정입니다
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;testing-tool-3가지-테스트-방법이-있다&#34;&gt;testing Tool (3가지 테스트 방법이 있다. )&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  * 1.end to end test

  * 2.integration Test

  * 3.Unit test
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;karma, mocha, chai, jest, jasmine 등과 같은 툴을 사용합니다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;하나의 기능을 테스트하는  &lt;code&gt;Unit test&lt;/code&gt; 에는 페이스북에서 만든 &lt;code&gt;jest&lt;/code&gt; 라는 것이 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.Linint 목적은?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;우리가 지정한 코드스타일을 지키는지 안지키는지 체크해주는 도구이다. 일관된 코드스타일을 체크해주므로 다른사람과의 코드를 합칠때 충돌을 줄일수 있다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;예를 들어 세미클론을 철저히지키는 사람과 빼먹는 사람이 코드를 합치면 충돌과 오류가 나기때문에 그것을 방지하기 위해 Linint 을 사용한다.&lt;/p&gt;

&lt;p&gt;코드 스타일을 일관적으로 마추기 위해 처음부터 setting 하고 들어간다.&lt;/p&gt;

&lt;p&gt;코드 스타일을 지키는지 체크해 주는 툴입니다. 읽기 좋은 코드, 유지 보수하기 좋은 코드를 만드는 데 큰 도움이 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linint 을 적용하기위해 Eslint 사용한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ESlint 는 하나의 테스트해주는 도구이다.&lt;/li&gt;
&lt;li&gt;엄격하고 내가 원하는 것만 테스트할수있는 장점이 있다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;협업할때 필수 툴 ESlint, Jest,Prettier&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;this&#34;&gt;This&lt;/h2&gt;

&lt;h4 id=&#34;this란&#34;&gt;this란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;this === execution context 라고도 말한다.&lt;/li&gt;
&lt;li&gt;콜타임에 따라서 알게된다.&lt;/li&gt;
&lt;li&gt;An object that the invoked function points to when executing&lt;/li&gt;
&lt;li&gt;호출된 함수가 실행할 때 가리키는 특정 객체입니다
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;execution-안에는-4-가지가-담긴다&#34;&gt;execution 안에는 4 가지가 담긴다.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* scope내 변수 및 함수 (Local, Global)

* 전달인자 (arguments)

* 호출된 근원 (caller)

* this
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;this-는-5가지-patterns-이-있다&#34;&gt;this 는 5가지 patterns 이 있다.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  // 1. global this
  // 2. function invocation
  // 3. method invocation
  // 4. construction mode
  // 5. call(), .apply()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1. global this
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
this === window  같다 나온다


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2. function invocation
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;함수 안에서도 호출될때 window.name이 되어서 Global variable 호출된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var name = &amp;quot;Global variable&amp;quot;

function outer() {
	function inner()  {
	console.log(this.name); // Global variable
	}
inner()
}

outer();


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3. method invocation&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;여기서 this 는 counter 이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let counter = {
  value : 0,
  increment: function() {
	this.value++ ;
  },
  getValue: function() {
	  return this.value;
  }
}

counter.increment() 
count.getValue()

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;4 construction mode (생정자 모드 )&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;주인이 누구냐에 따라서 결정된다.&lt;/li&gt;
&lt;li&gt;new 키워드를 쓰면은 this 는 그냥 인스턴스다
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function Car(brand,name,color) { // Car() 는 클라스
	
	this.what_brand = brand;
	this.what_name = name;	
	this.what_color = color;
}

// 2. 클라스 함수를 변수에 담고 파라미터 들어갈 값들 넣는다. 
 

let a1 = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;);  //인스턴스 생성
let a2 = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;);  //인스턴스 생성
let a3 = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;);  //인스턴스 생성
let a4 = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;);  //인스턴스 생성


// 3.this는 값은 ?

// 경우에 따라 계속 변한다 
// car 의 인스턴스인 a1,a2,a3,a4 가 this가 되는것이다. 


a1.what_brand // a1 은 this
a2.what_brand // a2 은this
a3.what_brand // a3 은this
a4.what_brand // a4 은this



&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;5 call(), .apply() invocation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;첫번째 인자가 &lt;code&gt;무조건&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;call(this,1,2);   this 값에 들어갈 obj 가 this 다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;apply(this,[1,2]); this 값에 들어갈 obj 가 this 다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var add = function  ( x , y ) {
	this.val = x + y ;    // 여기서 this 는 ?
 
var obj = { 
val : 0
}; 


add.call(obj,2,3);  // 5 동일다.  // this 는 obj

add.apply(obj,[2,3]); // 5  동일하다.  //  this 는obj


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__My_MDN</title>
      <link>/tutorial/2019-11-14-javascript-my-mdn/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2019-11-14-javascript-my-mdn/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Dictionary_files/javascriptt-light_870x220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;string&#34;&gt;&lt;strong&gt;String&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;str.includes()&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// true or false 를 반환한다. 
// if 문에 넣어 쓴다. 

let str = &#39;To be, or not to be, that is the question.&#39;;

console.log(str.includes(&#39;To be&#39;));       // true
console.log(str.includes(&#39;question&#39;));    // true
console.log(str.includes(&#39;nonexistent&#39;)); // false
console.log(str.includes(&#39;To be&#39;, 1));    // false
console.log(str.includes(&#39;TO BE&#39;));       // false
console.log(str.includes(&#39;&#39;)) 


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str.match(regexp)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 문자열안에 있는 알파벳 뽑기.

let str = &amp;quot;abcdefgh23j2k4h6l3h1uiui24h4324jk3jh4k3h24&amp;quot;

let alphabet = str.match(/[a-zA-Z]/g);

// [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;h&amp;quot;]


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str[index]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1.글자 하나하나 가져오기

// 2. index로 접근은 가능하지만 쓸 수는 없음 (read-only)

// 3. + 연산자를 쓸수 있음.

// 4. length 쓸수 있음.

// let str = &#39;CodeStates&#39;;

// str[0]; &amp;gt;&amp;gt; &#39;C&#39;

// but

// str[0] = &#39;G&#39; &amp;gt;&amp;gt; 바뀌지 않음.

// str = &#39;Codestates&#39;
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str..toUpperCase()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;소문자를 대문자로 바꿈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;let str = &#39;CodeStates&#39;;

str.toUpperCase(); &amp;gt;&amp;gt;&amp;quot;CODESTATES

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str.toLowerCase()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;대문자 소문자 바꿈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
let str = &amp;quot;CodeStates&amp;quot;;

str.toLowerCase()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;num.toString()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.숫자를 문자로 바꾸는것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let num = 10;

num.toString();    

&amp;gt;&amp;gt; &#39;10&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;2.&lt;code&gt;Tip&lt;/code&gt;배열에 담겨있는 문자열을 꺼낼때도 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;arr = [&amp;quot;this is john&amp;quot;]; //이문자를 꺼내기 위해서는 toString();

let words = arr.toString();

&amp;gt;words
&amp;gt; &amp;quot;this is john&amp;quot;



function getAllWords(str) {
  // your code here
  // toString 를 사용해 배열에 있는 문자를 꺼내서 새로운 변수에 담는다 
  // 변수에 담긴 문자를 나누는 메소드를 사용해  새로운 변수에 또 담는다.
  // 변수를 출력한다.
  if ( str === &amp;quot;&amp;quot; ) {
    let arr = [];
    return arr;
  } else {
  let words = str.toString();
  let ret = words.split(&amp;quot; &amp;quot;);
  return ret
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;String(obj)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;숫자를 문자로 바꾸는것&lt;/p&gt;

&lt;p&gt;String, 이 함수는 변환하려는 객체의 toString() 메소드를 사용하는 것과 동일함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var t = [1,2,3];

console.log(String(t)); 

&amp;gt;&amp;gt;&amp;quot;1,2,3&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str.split()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immtuable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;문자열을 문자의 배열로 나누고 싶을 때 사용하는 메소드입니다.&lt;/p&gt;

&lt;p&gt;문자열을 배열로 만들때 유용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let str = &amp;quot;hello, world this is jj&amp;quot;;

1.str.split();
[&amp;quot;hello, world this is jj&amp;quot;]


2. str.split(&amp;quot;&amp;quot;);
[&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;jj&amp;quot;]


3. str.split(&amp;quot; &amp;quot;);
[&amp;quot;h&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;j&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var s = &amp;quot;hello, world this is jj&amp;quot;;
s.split(&amp;quot;,&amp;quot;);
&amp;quot;hello&amp;quot;, &amp;quot; world this is jj&amp;quot;
콤마가 생겼다. 콤마의 기준으로 갈라진다.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var s = &amp;quot;hello world t-h-i-s-i-s-j-j&amp;quot;
s.split(&amp;quot;-&amp;quot;);

&amp;quot;hello  world t&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;j&amp;quot;
- 기준으로 갈라진다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str.indexOf(serchValue)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
&amp;quot;Blue Whale&amp;quot;indexOf(&amp;quot;Blue&amp;quot;); &amp;gt;&amp;gt;0
&amp;quot;Blue Whale&amp;quot;.indexOf(&amp;quot;hello&amp;quot;); &amp;gt;&amp;gt;-1
&amp;quot;Blue Whale&amp;quot;.indexOf(&amp;quot;Whale&amp;quot;); &amp;gt;&amp;gt;5


&amp;quot;canal&amp;quot;.lastIndexOf(&amp;quot;a&amp;quot;) &amp;gt;&amp;gt; 3

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;str.repeat(숫자입력) 반복하는것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;let str = &#39;Because I&#39;m happy&#39;;

console.log(&#39;Chorus lyrics for &amp;quot;Happy&amp;quot;: &#39; + chorus.repeat(27));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str.charAt(index)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;인덱스에 있는 값을 리턴한다.&lt;/p&gt;

&lt;p&gt;ex&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var stringName = &#39;coding everybody&#39;;
alert(stringName.charAt(0)); // c
alert(stringName.charAt(stringName.length-1)); // y
alert(stringName.charAt(1000) == &#39;&#39;); // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;str.replace()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immtable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;값을 찾아서 원하는 값으로 바꿔준다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;str = &amp;quot;john jung&amp;quot;
let newStr = str.replace(john,jj);

&amp;gt; &amp;quot;jj jung&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;number&#34;&gt;&lt;strong&gt;Number&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;num.toFixed( digits )&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 소수점 지정하는것 

var numObj = 12345.6789;

numObj.toFixed();       // Returns &#39;12346&#39;: note rounding, no fractional part
numObj.toFixed(1);      // Returns &#39;12345.7&#39;: note rounding
numObj.toFixed(6);      // Returns &#39;12345.678900&#39;: note added zeros

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;parseInt(value)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 정수로 파싱 한다. 
// 만약 Number 는 숫자로 만 변환해준다면 이메소드는 바로 15를 출력하게 해준다. 
// parseInt 는 집법 변환 할때도 쓰인다. 


parseInt(string, radix);

parseInt(&#39;0xF&#39;, 16);  // 15   &amp;gt;&amp;gt; 16진수는 f까지 있으니까 f 가15니까 
parseInt(&#39;F&#39;, 16);  // 15   
parseInt(&#39;17&#39;, 8);  // 15   10진법으로 전환해서 
parseInt(15,99 10); // 15
Number(&amp;quot;15.123&amp;quot;)

// 15.123

parseInt(&amp;quot;15.123&amp;quot;&amp;quot;)
 
// 15

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;parseFloat(value)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
parseFlaot(&amp;quot;15.123&amp;quot;)

// 15.123

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Number.isInteger(value)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 정수인지 아닌지 판단하는 것

Number.isInteger(0);         // true
Number.isInteger(1);         // true
Number.isInteger(-100000);   // true
Number.isInteger(99999999999999999999999); // true

Number.isInteger(0.1);       // false
Number.isInteger(Math.PI);   // false

Number.isInteger(NaN);       // false
Number.isInteger(Infinity);  // false
Number.isInteger(-Infinity); // false
Number.isInteger(&#39;10&#39;);      // false


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;math-method&#34;&gt;&lt;strong&gt;Math_method&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Math.random()&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// arguments :  없음
// return value :  0 과 1 사이의 난수를 반환한다. 

Math.random(); // 0.7915594421190384  // 콘솔에 찍으면 막 나온다. 
Math.random(); // 0.12480720616017948 // 난수가 반환이 되는 것이다. 
Math.random(); // 0.014493108986906034

// 이것을 이용해 특정 범이의 정수 리턴하기
// 사용자가 원하는 정수를 출력하는 함수 만들기

Math.random(); // 0.014493108986906034 //   // 0 과 1 사이의 숫자들 

Math.random() * 10 // &amp;gt;&amp;gt;8.031510209216247    // 0  ~ 10 까지 
Math.random() * 109 // &amp;gt;&amp;gt;50.031510209216247  // 0 ~ 109 까지 
Math.random() * 20 // &amp;gt;&amp;gt;14.031510209216247   // 0 ~ 20 까지 
Math.random() * 5 // &amp;gt;&amp;gt;2.031510209216247     // 0 ~ 5 까지 


function getRandomInt(num) {
	return Math.floor(Math.random() * num );
}

getRandomInt(10); // &amp;gt;&amp;gt; 6
getRandomInt(100); // &amp;gt;&amp;gt; 50
getRandomInt(20); // &amp;gt;&amp;gt; 15
getRandomInt(7); // &amp;gt;&amp;gt; 5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Math.floor(x)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 반환값(Return)
// number, 정수

//예제(Example)


Math.floor(5.12323); // number, 5
Math.floor(5.912321); // number, 5
Math.floor(5); // number, 5
Math.floor(-5.121323); // number, -6
Math.floor(-5.923213); // number, -6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Math.abs(x)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 함수는 주어진 숫자의 절대값을 반환합니다
// 소수점을 없애는 것은 안된다. 

Math.abs(&#39;-1&#39;);     // 1
Math.abs(-2);       // 2`
Math.abs(null);     // 0
Math.abs(&#39;&#39;);       // 0
Math.abs([]);       // 0
Math.abs([2]);      // 2
Math.abs([1,2]);    // NaN
Math.abs({});       // NaN
Math.abs(&#39;string&#39;); // NaN
Math.abs();         // NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Math.max()&lt;/strong&gt;
&lt;strong&gt;Math.min()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;큰수,작은수 가져오기&lt;/p&gt;

&lt;p&gt;EX 큰수 가져오기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Math.max(10, 20);   //  20
Math.max(-10, -20); // -10
Math.max(-10, 20);  //  20
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;reduce 사용해서 큰수 가져오기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [1,2,3];
let max = arr.reduce(function(a, b) {
    return Math.max(a, b);
});


console.log(max)
&amp;gt;3

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;spread operator  사용해서 큰수 가져오기&lt;/p&gt;

&lt;p&gt;arr 로 큰수를 가져오기 위해서는 &amp;hellip; 을 써야 Math.max() &amp;lt;&amp;lt; 안에 들어간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [1, 2, 3];
let max = Math.max(...arr);

console.log(max)
&amp;gt;3

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;array&#34;&gt;&lt;strong&gt;Array&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;arr.reverse()&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [1, 2, 3];

arr.reverse();  // [3, 2, 1]


// 갹체안에있는 pro 값만 바꿀수 있다. 

let a = {0: 1, 1: 2, 2: 3, length: 3};

console.log(a); // {0: 1, 1: 2, 2: 3, length: 3}

Array.reverse.call(a); //same syntax for using apply()

console.log(a); // {0: 3, 1: 2, 2: 1, length: 3}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.fill()&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// fill 메서드는 value, start, end의 3개 인자를 가집니다

[1, 2, 3].fill(4);        // 4 로 채울것이다.
 // [4, 4, 4]           
[1, 2, 3].fill(4, 1);    // 4 로 채울건데 1번째 부터 쭉 
// [1, 4, 4]
[1, 2, 3].fill(4, 1, 2);   // 4 로 채울건데 1번쨰 부터 2번째까지   
//[1, 4, 3]
[1,2,3,4,5,6,7,8,9,10].fill(4, 3, 6); // 4 로 채울건데 3번째 부터 6번째 까지 (5 번째 까지 채워짐) 
// [1, 2, 3, 4, 4, 4, 7, 8, 9, 10]
[1, 2, 3].fill(4, 3, 3);  // 4 로 채울건데 3번째 부터 3번까지 값이 없다. 
// [1, 2, 3]





&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.includes()&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;d&amp;quot;];

arr.includes(&amp;quot;a&amp;quot;); 
// true

arr.includes(&amp;quot;f&amp;quot;);
//false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Array.isArray()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;메서드는 인자가 Array인지 판별합니다.&lt;/p&gt;

&lt;p&gt;() 안에 비워 있으면 실행되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Array.isArray([]);  // true
Array.isArray([1, 2, 3]);  // true
Array.isArray({foo: 123}); // false
Array.isArray(&#39;foobar&#39;);   // false
Array.isArray(undefined);  // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.indexOf(seachElement)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;str.indexOf 랑 똑같다.&lt;/p&gt;

&lt;p&gt;element 존재 확인 할때 유용&lt;/p&gt;

&lt;p&gt;발견되지 않으면 -1  표시&lt;/p&gt;

&lt;p&gt;()&amp;lt;&amp;lt;원소를 입력하면부터 앞에서 부터 찾아서 index번호 알려준다.
비슷한 목적을 가진 메소드로는 includes,find가 있음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var array = [2, 9, 9];
array.indexOf(2);     // 0
array.indexOf(7);     // -1
array.indexOf(9, 2);  // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.lastIndexOf(seachElement)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;()&amp;lt;&amp;lt;원소를 입력하면부터 뒤에서 부터 찾아서 index번호 알려준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var anyString = &#39;Brave new world&#39;;

console.log(&#39;The index of the first w from the beginning is &#39; + anyString.indexOf(&#39;w&#39;));
// logs 8
console.log(&#39;The index of the first w from the end is &#39; + anyString.lastIndexOf(&#39;w&#39;)); 
// logs 10
console.log(&#39;The index of &amp;quot;new&amp;quot; from the beginning is &#39; + anyString.indexOf(&#39;new&#39;));
// logs 6
console.log(&#39;The index of &amp;quot;new&amp;quot; from the end is &#39; + anyString.lastIndexOf(&#39;new&#39;));
// logs 6

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.sort(sortfunc)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1.배열을 정렬한다.&lt;/p&gt;

&lt;p&gt;2.알파벳 순서로 정렬한다.&lt;/p&gt;

&lt;p&gt;3.숫자의 경우 암시적으로 문자열로 형변환 하기 때문에 숫자 1이 숫자 10보다 먼저 나온다.&lt;/p&gt;

&lt;p&gt;4.sortfunc 로 비교 대상인 두개의 인자를 전달하는데, 리턴 값에 따라서 선후를 판단한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
strArr = [&amp;quot;all&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;]

// a 가 크면 리턴 1  작은수부터 정렬
strArr.sort(function(a,b){
	if (a &amp;gt; b) {
	return 1;
} else if (a === b){
	return 0;
} else {
	return -1;
}
})


// a 가 작으면 리턴  큰수부터 정렬

strArr.sort(function(a,b){
	if (a &amp;gt; b) {
	return -1;
} else if (a === b){
	return 0;
} else {
	return 1;
}
})




&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Example 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
var numbers = [9,8,7,6,5,4,3,2,1];
alert(numbers.sort()); // array, [1,2,3,4,5,6,7,8,9]
alert(numbers); // array, [1,2,3,4,5,6,7,8,9], 원본을 변경한다. 
alert(numbers.sort() === numbers); // boolean, true, 원본과 반환값이 같다.
 
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
//array, [1,10,2,20,3,4,5,6,7,8,9], 암시적으로 원소를 문자로 형변환 하기 때문에 10이 1뒤에 온다.
alert(numbers.sort()); 

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Example 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
var x = function(a,b){
	return a-b;
}

console.log(numbers.sort(x));

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20]


순서반대 로 할려면
return a+b;

[20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Example 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
function sortNumber(a,b){
// 비교 대상인 a와 b가 인자로 전달된다.
//alert(&#39;a :&#39;+a+&#39;, b:&#39;+b);
// a에서 b를 뺀 결과가 음수면 a가 b보다 작고, 0이면 같다.
// sort메소드는 return 값이 음수,양수,0인지에 따라서 순서를 정한다.
return a-b;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Description from others&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
위의 sort함수를 보면 parameter로 function이 올수 있다은건 이 문서를 보고 알수 있습니다.
그런데 sort함수 parameter인 function의 parameter와 retrun에 대한 설명(?)은 어떻게 알수 있나요??

예를들어서
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1]; 
function sortNumber(a,b){
return a - b;
}

이럴때, sortNumber함수(내가 만들려는 함수 )의 파라미터가 2개 (a,b)인건 어찌 알수있고, 
return함수가 어떻게 동작하는지는 어떻게 알수 있을까요?


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Description from others&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
우선 [20, 10, 9,8,7,6,5,4,3,2,1]의 배열에서 a-b라는 연산을 모두 한 다음 
그 결과값으로 정렬하는 것이 결코 아닙니다.
뭐하러 굳이 뺄셈을 하고 그 값으로 또 정렬하겠습니까? 

자바스크립트의 정확한 알고리즘은 아니지만 
쉽게 정렬 알고리즘을 설명하면 이렇습니다. 

(a,b) 형식으로 지정한 두 인자를 차례로 비교합니다.

우선 배열 numbers[0]과 numbers[1] 즉, 20과 10을 비교해 볼까요?
20-10 = 10 
결과값이 10 즉, 양수입니다.
sort함수에 sortNumber(a,b)의 return 값으로 양수 10을 전달합니다. 
그럼 sort함수가 양수값을 전달받고 배열의 순서를 바꾸어 버립니다. 
(정확하게 말하면 두 배열 안에 든 값을 교체)
그럼 배열이 [10, 20, 9,8,7,6,5,4,3,2,1] 이렇게 바뀝니다. 

그 다음 numbers[0]과 numbers[2] 즉 10과 9를 비교합니다. 10 - 9 = 1 &amp;gt;0, 양수입니다. 
결과값이 양수이므로 또 10과 9의 순서를 바꿉니다. 
이런 식으로 계속 두 인자를 비교해서 결과값이 양수가 나오면 순서를 바꾸고, 
음수가 나오면 순서를 그대로 유지하는 겁니다.

배열이 바뀌어가는 순서를 보면 이해하기 쉽습니다.

[(20), (10), 9,8,7,6,5,4,3,2,1] 20-10 = 10, 즉 양수이므로 순서바뀜! ()는 비교되는 인자값.
[(10), 20, (9),8,7,6,5,4,3,2,1] 10 - 9 = 1 또 양수, 순서 바뀜.
[(9), 20, 10, (8),7,6,5,4,3,2,1] 반복...
[(8), 20, 10, 9,(7)...]
...
[(2). 20, 10...3, (1)]
[(1), 20, 10...]

그럼 배열 내에서 가장 작은 값 1이 찾아지겠죠. 

[1, 20, 10, 9,8,7,6,5,4,3,2]

1의 순서는 바뀌지 않습니다. 1-2 = -1 
즉 결과값이 음수이기 때문이죠. 

그 다음은 두번째 배열 차례입니다.
20 - 10 = 10 &amp;gt; 0 이므로 순서를 또 바꿉니다. 

[1, (20), (10), 9,8,7,6,5,4,3,2]
[1, (10), 20, (9), 8...]
[1, (9), 20, 10, (8)...]

이런 식으로 반복하다 보면 두번째로 작은 값 2도 찾게 됩니다. 

....

[1, 2, 20, 10, 9,8,7,6,5,4,3]

그럼 다음은 세번째... 
이렇게 지루하게 반복하면 결국 정렬이 됩니다.

물론 실제 자바스크립트에서는 비교하는 순서가 다릅니다. 
다른 알고리즘을 쓰기 때문이죠.

이렇게 차례차례 비교해 나가면 인간이 이해하기는 쉽지만 
연산량이 기하급수적으로 늘어나기 때문에 다른 정렬 알고리즘을 쓰는 것이죠.

실제로는 
[20, 10, 9,8,7,6,5,4,3,2,1]
배열의 양쪽 끝부터 비교하고 (20, 1), 
그 다음 배열의 가운데 값을 차례로 비교해 나갑니다. (1,6)
디버깅해 보시면 쉽게 아실 수 있을 겁니다
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Description from others&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ar numbers = [20, 10, 9,8,7,6,5,4,3,2,1]; 
function sortNumber(a,b){
return a - b;
}
를 하게 되면 모든 값들끼리 a - b를 하게 됩니다. 

그렇게 나온 값들을 sort()에 넣으면, (a - b)의 순서가 숫자가 낮은 것부터 높은 순서대로 정렬이 되겠죠.
-19(1 - 20), -9(1-10), -8(1-9), -7(1-8), -6(1-7), -5(1-6), -4(1-5), -3(1-4), -2(1-3), -1(1-2)
-18(2-20), -8(2-10), -7(2-9), -6(2-8), -5(2-7), -4(2-6), -3(2-5), -2(2-4), -1(2-3), 0(2-2), 1(2-1)
-17(3-20), -7(3-10), -6(3-9), -5(3-8), -4(3-7), -3(3-6), -2(3-5), -1(3-4), 0(3-3), 1(3-2), 2(3-1)
...
10(20-10), 11(20-9), 12(20-8), 13(20-7), 14(20-6), 15(20-5), 16(20-4), 17(20-3), 18(20-2), 19(20-1)

그럼 계산된 숫자의 크기에 따라서 a와 b의 순서가 sort()에 의해 재배열 되어
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20
가 나옵니다.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.push(newElement)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;마지막 배열에 추가&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,];
arr.push(1);

arr; // = &amp;gt; [1,2,3,4,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.pop()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;뒤에 있는배열 제거&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var arr = [1,2,3,4,];
arr.pop();

arr; // = &amp;gt; [1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.unshift()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;앞에 붙이기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4];

arr.unshift(1);

arr; // = &amp;gt; [1,1,2,3,4,];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.shift()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;앞에 있는거 빼기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4];

arr.shift();

arr; // = &amp;gt; [2,3,4,]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.slice(bein,end)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;
문자열의 특정구간을 검색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tip&lt;/code&gt; 복제할수 있는 기능도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let obj1 = [1,2,3,4,5,6];
let obj2 = obj1.slice();

&amp;gt;&amp;gt; obj2 = [1,2,3,4,5,6 ];

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2번째 인덱스 부터 가져온다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var fruits = [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;];
var myFruits = fruits.slice(2);

myFruits = [&amp;quot;Lemon&amp;quot;, &amp;quot;Apple&amp;quot;, &amp;quot;Mango&amp;quot;]


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Return a portion of an existing array&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var fruits = [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;];
var citrus = fruits.slice(1, 3);

// fruits contains [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;]
// citrus contains [&#39;Orange&#39;,&#39;Lemon&#39;]

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;만약 fruits.slice(1,&lt;code&gt;0&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var fruits = [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;];

fruits.slice(1, 0);

&amp;gt;&amp;gt; []  &amp;lt;&amp;lt; 값이 사라진다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.splice(start,deleteCount,&amp;ldquo;itme1&amp;rdquo;,&amp;hellip;&amp;ldquo;)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;배열 중간에 원소 추가, 삭제&lt;/p&gt;

&lt;p&gt;중간에 element 를 삭제 할수 있는 방법이 이거뿐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var array = [1,2,3,4,5];
// 배열 중간에 원소 삭제 
// array.splice(인덱스, 인덱스부터 삭제할 원소개수)
var o = array.splice(2, 1);  
console.log(array); // [1, 2, 4, 5]
console.log(o); // [3]  // 삭제된 원소 반환
// 배열 중간에 원소 추가 
// array.splice(인덱스, 인덱스부터 삭제할 원소개수(추가시 0), 추가할 원소 ...)
o = array.splice(3, 0, 99, 99, 99);  
console.log(array); // [1, 2, 4, 99, 99, 99, 5]
console.log(o); // []
/*
array.unshift();  // 첫번째 원소 추가
array.shift();     // 첫번째 원소 삭제
array.push();    // 마지막 원소 추가
array.pop();      // 마지막 원소 삭제
array.join();      // 배열의 모든 원소를 문자열로 변환하고 연결(+)한 결과 반환
*/      


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.concat(arr)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;더하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;1.
let letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let numbers = [1, 2, 3];

letters.concat(numbers);


// result in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3]


2.

var arr = [1,2,3,4,5];

arr.concat(6); 

console.log(arr) 

&amp;gt;&amp;gt; [1,2,3,4,5,]  

기존에 있는 것은 변하지 않는다.
변하게 하기위해서는 변수를 새로 만들기 !



3. 

arr.concat([6,7,8,9,10]);

&amp;gt;&amp;gt;arr

[1,2,3,4,5,6,7,8,9,10] 
여러게를 더할수 있다.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.forEach(callbackFunction(element, index, array)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;배열에 길이 만큼 반복 실행하는 용도!&lt;/p&gt;

&lt;p&gt;forEach()는 주어진 callback을 배열에 있는 각 요소에 대해 오름차순으로 한 번씩 실행합니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

array1.forEach(function(element) {
  console.log(element);
});

// expected output: &amp;quot;a&amp;quot;
// expected output: &amp;quot;b&amp;quot;
// expected output: &amp;quot;c&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;3가지 인자값을 싱행 할수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;요소 값&lt;/li&gt;
&lt;li&gt;요소 인덱스&lt;/li&gt;

&lt;li&gt;&lt;p&gt;순회 중인 배열&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function logArrayElements(element, index, array) {
console.log(&#39;a[&#39; + index + &#39;] = &#39; + element);
}

// Notice that index 2 is skipped since there is no item at
// that position in the array.
[2, 5, , 9].forEach(logArrayElements);
// logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;arr.map(callbackFunction(element, index, array)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;callback 내에서 리턴이 필요하다.&lt;/p&gt;

&lt;p&gt;기존배열과 길이가 같고 , 형태가 다른 배열을 만들때 유용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;배열에 있는 값 각 각  100으로나누고 싶다?&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [100 ,200 ,500 ];

let newArr = arr.map(function(cur,idx,arr){
return cur / 100;
})

&amp;gt;&amp;gt;newArr = [1, 2, 5]


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;배열안에 모든 요소를 숫자로 바꾸기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


// 더 간단하게 해결할 수 있는 방법
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(Number); // [1, 2,3]


// 아래 라인을 보시면...
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt);
// 결과를 [1, 2, 3] 으로 기대할 수 있습니다.
// 그러나 실제 결과는 [1, NaN, NaN] 입니다.

// 그러나 `parseInt`와 달리 float이나 지수표현도 반환합니다.

[&#39;1.1&#39;, &#39;2.2e2&#39;, &#39;3e300&#39;].map(Number); // [1.1, 220, 3e+300]


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;배열 안에있는 것을 다른 형태로 출력 하고 싶다.?(길이)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

arr2 = [&amp;quot;code&amp;quot;,&amp;quot;states&amp;quot;];

let newArr2 = arr2.map(function(cur){
	return cur.length
});

&amp;gt;&amp;gt; newArr2 = [4, 6]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.filter(callbackFunction(element, index, array)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;걸러주는 역활 한다.&lt;/p&gt;

&lt;p&gt;return 필요&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [1,2,3,4,5,6];

newArr = arr.filter(function(cur,index,arr2){

	return cur &amp;lt; 2;
})


newArr = [1];



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.reduce(callback,[,initalValue])&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;return value :  최종 누적값&lt;/p&gt;

&lt;p&gt;모든 element 값을 누적해 하나의 결과로 리턴할 때 유용&lt;/p&gt;

&lt;p&gt;The reducer function takes four arguments:&lt;/p&gt;

&lt;p&gt;Accumulator (acc)&lt;/p&gt;

&lt;p&gt;Current Value (cur)&lt;/p&gt;

&lt;p&gt;Current Index (idx)&lt;/p&gt;

&lt;p&gt;Source Array (src)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;배열안에 있는 값을 각 각 더하고 싶을때 ?&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arr = [1, 2, 3, 4];

let count = arr.reduce(function(acc.cur){
  return acc + cur;
  // 1 + 2 + 3 + 4
});

conunt =&amp;gt; 10

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;초기값 5 를 넣고 더했을때&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [1, 2, 3, 4];

let count = arr.reduce(function(acc.cur) {
  return acc + cur;
  //5 + 1 + 2 + 3 + 4
},5);


count = &amp;gt;&amp;gt; 15

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.join(separator)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;배열의 원소를 결합해서 하나의 문자열로 만든다.
공백이 있는 곳에  요소를 더할수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [&amp;quot;welcome&amp;quot;,&amp;quot;coding&amp;quot;,&amp;quot;everybody&amp;quot;];
arr.join(&amp;quot; &amp;quot;);
&amp;quot;welcome coding everybody&amp;quot;

arr.join(&amp;quot; hi &amp;quot;)
&amp;quot;welcome hi coding hi everybody&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.every()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;every() 메서드는 배열 안의 모든 요소가 주어진 판별 함수를 통과하는지 테스트합니다.&lt;/p&gt;

&lt;p&gt;다음 예는 배열의 모든 요소가 10보다 더 큰지 테스트합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function isBigEnough(element, index, array) {
  return element &amp;gt;= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;화살표 함수 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
[12, 5, 8, 130, 44].every(elem =&amp;gt; elem &amp;gt;= 10); // false
[12, 54, 18, 130, 44].every(elem =&amp;gt; elem &amp;gt;= 10); // true


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;arr.some()&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;하나라도 조건이 맞으면 true  반환한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var array = [1, 2, 3, 5];

var even = function(element) {
  // checks whether an element is even
  return element % 2 === 0;
};

console.log(array.some(even));
// expected output: true



&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;object&#34;&gt;&lt;strong&gt;Object&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Object.keys(객체)  : &lt;code&gt;key&lt;/code&gt; 뽑기 into array&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object.values(객체) : &lt;code&gt;value&lt;/code&gt; 뽑기 into array&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object.entries(객체) : &lt;code&gt;전체&lt;/code&gt;뽑기 into array&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let user = {
  name: &amp;quot;John&amp;quot;,
  age: 30
};
Object.keys(person) = [&amp;quot;name&amp;quot;, &amp;quot;age&amp;quot;]
Object.values(person) = [&amp;quot;John&amp;quot;, 30]
Object.entries(person) = [ [&amp;quot;name&amp;quot;,&amp;quot;John&amp;quot;], [&amp;quot;age&amp;quot;,30] ]

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;뽑은것들 변수에 담아서 배열 에 넣기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arrKey =  Object.keys(person);
&amp;gt;&amp;gt;[&amp;quot;name&amp;quot;, &amp;quot;age&amp;quot;]

let arrValues = Object.values(person);
&amp;gt;&amp;gt; [&amp;quot;John&amp;quot;, 30]

let arrEntries = Object.entries(person);
&amp;gt;&amp;gt;[ [&amp;quot;name&amp;quot;,&amp;quot;John&amp;quot;], [&amp;quot;age&amp;quot;,30] ]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;obj.key&lt;/code&gt; or `obj[key]&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;for 문을 이용해 객체안에 있는 key value 뽑기&lt;/p&gt;

&lt;p&gt;ex 키값 뽑기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let person = { name : &amp;quot;john&amp;quot; , age : 33 } ; 

for (let key in person) {
	console.log(key);
}

&amp;gt;&amp;gt;name
&amp;gt;&amp;gt;age

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;ex value 뽑기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
let person = { name : &amp;quot;john&amp;quot; , age : 33 } ;

for (let key in person) {
	console.log(person[key]);
}

&amp;gt;&amp;gt;john
&amp;gt;&amp;gt;33

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>__My_Notes</title>
      <link>/tutorial/2019-11-26-js-post/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/2019-11-26-js-post/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;1-javacript&#34;&gt;1.Javacript&lt;/h2&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;object-assign&#34;&gt;Object.assign()&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.assign(target, &amp;hellip;sources)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// 1 번째 예제

var obj = {a:1};
var copy = Object.assign({}, obj);
console.log(copy); // {a: 1}

// 2번째 예제

var obj1 = {a:1};
var obj2 = {b:1};
var obj3 = {c:1};
var obj4 = {d:1};


var newObj = Object.assign({}, obj1, obj2, obj3,obj4);


console.log(newObj); // {a: 1, b: 1, c: 1, d: 1}

// 3번째 예제 


const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);  // assign 을 한후 target의 값이 바뀌었다.  
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget); // 이중 값이 둘어오면 나중에 값으로 cover 된다. 

// expected output: Object { a: 1, b: 4, c: 5 }



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;함수-생성하는-방법&#34;&gt;함수 생성하는 방법&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;함수 선언식 과 표현식의 차이점&lt;/li&gt;
&lt;li&gt;함수 선언식은 호이스팅이 되고 표현식은 호이스팅이 되지 않는다.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;함수 선언식에서는  ; 사용하지 않는다. 표현식에서는 세미콜론 사용,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;선언식&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

greet();
// 함수 선언
function greet(){
    console.log(&#39;hi&#39;)
}


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;표현식&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
const sayHello = function(){ 

  console.log(&#39;hello&#39;) 
  
  };


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;상속과-다형성의-차이점&#34;&gt;상속과 다형성의 차이점&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;상속과 다형성은 서로 보는관점이 다르다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;상위객체가 하위객체를 자기의 어떠함으로 만들어낼때 다형성이 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;하위객체가 상위객체를 볼때 상속이 된다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;deep-copy-shallow-copy&#34;&gt;Deep copy &amp;amp; Shallow copy&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.Deep copy&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;원시타입(primitive type)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;string-boolean-number&#34;&gt;String,Boolean,Number&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;복사가 일어날때 독립적이다
새로운 메모리 공간을 확보하여 값을 저장한다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Shallow copy&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;참조 타입(reference type)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;object-array-function&#34;&gt;Object,Array,function&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;복사가 일어날때, 객체 그 자체가 아닌 객체의 위치 값을 저장 
한마디로 딥 카피를 하면 엄청 메모리가 많이 잡힌다. 
똑같은값쓰는데 메모리값또할당받아서 쓰지말라는 것이다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var x = 2;
var y = x; 
y = 3;

x // 2 

// 
// y = x 로 할당 하여도 x 값은 변하지 않는다 왜냐하면 메모리를 따로 저장하기 때문이다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var x = { foo: 3 };
var y = x;
y.foo = 2;

// x.foo = 2  가 된다. 
// y.foo = 2 로 바꿨다. 그런데 x.foo 값이 바뀌었다. 
// 왜냐하면 x 와 y 는 같은 메모리를 사용하기 때문이다. 위치만 따로 쓴다. 

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var x = { foo: 3 };
var y = x;
y = 2;

// x.foo = 3. 
// 이것은 바뀌지 않는다. 왜냐하면 y = x 로 하여 deep Copy 가 일어나서 메모리를 따로 쓰기 때문에 x.foo 에 영향을 주지 않는다. 



&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var myArray = [2, 3, 4, 5];
var ourArray = myArray;
ourArray = [];

myArray // [2, 3, 4, 5]

// ourArray = [] 배열을 초기화 해도 myArray 에 영향을 주지 않는다. 
// 왜냐하면 값을 새로 지정해줬기 때문이다. 



&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

var myArray = [2, 3, 4, 5];
var ourArray = myArray;
ourArray[2] = 25;
ourArray = undefined;

myArray // [2, 3, 25, 5]

// 이경우에는 값이 변했다. 
// 왜냐하면 ourArray 가 myArray 메모리를 같이 쓰고있다가
// ourArray[2] = 25 로 바꾸웠기 때문에 myArray에 영향을 끼친다. 

// 하지만 
var myArray = [2, 3, 4, 5];
var ourArray = myArray;
ourArray = []

myArray // [2, 3, 4, 5];

// ourArray = [] 하면 myArray 에 영향을 주지 않는다. 
// ourArray = [] 빈배열로 정의하면 새로 배열을 만들었기 때문에
// myArray 에서 독립되서 메모리를 사용하기 때문이다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;callbacks-promises-async-await&#34;&gt;Callbacks, Promises, Async Await&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// DATA

const posts = [
	{ title: &amp;quot;&#39;Post One&amp;quot;, body: &#39;this is post one&#39;},
	{ title: &amp;quot;Porst One&amp;quot;, body: &amp;quot;this is post two&amp;quot;}
];



// getPosts() 함수는 화면에 data 안에 있는 tile 을 출력해준다. 
// 1초후 출력한다. 

function getPosts() {
	setTimeout(()=&amp;gt;{
	let output = &amp;quot;&amp;quot;;
	posts.forEach((post,index)=&amp;gt;{
		output = output + `&amp;lt;li&amp;gt;${post.title}&amp;lt;/li&amp;gt;`
	});
	document.body.innerHTML = output;
	},1000);
}
getPosts();


// creatPost(post) 함수는 2초후에 data에 새로운 값을 추가해넣는다. 
// 2초후에 추가된다 추가될 내용은 createPost({title:&amp;quot;추가될 내용&amp;quot;}) 이거다.

function createPost(post){
	setTimeout(()=&amp;gt;{
		posts.push(post)
	},2000)
}


// 추가된 내용이 출력되지 않는다. 왜냐하면 getPosts() 가 출력된후에 
// creatPost 가 추가되었기 때문이다. 

createPost(title: &amp;quot;Porst Three&amp;quot;, body: &amp;quot;this is post three&amp;quot;})

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;callback을 사용해서 추가한 값을 출력하기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getPosts() {
	setTimeout(()=&amp;gt;{
	let output = &amp;quot;&amp;quot;;
	posts.forEach((post,index)=&amp;gt;{
		output = output + `&amp;lt;li&amp;gt;${post.title}&amp;lt;/li&amp;gt;`
	});
	document.body.innerHTML = output;
	},1000);
}
getPosts(); // 1.이 호출을 creatPost() 함수 인자값으로 넣는다. 

// 2.creatPost 안에 파라미터로 callback 을 만든다.
// 이것이 callback 을 쓰는 이유이다. 
function createPost(post,callback){
	setTimeout(()=&amp;gt;{
		posts.push(post)
		callback() // 3.콜백 함수를 여기서 실행한다.
	},2000)
}


createPost({title:&amp;quot;Post Three&amp;quot;, body:&#39;This is post three&#39;},getPosts) //4.넣는다.



&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Promises 사용하해서 값을 추가하기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getPosts() {
	setTimeout(()=&amp;gt;{
	let output = &amp;quot;&amp;quot;;
	posts.forEach((post,index)=&amp;gt;{
		output = output + `&amp;lt;li&amp;gt;${post.title}&amp;lt;/li&amp;gt;`
	});
	document.body.innerHTML = output;
	},1000);
}



function createPost(post) {
		// Prsomise 안에 코드작성 
	return new Promise((resolve,reject)=&amp;gt;{

		setTimeout(()=&amp;gt;{
			posts.push(post)
		
		// error 가 잇는지 없는지 검사하기 위한방식

			const error = false; 

			if (!error) {
				resolve(); // 에러가 겂다면 출력
			} else {
				reject(&amp;quot;Error : something went wrong&amp;quot;)
			}
		},2000);

	})

}
// .then(getPorsts)  여기에 함수를 넣는다.  
createPost({title:&amp;quot;Post Three&amp;quot;,body:&#39;This is post three&#39;}).then(getPosts);



// 만약 에러메시지가 console 에 나오게 하려면

const error = true

		if (!error) {
				resolve(); 
			} else {
				reject(&amp;quot;Error : something went wrong&amp;quot;) // 이것이 나와야 한다. 
			}
		},2000);

	})

}

// .catch 라는 것을 사용한다. 
createPost({title:&amp;quot;Post Three&amp;quot;,body:&#39;This is post three&#39;})
.then(getPosts).catch(e =&amp;gt; console.log(e)); // console 창에 출력해라 


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-11-26-js-post_files/Screen Shot 2019-12-18 at 5.42.03 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Promise.all&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

const promise1 = Promise.resolve(&amp;quot;Hello world&amp;quot;);
const promise2 = 10;
const Promise3 = new Promise((resolve,reject)=&amp;gt;{
	setTimeout(resolve,2000, &amp;quot;GoodBye&amp;quot;);
})

Promise.all([promise1,promise2,Promise3])
.then((val =&amp;gt; console.log(val)))

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;객체지향프로그래밍-oop&#34;&gt;객체지향프로그래밍(OOP)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;갹체 지향 프로그래밍이란(OOP: Object Oriented Programming)?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;객체 지향 프로그래밍(이하 OOP)는 컴퓨터 프로그램을 “객체(Object)&amp;ldquo;들의 모임으로 파악하고자 하는 프로그래밍의 패러다임 중에 하나이다. 각 “객체(Object)&amp;rdquo; 들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;객체 지향 프로그래밍 장점&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;코드의 재사용성 제공 :
객체의 특성이나 속성을 한 번 정의해 놓으면 해당 객체에 소속되어 있는 모든 객체들의 속성으로 사용할 수 있으므로 재사용성이 높아진다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;유지보수의 용이 : 한 번만 정의한 것을 수정하면 모든 객체의 속성을 수정할 수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;신뢰성 증대 : 다양하게 사용된 속성들에 경험이 쌓이면서 신뢰가 축적되기 쉽고 그것을 다시 사용한다면 에러(버그)의 가능성이 줄어든다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OOP의 기본 구성 요소&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;클래스(Class)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;같은 종류의 집단에 속하는 속성과 행위를 정의한 것. 다른 클래스와 독립적으로 디자인해야 한다. 위의 예제에서 몬스터(Monster) 의 특성과 행위들을 정의한 객체가 클래스가 될 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;객체(Object)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;클래스의 인스턴스(Instance). 상위 클래스의 속성을 가지고 있으면서 개별적인 특성과 행위(메소드 : Method) 또한 가지고 있다. 위의 예제에서는 드래곤, 좀비, 해골 등이 각각의 객체가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;메서드(Method)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;클래스로부터 생성된 객체를 사용하는 방법. 객체의 속성을 조작하는 데 사용된다. 위의 예제에서 각각의 몬스터들이 레벨업을 하는 행위가 메서드(method)라고 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;OPP 특성&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;캡슐화(Encapsulation), 추상화(Abstraction) ,재사용성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;예제)&lt;/li&gt;
&lt;li&gt;객체를 만든다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;이 객체는 일반적으로 쓰는  Object Literal(객체 리터럴) 으로 생성됨&lt;/li&gt;
&lt;li&gt;외부에서 쉽게 프로포티 에 쉽게 접근할수 있다.&lt;/li&gt;
&lt;li&gt;예를 들어 level 을 바꾸는 경우가 있을수 있다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var monster1 = {
  level : 0,
  habitat : &#39;forest&#39;,
  levelUp: function () {
    this.level++;
  }
};


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;캡슐화(Encapsulation)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;외부에서 &lt;code&gt;var level = 0&lt;/code&gt;  접근 할수 없게 되었다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이전의 몬스터 객체처럼 monster.level로 몬스터의 level데이터에 접근할 수 없게 되었다. level은 오직 monster.levelUp이라는 메소드(method)로만 조작할 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var monster = createMonster();
function createMonster () {
  var level = 0;
  var openInfo = {
    habitat : &#39;forest&#39;,
    levelUp : function () {
      level++;
    }
  };
  return openInfo;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;추상화(Abstraction)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;추상화는 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정을 말한다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
//몬스터들이 공격을 받아 healthPoint가 0이 되면 필드에서
//죽은 것(death)으로 처리하고 싶다.
//이용자들은 몬스터들을 공격하고 죽는 모습을 보기만 하면 된다.
//어떠한 과정을 거쳐서 몬스터가 죽었는지에 대해서는 알 필요가 없다.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;위의 케이스에서는 객체에 2가지 속성이 추가되어야 한다. 몬스터가 죽은 상태인지 살아있는 상태인지를 확인하는 속성, 그리고 healtpoint라는 속성이다. 위의 속성을 추가하고 공격을 받는 상황을 메소드(method)로 만들어보겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var monster = {
  level : 0,
  habitat : &#39;forest&#39;,
  healthPoint : 100,
  isLive : true,
  levelUp: function () {
    this.level++;
  },

  damaged: function (damage) {
    this.healthPoint -= damage;
    if (this.healthPoint === 0){ 
       this.isLive = false;
    } 
  }
}

monster
// {level: 0, habitat: &amp;quot;forest&amp;quot;, healthPoint: 100, isLive: true, levelUp: ƒ, …}
monster.damaged(20);

monster
// {level: 0, habitat: &amp;quot;forest&amp;quot;, healthPoint: 80, isLive: true, levelUp: ƒ, …}
monster.damaged(20);

monster
//{level: 0, habitat: &amp;quot;forest&amp;quot;, healthPoint: 60, isLive: true, levelUp: ƒ, …}
monster.damaged(20);

monster
//{level: 0, habitat: &amp;quot;forest&amp;quot;, healthPoint: 40, isLive: true, levelUp: ƒ, …}
monster.damaged(20);

monster
//{level: 0, habitat: &amp;quot;forest&amp;quot;, healthPoint: 20, isLive: true, levelUp: ƒ, …}

monster.damaged(20);

monster // healthPoint :0 되었고 isLive 는 false 가 되었다. 
//{level: 0, habitat: &amp;quot;forest&amp;quot;, healthPoint: 0, isLive: false, levelUp: ƒ, …}


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;재사용성&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;몬스터를 여러마리 만든다고 가정하자&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OOP의 가장 큰 특성 중 하나가 바로 코드의 &lt;code&gt;재사용성&lt;/code&gt;과 &lt;code&gt;상속&lt;/code&gt;의 개념이다. 같은 객체를 여러 개 만들어야 하는 경우, 한 번 작성된 코드를 활용하여 동일한 객체를 만들 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Monster () {
  this.healthPoint = 100;
  this.habitat = &#39;forest&#39;;
  this.level = 1;
}
Monster.prototype.levelUp = function () {
  this.level++;
}
var broMonster= new Monster();  // 몬스터1
var childMonster = new Monster(); // 몬스터 2
var parentMonster= new Monster(); // 몬스터 3


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;위의 코드처럼 생성자 함수를 이용하는 방법 이외에도 Factory Function을 이용하는 방법도 있다. Factory Function은 간단히 객체를 리턴하는 함수라고 생각하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var monsterPrototype = {
  levelUp : function () {
    this.level++;
  }
}
function createMonster () {
  var monster = Object.create(monsterPrototype);
  monster.level = 1;
  monster.habitat = &#39;forest&#39;;
  return monster;
}
var broMonster= new createMonster();
var childMonster = new createMonster();
var parentMonster= new createMonster();


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;prototype-무엇이냐&#34;&gt;prototype 무엇이냐?&lt;/h2&gt;

&lt;h3 id=&#34;자바스크립트는-프로토타입-기반-객체지향-프로그래밍-언어이다&#34;&gt;자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다.&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ES6 문법이 도입되기 전에는 JavaScript에는 클래스(Class)가 없었음 그래서 객체 생성을 위해서 prototype을 사용했다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;객체를 생성하면, 프로토타입이 결정되고, 우리는 그 프로토타입을 변경할 수 있습니다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;첫번째-알아야-할것&#34;&gt;첫번째 알아야 할것&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;함수를 만들어 변수에 담을때 new 라는 것을 같이 담으면 객체가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person() {}

let x = new Person(); //  x 라는 변수는 객체가 된다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;두번째-알아야할-것&#34;&gt;두번째 알아야할 것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;객체(object)는 함수(function)로부터 시작된다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function Book() { }                // 함수 &amp;lt;&amp;lt;생성자 함수
var jsBook = new Book();           // 객체 생성


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;두가지 방식을 객체를 생성할수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var jsBook = new Book(); // 첫번째 방식 (생성자 함수) // 객체 

var jsBook = {}          // 두번째 방식(생성자 선언 없이 ) // 객체 


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;세번째-알아야-할것&#34;&gt;세번째 알아야 할것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;함수 생성시 발생하는 것을 알아야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.함수를 정의하면 함수가 생성되며 &lt;code&gt;Prototype object&lt;/code&gt;가 같이 생성 됩니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;생성된 Prototype object는 함수의 prototype 속성을 통해 접근할 수 있습니다.
(Prototype object같은 경우 &lt;code&gt;함수 생성시&lt;/code&gt;(var jsBook = new Book())에만 됩니다. 일반 객체 생성시에는 생성되지 않습니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;2.함수의 생성과 함께 생성된 Prototype object는 constructor와 &lt;strong&gt;proto&lt;/strong&gt;를 갖고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;constructor는 &lt;code&gt;생성된 함수&lt;/code&gt;를 가리키며(여기서는 function Book을 가리킵니다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;는 Prototype Link로서 객체가 생성될 때 사용된 생성자(함수)의 &lt;code&gt;Prototype object&lt;/code&gt;를 가리킵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;네번째-알아야-하는것&#34;&gt;네번째 알아야 하는것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;객체(object) 생성시 발생하는 일&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;생성하는 순간 jsBook 이라는 객체는 &lt;strong&gt;proto&lt;/strong&gt; 라는 &lt;code&gt;_proto__&lt;/code&gt;라는 프로퍼티를 갖고있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function Book() { }

Book.prototype.name = &amp;quot;john&amp;quot; 

var jsBook = new Book() // jsBook 은 객체이다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;prototype property(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 &lt;strong&gt;proto&lt;/strong&gt;는 객체라면 모두 갖고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-11-26-js-post_files/Screen Shot 2019-12-16 at 2.39.56 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;prototype property&lt;/code&gt;(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 &lt;code&gt;__proto__&lt;/code&gt;는 객체라면 모두 갖고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;예제&#34;&gt;예제)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1.일반적인 함수 패턴
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function Name(_name){
    var oName = {
        name : _name,
        getName : function(){
            return this.name;
        }
    }

    return oName;
}

Name(&#39;john&#39;); // Object{name: &#39;siwa&#39;, getName:function()} 리턴
var x = Name(&#39;john&#39;);
x.getName(); // &#39;john&#39; 리턴


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.객체 생성자 함수의 활용 - &lt;code&gt;모듈화&lt;/code&gt;,&lt;code&gt;프로토타입&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;new Key word 를 사용한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이는 객체지향적인 언어를 표방하는 기능, 클래스를 만드는 것과 비슷하다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(&lt;code&gt;new&lt;/code&gt;라는 키워드는 자바에서 클래스를 호출해서 인스턴스를 만드는 것과 비슷하다)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
 function Name(_name){
		console.log(&#39;this is&#39;,this);
		this.name = _name;
		this. getName = function(){
        return this.name;
    }
}

// 함수 를 그냥 호출했을때 와 new 키워드와 같이 호출했을때의 차이점 을 할수 있다. 

// 1. 함수를 그냥 호출했을때
Name(&#39;john&#39;); // this is window, undefined 리턴

// 2. new 키워드와 함께 함수를 호출했을 때
new Name(&#39;john&#39;); // this is Name{}, Name{name:&#39;monkey&#39;, getName()} 리턴



var x = new Name(&#39;john&#39;);

x.getName(); // &#39;john&#39;




&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.객체 생성자 함수의 활용 - &lt;code&gt;모듈화&lt;/code&gt; 와  &lt;code&gt;프로토타입&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*기능별로 모듈화 시킨 독립적인 클래스 단위로 그루핑할때 생성자 함수를 활용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;예를 들어 구글지도 UI를 만들 때, 화면에 보이는 기능 단위 즉 의미적으로 다른 기능이라면 (ex. 사진, 공유, 검색, 지도화면, 설정) 각각의 기능을 별도 모듈(클래스 단위)로 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 모듈화 수도코드 예시
// 지도를 표현하는 영역 클래스

function Map(name){
    this.name = &amp;quot;john&amp;quot;
    }
    
// 지도를 검색하는 영역 클래스
function SearchMenu(){}

// 사진을 슬라이드 하는 영역 클래스
function ViewCurrentPhotos(){}


var oMap = new Map(&amp;quot;john&amp;quot;);

 // 여기서 setDraw 를 설정해준다.
Map.prototype.setDraw = function (){
    console.log(name + &amp;quot;그림을 그리네 ?&amp;quot;);
}

oMap.setDraw() // john 그림을 그리네?


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3.객체 생성자 함수의 활용 - &lt;code&gt;모듈화&lt;/code&gt; 와  &lt;code&gt;프로토타입&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function Car(band,name,color) {
    // 인스턴스가 만들어 질때  실행될 코드들... 
}

// new 키워드를 통해 클라스의 인스턴스를 만들어낼 수 있습니다. 



// 1. 속성  : band,name,color , currentFuel,maxSpeed
// 2. 메소드  : refuel() ,setSpeed(), drive()



// ex


// 1. 클라스 함수 와 인스턴스 생성 

function Car(brand,name,color) { // Car() 는 클라스
	
	this.what_brand = brand; // 여기서 this 는 인자값이 드러갈 변수이름 (avante)
	this.what_name = name;	
	this.what_color = color;
}

// 2. 클라스 함수를 변수에 담고 파라미터 들어갈 값들 넣는다. 

let avante = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;); // 변수를 만든다 (인스턴스값으로 들어갈 )

// 3. 추가로 인스턴스를 생성 

Car.prototype.what_drive = function () { // Car() 인스턴스 생성 그리고 function 는 인스턴스 값  
    console.log(this.name + &amp;quot;가 운전을 합니다. &amp;quot;);
}


avante.what_name // 인스턴스 값 출력
// &amp;quot;avante&amp;quot;
avante.what_brand
// &amp;quot;GM&amp;quot;
avante.what_color
// &amp;quot;black&amp;quot;

avante.what_drive()  // 새로 생성한 what_drive 출력 
// jj 가 운전을 합니다. 

`tip`

let arr = [1,2,3,4,5]     // 배열 만들기 
let arr = new Array(1,2,3,4,5) // 배열 만들기  // Array클라스 안에 (인자값들) 




// ES6  에서는 클라스라는 키워드를 이용해서 정의 할수 있다. 


class car {
	constructor(brand,name,color) {
	
	// 인스턴스가 만들어질 때 실행되는 코드
		}
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;생성자-함수-prototype-객체-instance&#34;&gt;생성자 함수 || prototype 객체 || instance&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-11-26-js-post_files/Screen Shot 2019-12-04 at 9.14.37 AM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;생성자-함수-만들기&#34;&gt;생성자 함수 만들기&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 생성자 함수 를 만든다. 

function Class(name, age,yesNo) {
  this.name = name
  this.age = age
  this.yesNo = yesNo
  
}

// 동작을 만들기 위해 stydy 함수를 생정자 함수안에 추가한다.  
// 이때 prototype 을 만든다. 

Class.prototype.study = function(){
  console.log(this.name + &amp;quot; 운전을 합니다. &amp;quot;)
}


// 인스턴스 만든다. 
let obj = new Class(&amp;quot;join&amp;quot;,33,&amp;quot;좋아 이녀석아&amp;quot;);

obj.study(); // join 운전을 합니다.


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;함수-메소드-call-apply-bind&#34;&gt;함수 메소드 call(),apply,bind()&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;함수를 불러올때 유요한 메소드들&lt;/p&gt;

&lt;p&gt;불로오는 방식이 들림&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;add.call(obj,2,3);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;add.apply(obj,[2,3]);  (배열로 인자값을 넣는다.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;let boundFn = add.&lt;code&gt;bind&lt;/code&gt;(obj,2,3)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;boundFn &amp;lt;== this 값이 묶여 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;call&lt;/code&gt;은 실행되는 함수의 this값을 원하는 객체로 바꿔서 실행할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;는 실행되는 함수의 this값을 원하는 객체로 고정시키는 새로운 함수를 만들어낸다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;call-apply&#34;&gt;call() , apply()&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// this 값을 넘겨주는 방식이 틀림
// call() and apply()  사용해서 함수안에있는 parameter 사용하기 

//  add.call(obj,2,3);   obj &amp;lt;&amp;lt; this 2,3 &amp;lt;&amp;lt;&amp;lt;x y
//  add.apply(obj,[2,3]);   obj &amp;lt;&amp;lt; this 2,3 &amp;lt;&amp;lt;&amp;lt;x y

// 만약 this 가 add 함수 안에 없으면 
// add.call(null,2,3); 

var obj = { 
val : 0
}; 

//  리턴값이 출력되는 것이 아니라 this값이 obj 가 됨으로 obj.val =  2 +3 // 이것을 해주기 위해  add.call(obj,2,3); or add.apply(obj,[2,3]);
var add = function  ( x , y ) {
	this.val = x + y ;   


add.call(obj,2,3);  // 5 동일다. 

add.apply(obj,[2,3]); // 5  동일하다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;call-apply-어떻게-쓰냐&#34;&gt;call(), apply 어떻게 쓰냐?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;call, apply로 prototype 기능 빌려쓰기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [&amp;quot;code&amp;quot;,&amp;quot;states&amp;quot;]; 

//5보다 많은 length 가져오고 싶을때 filter 를 쓰게 된다. 
//그런데 call() 과 applay 를 이용해서 가져올수 있다. 

Array.prototype // 이럴때 필요 이라는 것이 필요하다. 

function moreThanFive(str) {
	return str.length &amp;gt; 5;
}


//첫번째 방법

arr.fillter(moreTahnFive) 

//두번째 방법

Array.prototype.filter.call(arr,moreThanFive)
Array.prototype.filter.apply(arr,[moreThanFive])


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;배열이(유사배열) 같아 보이지만 배열이 아닌경우&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let list = document.querySelectorAll(&amp;quot;a&amp;quot;)

//a 라는 selector를 모두가져와서 ID를 출력하고 싶다. 
//그럼 배열안에 Id 를 가져올때 map 을 쓸것이다. 
//그런데 실제로 이것은 배열 이아니기 때문에 map 메소드를 쓸수 없다 .

//이것을 배열로 인식하고 map 메소드 등을 이용해서 가공하기 위해서는 
//사용하기 위해서는  call(), apply()를 사용해서 가져와야 한다. 

function getElementId(element) {
	return element.id
}
list.map(getElementId) // 오류가발생한다. 왜냐하면 list 는 array 가 아니가 때문이다. 

// 이것을 되게 하는 방법

Array.prototype.map.call(this,getElementId) // this 값인 list 를 넣어주고 함수를 두번째 에 넣어주면  값이 실행된다. 



&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;applly-어디다-쓰느냐&#34;&gt;applly() 어디다 쓰느냐?&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;	
// arr 안에 가장 큰수를 가져오는 방법 apply() 메소드 써서 가져올수 있다.

let arr = [1,2,3,4,5,6];


Math.max.apply(null,arr); //apply 는 배열을 담으니까 큰수를 가져온다.  

// 6

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;bind-언제-유용하냐&#34;&gt;bind() 언제 유용하냐 ?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.특정 함수가 this 값을 바꿔버리는 경우&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;setTimeout()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 생성자 함수가 있다. 

function Class(name, age,yesNo) {
  this.name = name
  this.age = age
  this.yesNo = yesNo
  this.workingHard = function(){
	return this.yesNo;
	}
  this.study = function() {
	console.log(this.workingHard());
	}
  
}

// 인스턴스 obj 을 지정한다. 

let obj = new Class(&amp;quot;join&amp;quot;,33,&amp;quot;좋아 이녀석아&amp;quot;);

// study() 를 실행해서 workingHard() 실행하면  this.yesNo 가 실행 &amp;quot;좋아 이녀석아&amp;quot; 실행된다. 

// 하지만 setTimeout안에서는 this 값이 바꿔지기 때문에 실행이 안된다. 

setTimeout(obj.study,2000)


// 그래서 bind() 사용해서 실행한다. 
setTimeout(obj.study.bind(obj),2000)

//&amp;quot;좋아 이녀석아&amp;quot;; 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2.bind로 커링 구현하기&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;인자값을 고정시키고 쓸때&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function template(name,money) {
	// name 값을 지정하고 쓸것이다.
   return &amp;quot;&amp;lt;h1&amp;gt;&amp;quot;+name+&amp;quot;&amp;lt;/h1&amp;gt;&amp;quot; + &amp;quot;&amp;lt;span&amp;gt;&amp;quot;+money+&amp;quot;&amp;lt;/span&amp;gt;&amp;quot;
}


let temJohn = template.bind(null,&amp;quot;john&amp;quot;) // join 지정하고 바인드 해둔 것을 변수에 담는다 (커링)

temJohn(200); // &amp;quot;&amp;lt;h1&amp;gt;john&amp;lt;/h1&amp;gt;&amp;lt;span&amp;gt;200&amp;lt;/span&amp;gt;&amp;quot;

let temEsther = template.bind(null,&amp;quot;esther&amp;quot;);
temEsther(2000); // &amp;quot;&amp;lt;h1&amp;gt;esther&amp;lt;/h1&amp;gt;&amp;lt;span&amp;gt;2000&amp;lt;/span&amp;gt;&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;this&#34;&gt;This&lt;/h2&gt;

&lt;h4 id=&#34;execution-context-실행컨텍스트&#34;&gt;Execution context (실행컨텍스트)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;어떤 함수가 호출되면, 실행 컨텍스트 execution context가 만들어진다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;call stack에 push&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;함수를 벗어나면 call stack에서 pop&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;scope별로 생성&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;여기에 담긴 것&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;scope내 변수 및 함수 (Local, Global)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;전달인자 (arguments)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;호출된 근원 (caller)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/2019-11-26-js-post_files/Screen Shot 2019-12-03 at 3.37.25 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;this-keyword&#34;&gt;&lt;code&gt;this&lt;/code&gt; keyword&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;모든 함수 scope 내에서 자동으로 설정되는 특수한 식별자&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;execution context의 구성요소 중 하나로, 함수가 실행되는 동안 이용할 수 있다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; === execution context 라고도 말한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;this-는-5가지-patterns-이-있다&#34;&gt;&lt;code&gt;this&lt;/code&gt; 는 5가지 patterns 이 있다.&lt;/h4&gt;

&lt;p&gt;// 1. global this
// 2. function invocation
// 3. method invocation
// 4. construction mode
// 5. call(), .apply()&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Contruction ==&amp;lt; 생성자 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Method Invocation : call, apply의 첫번째 인자로 명시 된 객체, .을 기준으로 왼쪽에있는 객체&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;생성자함수-만들기-객체&#34;&gt;생성자함수 만들기 (객체)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;생성자는 new로 객체를 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Class(name, age) {
  this.name = name
  this.age = age
  
}

const obj1 = new Class(&#39;john&#39;, &#39;33&#39;) // Class의 인스턴스 생성 
console.log(obj1.name) // jogn
console.log(obj1.age) // 33

const obj2 = new Class(&#39;esther&#39;, &#39;30&#39;)
console.log(obj2.name) // essther
console.log(obj2.age) // 30


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;일반-객체-만들기-객체&#34;&gt;일반 객체 만들기 (객체 )&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
const person1 = {
  name: &#39;john&#39;,
  age: 33,
  yourName: function() {
    return this.name
  }
}
console.log(person1.yourName()) // john

const person2 = person1 // person1 을 person2 에 넣는다.  
person2.name = &#39;esther&#39; // 그리고 값을 바꾼다.


console.log(person1.yourName()) // person1 출력 :esther 

console.log(person2.yourName()) // person2 출력 :esther 

// person2 를 바꿨는데 person1 에 있는 name 까지 바뀌었다. 
// 왜냐하면 person2는  person1 레퍼런스 변수이므로 하나 이기 땨문이다. 



&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;how-to-use-this-with-call&#34;&gt;how to use this with call()&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function bar () {
  console.log(this);
}

bar.call({a:1}); // {a:1}


function bar () {
  console.log(this.a);

}

bar.call({a:1}) // 1





&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-1&#34;&gt;Closure 1&lt;/h2&gt;

&lt;h4 id=&#34;클로저란&#34;&gt;클로저란?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;함수는 함수를 리턴할수 있다.그것을 고차함수라고 하는데 그것을 클로저라 부른다. 한마디로 &lt;code&gt;외부함수의 변수에 접근할수 있는 함수&lt;/code&gt;를  &lt;code&gt;클로저&lt;/code&gt;라 부른다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;특징&#34;&gt;특징 ?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저 함수의 장점은 지역변수 외부 함수의 변수 전역 변수 에 접근이 가능하다는 점이다 !&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function foo() {
  return function() {
        return 2 
    }
}

foo() // f

// 2 가 반환되지 않고 
//f &amp;lt;&amp;lt; 함수 자체가 리턴된다 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;클로저예제1 : 함수 이용해서 템플릿 함수 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function htmlMark(tag) {
    let stratTag = &amp;quot;&amp;lt;&amp;quot; + tag + &amp;quot;&amp;gt;&amp;quot; ; 
    let endTag = &amp;quot;&amp;lt;&amp;quot; + tag + &amp;quot;&amp;gt;&amp;quot; ;
      return function(content) {     //  클로저 함수 사용 
        return stratTag + content + endTag;
    }
}

htmlMark(&amp;quot;h1&amp;quot;)(&amp;quot;JJ&amp;quot;); // 커링 사용해서 출력 tag : &amp;quot;h1&amp;quot; content:&amp;quot;JJ&amp;quot;
// &amp;gt;&amp;gt;&amp;gt; &amp;lt;h1&amp;gt;JJ&amp;lt;h1&amp;gt;

let h1Tag = htmlMark(&amp;quot;h1&amp;quot;); // 변수에 tag:&amp;quot;h1&amp;quot;담아서 지정하고 출력 

h1Tag(&amp;quot;JJ&amp;quot;)  //  content : &amp;quot;JJ&amp;quot;
// &amp;gt;&amp;gt;&amp;gt; &amp;lt;h1&amp;gt;JJ&amp;lt;h1&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;클로저예제 2 : 클로저 모튤 패턴&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


// 두 카운터가 각기 다른 privateCount 를 다루면서, privareCounter 을 밖에 노출시키지 않는 것이 장점이다. 

function makeCounter() {
	let privateCounter = 0; 

	let obj = {
	  plus : function() {
		  privateCounter = privateCounter + 1;
	  },	
	  minus: function() {
		  privateCounter = privateCounter - 1;
	  },
	  getValue: function() {
		  return privateCounter;
	  }
  }
  return obj;
};

let count1 = makeCounter() // 함수를 변수에 지정한다. 
count1.plus() // obj key값을 실행시키면 propo 값인 함수가 실행되면서 기존에 privateCounter 0 이였던 것을 1 증가시킨다. 

coun1.getValue() //  obj key값인 getValue() 함수를 실행시키면 지금까지 plus 하고 minus한 값을 출력 할수 있게 코드가 짜여 있다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-2&#34;&gt;Closure 2&lt;/h2&gt;

&lt;h4 id=&#34;클로져란&#34;&gt;클로져란?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저는 독립적인 (자유) 변수를 가리키는 함수이다. 또는, 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’.&lt;/p&gt;

&lt;p&gt;내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;



// 일반적인 함수


let addTo = function (passed) {

	let inner = 2;
	return passed + inner; 3 + 2 

};

console.log( addTo(3) ) //  5


//이것이 클로저

let passed = 3;  // 함수 밖에 변수를 선언한다 

let addTo = function () { //  parameter 를 외부에서가져온다. 

	let inner = 2;
	return passed + inner; 3 + 2  // 

};

console.log( addTo() ) //  5

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-3&#34;&gt;Closure 3&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다.&lt;/p&gt;

&lt;p&gt;자바스크립트에서 함수는 일급객체이다. 함수를 호출했을때 리턴되는 함수(클로저)를 참조하고 있는 것이다.&lt;/p&gt;

&lt;p&gt;즉 반환되는 내부함수가 클로저이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function outter() {
    
    var title = &#39;난 영혼처럼 살아있다.&#39;;
    
    return function() {
        
        console.log(title); // 클로저로 참조되는 외부변수를 자유변수(Free Variable) 라 부른다.
        
    };
};
 
var inner = outter();  // 생명 주기가 끝난 외부함수의 변수를 참조하는 내부함수를 클로저라 한다.  
inner();  // 결과 : 난 영혼처럼 살아있다. 
 
 
 

// 매번 호출할때 마다 변수값을 유지하고 싶을때 사용한다.
// 클로저가 참조하고 있는 변수를 노출시키지 않는다 (캡슐화)
// 클로저에서는 접근할수 있지만 코드 외부에서는 접근할수 없다.

var a = function() {
    
    var count = 0;
 
    return function() {
         return count++;
    };
};
 
let next = a();
 
console.log(next());  
console.log(next());  
console.log(next());  
console.log(next());  



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-4&#34;&gt;Closure 4&lt;/h2&gt;

&lt;h4 id=&#34;추가설명-코드를-작성할때-많이-격는-어려움&#34;&gt;추가설명 &amp;amp; 코드를 작성할때 많이 격는 &lt;code&gt;어려움&lt;/code&gt;&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저는 JavaScript의 유효범위 체인을 이용하여 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 방법입니다. 외부 함수가 종료되더라도 내부함수가 실행되는 상태면 내부함수에서 참조하는 외부함수는 닫히지 못하고 내부함수에 의해서 닫히게 되어 클로저라 불리 웁니다. 따라서 클로저란 외부에서 내부 변수에 접근할 수 있도록 하는 함수입니다.&lt;/p&gt;

&lt;p&gt;내부 변수는 하나의 클로저에만 종속될 필요는 없으며 외부 함수가 실행 될 때마다 새로운 유효범위 체인과 새로운 내부 변수를 생성합니다. 또, 클로저가 참조하는 내부 변수는 실제 내부 변수의 복사본이 아닌 그 내부 변수를 직접 참조합니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function outerFunc(){  
    var a= 0;
    return {
        innerFunc1 : function(){
            a+=1; // a =  a + 1;
            console.log(&amp;quot;a :&amp;quot;+a);
        },
        innerFunc2 : function(){
            a+=2; // a = a + 2;
            console.log(&amp;quot;a :&amp;quot;+a);
        }
    };
}
var out = outerFunc();  
out.innerFunc1();  
out.innerFunc2();  
out.innerFunc2();  
out.innerFunc1();

//실행결과
/*
a = 1  
a = 3  
a = 5  
a = 6  
*/
function outerFunc(){  
    var a= 0;
    return {
        innerFunc1 : function(){
            a+=1;
            console.log(&amp;quot;a :&amp;quot;+a);
        },
        innerFunc2 : function(){
            a+=2;
            console.log(&amp;quot;a :&amp;quot;+a);
        }
    };
}
var out = outerFunc();  
var out2 = outerFunc();  
out.innerFunc1();  
out.innerFunc2();  
out2.innerFunc1();  
out2.innerFunc2();


//실행결과

/*
a = 1  
a = 3  
a = 1  
a = 3  
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[예제 8] 클로저의 상호작용, 서로 다른 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;위의 코드는 클로저의 예제 코드이며 그 중 좌측 코드는 서로 다른 클로저가 같은 내부 변수를 참조하고 있다는 것을 보여주고 있습니다. 서로 다른 클로저 innerFunc1과 innerFunc2가 내부 변수 a를 참조하고 a의 값을 바꿔주고 있습니다. 실행 결과를 보면 내부 변수 a의 메모리를 같이 공유한다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;우측 코드는 같은 함수를 쓰지만 서로 다른 객체로 내부 변수를 참조하는 모습입니다. 외부 함수가 여러 번 실행되면서 서로 다른 객체가 생성되고 객체가 생성될 때 마다 서로 다른 내부 변수가 생성되어 보기엔 같은 내부 변수 a로 보이지만 서로 다른 내부 변수를 참조합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;클로저의-사용이유&#34;&gt;클로저의 사용이유&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저를 사용하게 되면 전역변수의 오,남용이 없는 깔끔한 스크립트를 작성 할 수 있습니다. 같은 변수를 사용하고자 할 때 전역 변수가 아닌 클로저를 통해 같은 내부 변수를 참조하게 되면 전역변수의 오남용을 줄일 수 있습니다. 또한, 클로저는 JavaScript에 적합한 방식의 스크립트를 구성하고 다양한 JavaScript의 디자인 패턴을 적용할 수 있습니다. 그의 대표적인 예로 모듈 패턴을 말 할 수 있는데 모듈 패턴의 자세한 내용은 [Javascript : 함수(function) 다시 보기]을 참고 하시면 될 것 같습니다. 마지막으로 함수 내부의 함수를 이용해 함수 내부변수 또는 함수에 접근 함으로써 JavaScript에 없는 class의 역할을 대신해 비공개 속성/함수, 공개 속성/함수에 접근을 함으로 class를 구현하는 근거 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;3-2-클로저-사용시-주의할-점&#34;&gt;3.2 클로저 사용시 주의할 점&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저를 사용할 때 주의해야 할 점이 여럿 있습니다. 제가 알려드리고 싶은
주의 점은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;for 문 클로저는 상위 함수의 변수를 참조할 때 자신의 생성될 때가 아닌 내부 변수의 최종 값을 참조합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;body&amp;gt;  
    &amp;lt;script&amp;gt;
    window.onload = function(){
        var list = document.getElementsByTagName(&amp;quot;button&amp;quot;);

        for(var i =0, length = list.length; i&amp;lt;length; i++){
            list[i].onclick=function(){
            console.log(this.innerHTML+&amp;quot;은&amp;quot;+(i+1)+&amp;quot;번째 버튼입니다&amp;quot;);
            }
        }
    }
    &amp;lt;/script&amp;gt;
&amp;lt;button&amp;gt;1번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;2번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;3번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;/body&amp;gt;  


//실행결과

/*
1번째 버튼은 4번째 버튼입니다  
2번째 버튼은 4번째 버튼입니다  
3번째 버튼은 4번째 버튼입니다  
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[예제 9] for문안의 클로저&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;위의 코드는 각각의 버튼에 이벤트를 걸어 클릭된 버튼이 몇 번째 버튼인지를 알기 위한 예제 입니다. 하지만, 실행 결과 값은 바라던 결과가 나오지 않습니다. 위의 클로저인 클릭 이벤트가 참조 하는 변수 i의 값이 버튼이 클릭될 때의 값이 아닌 for 구문을 다 돌고 난후 i의 값 4를 참조하기 때문에 모두 4라는 결과가 나옵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;body&amp;gt;  
    &amp;lt;script&amp;gt;
    window.onload = function(){
        var list = document.getElementsByTagName(&amp;quot;button&amp;quot;);

        var gate = function(i){
            list[i].onclick=function(){
            console.log(this.innerHTML+&amp;quot;은&amp;quot;+(i+1)+&amp;quot;번째 버튼입니다&amp;quot;);
            }
        }
        for(var i =0, length = list.length; i&amp;lt;length; i++){
             gate(i);
        }
    }
    &amp;lt;/script&amp;gt;
&amp;lt;button&amp;gt;1번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;2번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;3번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;/body&amp;gt;


//실행결과
/*
1번째 버튼은 1번째 버튼입니다  
2번째 버튼은 2번째 버튼입니다  
3번째 버튼은 3번째 버튼입니다  
*/


````


* [예제 10] 예제9 해결법 : 중첩클로저

&amp;gt; 위의 예제 코드를 통해 중첩 된 클로저를 사용하는 것 만으로 위와 같은 문제를 피하여 원하는 값이 나옵니다.

&amp;gt; 성능문제 클로저가 필요하지 않는 부분에서 클로저를 사용하는 것은 처리 속도와 메모리 면에서 좋은 방법이 아닙니다.


```js

function MyObject(inputname) {  
    this.name = inputname;
    this.getName = function() {
        return this.name;
    };
    this.setName = function(rename) {
        this.name = rename;
    };
}
var obj= new MyObject(&amp;quot;서&amp;quot;);  
console.log(obj.getName());  


//실행결과
/*
서
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[예제 11] 클로저의 오남용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;위의 코드와 같은 함수 내부의 클로저 구현은 함수의 객체가 생성될 때마다 클로저가 생성되는 결과를 가져옵니다. 같은 구동을하는 클로저가 객체마다 생성이 된다면 쓸데없이 메모리를 쓸데없이 차지하게 되는데, 이를 클로저의 오남용이라고 합니다. 클로저의 오남용은 성능 문제 면에서 안 좋은 결과를 가져옵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function MyObject(inputname) {  
    this.name = inputname;
}
MyObject.prototype.getName = function() {  
    return this.name;
};
MyObject.prototype.setName =   function(rename) {  
    this.name = rename;
};
var obj= new MyObject(&amp;quot;서&amp;quot;);  
console.log(obj.getName());  

//실행결과
/*
서
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[예제 12] prototype객체를 이용한 클로저 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;클로저를 위의 코드와 같이 prototype객체에 생성하게 되면 객체가 아무리 생성되어도 클로저를 한 번만 생성하고 여러 객체에서 쓸 수 있게 되어 메모리의 낭비를 줄입니다.&lt;/p&gt;

&lt;p&gt;this와 arguments객체 클로저를 통해서는 외부함수의 this객체와 arguments객체를 참조하지 못합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function f1(){  
    function f2(){
        console.log(arguments[0]);
    }
    return f2;
}
var exam = f1(1);  
exam();

//실행결과
/*
undefined  
*/

function f1(){  
    var a= arguments[0];
    function f2(){
        console.log(a);
    }
    return f2;
}
var exam = f1(1);  
exam();  

//실행결과
/*
1  
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[예제 13] arguments객체 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;위의 좌측코드같이 클로저를 통해 arguments객체를 참조하게 되면 undefined라는 실행결과가 나옵니다. 즉, arguments객체는 참조가 불가능하며 굳이 참조하고 싶다면 오른쪽 코드와 같이 새로운 내부 변수에 arguments객체의 값을 넣고 그 변수를 참조 하거나 매개변수를 만들어 매개 변수를 참조하여야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Function 생성자

var a= 20;  
function function1(){  
    var a= 10;
    var function2 = new Function(&amp;quot;&amp;quot;,&amp;quot;return a;&amp;quot;);
    return function2;
}
var exam = function1();  
exam();  
//실행결과
/*
20  
*/

// [예제 14] Function생성자로 선언된 클로저

// 위의 코드와 같이 클로저가 Function생성자로 생성된 경우 전역에서 생성된 것으로 인지합니다. 클로저 function2를 통하여 내부 변수 a를 참조하려고 했지만 원했던 결과와 달리 전역 변수 a가 참조 됩니다.



function outerFunc(){  
    var outer_val = {};
    function innerFunc(){
        console.log(outer_val);
    }

    outer_val.values = innerFunc;
    return innerFunc;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[예제 15] 인위적 순환참조&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;위의 코드는 의도적으로 클로저의 순환참조를 만든 예제 코드입니다. 내부 객체 outerval의 속성 값 values 에 내부 함수 innerFunc를 참조하게 만들고 내부 함수 innerFunc는 내부 객체 outerval을 호출 하고 있습니다. 위와 같은 순환 참조는 서로를 참조 하면서 영원히 끝나지 않는 호출로 인하여 메모리 누수를 야기합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function outerFunc(){  
    var outer_val = {};
    function innerFunc(){
        console.log(&amp;quot;Hello&amp;quot;);
    }
    outer_val.values = innerFunc;
    return innerFunc;
}

// [예제 16] 의도치 않은 순환참조

// 그렇다면 위 코드같이 서로를 참조를 하지 않게 되면 순환참조가 끊어질까요? 아닙니다. JavaScript의 클로저는 특별한 문법을 쓰지 않고도 암묵적으로 생기는 특성을 가지고 있습니다. 이는 클로저를 쉽게 만들도록 해주지만 클로저가 사용되는 곳을 사용자가 식별하기 어렵게 만들기도 합니다. 그렇게 되면 내부 함수의 innerFunc는 암묵적으로 상위 함수의 내부 객체인 outer_val을 참조하게 되고 이로인해 의도치 않게 순환참조가 만들어집니다. 이런 의도치 않은 순환참조는 메모리 누수를 야기합니다.

// 이 같은 의도치 않은 순환참조는 객체가 제거될 때 명시적으로 null값으로 초기화 해 주거나 try-catch-finally구문으로 해결합니다. 또는 더 글라스 크락포드가 제시한 purge함수를 쓰게 되면 순환참조를 해결할 수 있습니다. 아래는 purge함수 입니다.

function purge(d) {  
    var a = d.attributes, i, l, n;
    if (a) {
        for (i = a.length - 1; i &amp;gt;= 0; i -= 1) {
            n = a[i].name;
            if (typeof d[n] === &#39;function&#39;) {
                d[n] = null;
            }
        }
    }
    a = d.childNodes;
    if (a) {
        l = a.length;
        for (i = 0; i &amp;lt; l; i += 1) {
            purge(d.childNodes[i]);
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;커링-currying&#34;&gt;커링 (currying)&lt;/h2&gt;

&lt;h4 id=&#34;커링이란&#34;&gt;커링이란?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;호출된 함수의 매개변수로 동적으로 새로운 함수를 생성하여 반환하는 패턴을 커링이라 한다.&lt;/p&gt;

&lt;p&gt;호출하는 함수의 인자값이 비슷하다면 커링을 사용하는 것이 효율적이다.&lt;/p&gt;

&lt;p&gt;클로저를 이용해 함수의 인자를 미리 등록해두는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function func(a) {
    return function(b) { // 내부 함수, 즉 클로저인 익명 함수 반환
        return a + b;
    }
}
var currying = func(5);
var result = currying(5); 
console.log(result);

// 또는 아래처럼 호출
var result2 = func(5)(7); 
console.log(result2);

https://mylife365.tistory.com/320 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scope&#34;&gt;Scope&lt;/h2&gt;

&lt;h4 id=&#34;스코프란&#34;&gt;스코프란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;자바스크립트에서 스코프란 어떤 변수들에 접근할 수 있는지를 정의합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;스코프엔 두 가지 종류가 있습니다. 전역 스코프와 지역 스코프로 나뉩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;전역_스코프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


let greeting = &#39;Hello John&#39; // 외부에서 변수가 선언됨

function marcusHello () {
  console.log(greeting)
}

console.log(greeting) // &#39;Hello John!&#39; 

sayHello() // &#39;Hello John!&#39; 


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;지역_스코프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function marcusHello () {
  
  let greeting = &#39;Hello John!&#39; // 안에서 변수가 선언됨
  console.log(greeting)
}

marcusHello() // &#39;Hello John!!&#39;

console.log(x) // Error, hello is not defined


let name = &amp;quot;john&amp;quot;;

function showName() { 
  let name = &amp;quot;jj&amp;quot;; // 2. 지역변수 &amp;lt;&amp;lt; showName함수에서만 접근 가능
  console.log(name); // 2. jj
}

console.log(name); // 1.john &amp;lt;&amp;lt; 전역변수 가져옴
showname()         // 2.jj 
console.log(name)  // 3. john &amp;lt;&amp;lt; 여전히 전역 변수 john





let name = &amp;quot;john&amp;quot;;

function showName() {
  name = &amp;quot;jj&amp;quot;; // name 이 전역변수로 바뀜 cos let 없기 때문에 외부에서 변수 가져왔다. 
  console.log(name); //   jj 
}

console.log(name); // 1. john &amp;lt;&amp;lt; 전역변수 가져옴
showName()         // 2. 
console.log(name)  // 3. jj 함수가 실행된 뒤에는 함수안에 있는 name = jj 를 가져와서 리턴한다. 왜냐하면 jj 가 전역 변수로 바뀌었기 때문이다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-methods&#34;&gt;Number Methods&lt;/h2&gt;

&lt;h4 id=&#34;1-number-isinteger&#34;&gt;1. Number.isInteger()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;숫자가 인지 아닌지 확인&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;return : boolean&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Number.isInteger(1) // ture;
number.isInteget(&amp;quot;1&amp;quot;) // false;



&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-number-parsefloat-parseint&#34;&gt;2. Number(), parseFloat(), parseInt()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;문자열을 숫자로 바꾸는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Number(&amp;quot;12,32&amp;quot;); // Nan 소수점이 있으면 반환 안된다. 

parseInt(&amp;quot;123.2323&amp;quot;); // 123 소수점뒤에는 버린다. 
parseFloat( &#39;12.34&#39; ) // 12.34 소수점까지 포함해서 숫자로 반환해준다.

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-tofixed&#34;&gt;3. toFixed();&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;소수점이 길면 자르는 역활&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;반환값 : string&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let num = 123.2342323123231232312323123231232312323
num.toFixed(3) //  &amp;quot;123.234&amp;quot; // string 으로 반환


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;math-methods&#34;&gt;Math Methods&lt;/h2&gt;

&lt;h4 id=&#34;1-math-max-math-min&#34;&gt;1. Math.max() / Math.min()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;가장 큰수 리턴&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Math.max(2,3,2,4,52)

// 52

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;가장 작은수 리턴&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Math.min(2,3,2,4,52)

// 2


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-floor&#34;&gt;2.floor()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;소수점을 가장 가까운 정수로 내림한 값을 리턴&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;return : numnber , 정수&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Math.floor(5.1)); // number, 5
alert(Math.floor(5.9)); // number, 5
alert(Math.floor(5)); // number, 5
alert(Math.floor(-5.1)); // number, -6
alert(Math.floor(-5.9)); // number, -6


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-round&#34;&gt;3.round()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;소수점을 가장 가까운 정수로 리턴한다.&lt;/li&gt;
&lt;li&gt;return : number;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

alert(Math.round(5));   // number, 5
alert(Math.round(5.6)); // number, 6 // 올라간다. 
alert(Math.round(5.4)); // number, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-random&#34;&gt;4.random()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;0과 1사이의 랜덤한 수를 리턴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*0과 1사이의 수를 리턴함&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Math.random()의 리턴값에 수를 곱하면 0부터 곱한 수 사이의 랜덤한 값을 구할 수 있다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;랜덤한 수를 발급하거나, 시스템적으로 불규칙한 행위가 필요할 때 사용&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Math.random()*100); // number, 0~100 사이의 랜덤한 값을 리턴
alert(Math.ceil(Math.random()*100)); // number, 0~100 사이의 랜덤한 값을 올림한 정수를 반환



&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-abs&#34;&gt;5. abs()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;인자로 전달된 값에 대한 절대값을 리턴함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;6-sqrt&#34;&gt;6. sqrt()&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;제곱근을 리턴함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;사용방법 : Math.sqrt([대상 숫자]);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ex&#34;&gt;ex&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1024의 제곱근을 구하시오.

Math.sqrt(1024) : 32


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
alert(Math.sqrt(25)); // number, 5
alert(Math.sqrt(100)); // number, 10
alert(Math.sqrt(5)); // number, 2.23606797749979
alert(Math.sqrt(-5)); // Nan, 제곱근은 음수일 수 없음


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;7-pow&#34;&gt;7.pow&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;거듭제곱을 리턴한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Syntax : Math.pow(a,n)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;사용방법 :   Math.pow([대상 숫자], [거듭제곱 횟수]);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ex-1&#34;&gt;ex&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 숫자 2를 5번 거듭제곱하여 그 결과를 출력하시오.

Math.pow(2, 5)      // : 32
// 2* 2* 2 * 2 * 2  // : 32

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
//절대값이란 실수에서 부호를 제거한 값을 의미한다. 
// 3과 -3의 절대값은 3이 된다.
alert(Math.abs(-3)); // number, 3


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;callback&#34;&gt;Callback&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


// 장점 


/*
원래의 내장메소드에 있는 기능을 콜백 으로 바꿔서 사용할수 있다.

값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.

ajax를 사용할때 제이 쿼리를 이용해서 콜백이 사용된다. 


*/

function sortNumber(a,b){
    // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
    return b-a;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Notes_files/Screen Shot 2019-07-17 at 4.46.43 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 콜백 함수를 사용해서 함수 사용해기 

// first = element
// second = index
// third = array

function foo(first,second,third) {
	if ( first &amp;gt; second ) {
		console.log(first);
	} else {
		console.log(second);  
	}
}

function forEach(arr,test) {
	for (let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
		foo(arr[i],i,arr); // 함수
    	}
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;salesteam-안에-있는-data-fliter-와-foreach-로-다루기&#34;&gt;salesTeam 안에 있는 data  fliter 와 foreach 로 다루기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var salesTeam = [
  {
    &amp;quot;name&amp;quot;: {
      &amp;quot;first&amp;quot;: &amp;quot;Bruce&amp;quot;,
      &amp;quot;last&amp;quot;: &amp;quot;Wayne&amp;quot;
    },
    &amp;quot;age&amp;quot;: 10,
    &amp;quot;sales&amp;quot;: &amp;quot;$2314&amp;quot;
  },
  {
    &amp;quot;name&amp;quot;: {
      &amp;quot;first&amp;quot;: &amp;quot;Alvaro&amp;quot;,
      &amp;quot;last&amp;quot;: &amp;quot;Angelos&amp;quot;
    },
    &amp;quot;age&amp;quot;: 55,
    &amp;quot;sales&amp;quot;: &amp;quot;$1668&amp;quot;
  },
  {
    &amp;quot;name&amp;quot;: {
      &amp;quot;first&amp;quot;: &amp;quot;Alvaro&amp;quot;,
      &amp;quot;last&amp;quot;: &amp;quot;Angelos&amp;quot;
    },
    &amp;quot;age&amp;quot;: 15,
    &amp;quot;sales&amp;quot;: &amp;quot;$1668&amp;quot;
  }
];


// age 가 20 아래인 것만 teenager 에 담기 
// filter 사용

let teenager = salesTeam.filter(function(ele){
    return ele.age &amp;lt; 20;
  });

// 뽑은거 안에서 fullNmae 가져오기
// foreach 사용

  let result = [];
  teenager.forEach(function(ele){
    result.push(`${ele.name.first} ${ele.name.last}`);
  });



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;from&#34;&gt;from()&lt;/h2&gt;

&lt;h4 id=&#34;definiton-syntax&#34;&gt;Definiton &amp;amp; Syntax&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Array.from(arrayLike[, mapFn[, thisArg]])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;리턴 새로운 Array 인스턴스&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MDN&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Array.from()&lt;/code&gt;은 선택 매개변수인 mapFn를 가지는데, 배열(혹은 배열 서브클래스)의 각 요소를 맵핑할 때 사용할 수 있습니다. 즉, &lt;code&gt;Array.from(obj, mapFn, thisArg)&lt;/code&gt;는 중간에 다른 배열을 생성하지 않는다는 점을 제외하면 &lt;code&gt;Array.from(obj).map(mapFn, thisArg)&lt;/code&gt;와 같습니다. 이 특징은 &lt;code&gt;typed arrays&lt;/code&gt;와 같은 특정 배열 서브클래스에서 중간 배열 값이 적절한 유형에 맞게 생략되기 때문에 특히 중요합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;string-받아서-배열로-바꿈&#34;&gt;string 받아서 배열로 바꿈&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
console.log(Array.from(&#39;foo&#39;));
// expected output: Array [&amp;quot;f&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;o&amp;quot;]

console.log(Array.from([1, 2, 3], x =&amp;gt; x + x));
// expected output: Array [2, 4, 6]


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;set-사용해서-중복된-값-제거&#34;&gt;set 사용해서 중복된 값 제거&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
const set = new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;]);
Array.from(set);
// [ &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ]


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;arguments-도-받아서-배열로-만들어-버린다&#34;&gt;arguments 도 받아서 배열로 만들어 버린다.&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function f() {
  return Array.from(arguments);
}

f(1, 2, 3);

// [ 1, 2, 3 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;map-으로-사용하기-배열안에-배열&#34;&gt;map 으로 사용하기 배열안에 배열&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;values 값 얻기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var a = new Map([[&#39;1&#39;, &#39;a&#39;], [&#39;2&#39;, &#39;b&#39;]]) // 각요소의 1번째 가 키 2번째가 값 

Array.from(a.values()); // 새로운 array 출력한다. 

[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;] //값

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;keys 값 얻기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var a = new Map([[&#39;1&#39;, &#39;a&#39;], [&#39;2&#39;, &#39;b&#39;]]) // 각요소의 1번째 가 키 2번째가 값 

Array.from(a.values()); // 새로운 array 출력한다. 

[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;] //값


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;내가-원하는-수만큼-배열-만들기&#34;&gt;내가 원하는 수만큼 배열 만들기&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Array.from({length: 5}, (val, index) =&amp;gt; index);

// [0, 1, 2, 3, 4]


function add (val,index) {
return index;
}



Array.from({length: 5},add) // [0, 1, 2, 3, 4]


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reduce&#34;&gt;reduce()&lt;/h2&gt;

&lt;h4 id=&#34;definiton-syntax-1&#34;&gt;Definiton &amp;amp; Syntax&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;accumulator — the accumulator accumulates all of the callbacks returned values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;val — the current value being processed&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;index — the current index of the value being processed&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arr — the original array&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;The reduce() method is used to apply a function to each element in the array to reduce the array to a single value.&lt;/p&gt;

&lt;p&gt;여러게의 값이 담긴 배열이 줄여서(reduce) &lt;code&gt;최종적으로 하나의 값으로 만드는 과정&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;리턴값이 반듯이 필요&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;누적값 : 배열의 요소를 하나하나 줄여가면서 생기는 중간 과정(결과)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;현재값 : 리듀서가 배열을 지나갈 떄 만나는 배열의 요소&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;초기값 : 배열의 요소를 줄이기 전 누적값의 &lt;code&gt;초기&lt;/code&gt; 상태&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ex-2&#34;&gt;ex)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Reduce vs. For Loop&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;배열에서 숫자로&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To use for Loop&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let arr = [1, 2, 3, 4];
let sum = 0;
for(var i = 0; i &amp;lt; arr.length; i++) {
    sum += arr[i];
}
// sum = 10


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;To use the reduce() function&lt;/li&gt;
&lt;li&gt;배열에서 숫자로&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arr = [1,2,3,4];

let sum = arr.reduce((acc, val) =&amp;gt; {
  return acc + val;
});

// sum = 10

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;배열에서 문자열로&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이름 함쳐서 문자열로 출력 시키기&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let users = [
  
  {name:&amp;quot;john&amp;quot;,age : 20 },
  {name:&amp;quot;tim&amp;quot;,age :40 },
  {name:&amp;quot;esther&amp;quot;,age : 60 },
  
];

// &amp;quot;john, tim, esther&amp;quot; 이렇게 만들것이다. 

function sumName(retName , cuur ) {
	// 1. &amp;quot; &amp;quot; + &amp;quot;john&amp;quot; + &amp;quot;,&amp;quot;
	// 2. &amp;quot;john,&amp;quot; + &amp;quot;tim&amp;quot; + &amp;quot;,&amp;quot;
	// 3. &amp;quot;john, time,&amp;quot; + &amp;quot;esther&amp;quot; + &amp;quot;,&amp;quot;
	retName = retName + cuur.name + &amp;quot;,&amp;quot;; 
	return retName ; // 리턴을 꼭 해줘야 한다.
 }
 
 
users.reduce(sumName, &amp;quot;&amp;quot;); // 두번째 인자값에 초기값인  &amp;quot;&amp;quot; 넣어준다.

// &amp;quot;john,tim,esther,&amp;quot;




&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;배열에서 객체로&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;첫번째 글자를 따서 전화번호부 만들기&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 원본
let users = [
  
  {name:&amp;quot;john&amp;quot;,age : 20 },
  {name:&amp;quot;tim&amp;quot;,age :40 },
  {name:&amp;quot;esther&amp;quot;,age : 60 },
  
];

// 결과 출력 

let addressBook = {
	j : [
		{name:&amp;quot;john&amp;quot;,age : 20 }
      ],
	t : [
		{name:&amp;quot;tim&amp;quot;,age :40 }
      ],
	e : [
		{name:&amp;quot;esther&amp;quot;,age : 60 }
 	  ]
};



//1. makeAddressBook &amp;lt; callback 함수를 미리 만든다. 

function makeAddressBook (addressBook, user) {
  // 첫번째 글자를 먼저 변수에 저장한다. 
  let firstLetter = user.name[0];
  
  // addressBook { };
  
  
  if (firstLetter in addressBook) {
	  // 만약 키가 있으면 해당 배열에 사람을 추가한다. 
    addressBook[firstLetter].push(user);
	} else {
	  // 만약 키가 없다면 해당 배열을 만들고
	  addressBook[firstLetter] = [];
	  // 사람을 추가한다. 
  	addressBook[firstLetter].push(user);
  }
	return addressBook; // 객체를 리턴한다. 
}

users.reduce(makeAddressBook, {} ); 

// {j: Array(1), t: Array(1), e: Array(1)}

/* 결과값 
{
	j : [
		{name:&amp;quot;john&amp;quot;,age : 20 }
      ],
	t : [
		{name:&amp;quot;tim&amp;quot;,age :40 }
      ],
	e : [
		{name:&amp;quot;esther&amp;quot;,age : 60 }
 	  ]
};
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Using the reduce() method, how would you sum up the population of every country&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;data&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let data = [
  {
    country: &#39;China&#39;,
    pop: 1409517397,
  },
  {
    country: &#39;India&#39;,
    pop: 1339180127,
  },
  {
    country: &#39;USA&#39;,
    pop: 324459463,
  },
  {
    country: &#39;Indonesia&#39;,
    pop: 263991379,
  }
]

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Soultion&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


let sum = data.reduce(function(acc,val){
	
	return acc + val.pop;
		
	},0);
	
//1409517397 +1339180127 + 324459463 + 263991379 = 3337148366

// sum // 3337148366
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;except China?&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let sum = data.reduce((acc, val) =&amp;gt; {
  return val.country === &#39;China&#39; ? acc : acc + val.pop;
}, 0);


//sum = 1927630969
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-to-convert-a-str-of-nums-to-an-arr-of-nums&#34;&gt;How to convert a str of nums to an arr of nums?&lt;/h2&gt;

&lt;h4 id=&#34;qeustion&#34;&gt;Qeustion&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;str = &amp;ldquo;1,2,3,4&amp;rdquo; =&amp;gt;  [1, 2, 3, 4]&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
 
var a = &amp;quot;1,2,3,4&amp;quot;;
var b = a.split(&#39;,&#39;);
/// [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;]

// how to make this : [1, 2, 3, 4] 

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;soultion&#34;&gt;Soultion&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;useing Array.map to convert each element into a number.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = &amp;quot;1,2,3,4&amp;quot;;

var b = a.split(&#39;,&#39;).map(function(item) {
    return parseInt(item, 10);
});

// b = [1, 2, 3, 4] 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;useing Map and Number&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var b = a.split(&#39;,&#39;).map(Number);

// b = [1, 2, 3, 4] 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;useing from()&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var b = Array.from(a.split(&#39;,&#39;),Number);

// b = [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;foreach-map-fliter&#34;&gt;forEach(), map(), fliter()&lt;/h2&gt;

&lt;h4 id=&#34;1-foreach&#34;&gt;1. forEach()&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;array.forEach (callback(callbackFunction(element, index, array)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;배열 혹은 함수를 반복할때  사용&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리턴값 없다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ex-3&#34;&gt;ex)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;forEach 로 배열의 합 구하기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function test(){
    var testArray = [1,2,3,4,5];
    var sum = 0;
    function getSum(value){
        sum =  sum + value;
    }
    testArray.forEach(getSum); // forEach(getSum) that&#39;s all  
    console.log(sum);
  }

test()  // 15 

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-map&#34;&gt;2.map()&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;array.map(callbackFunction(element, index, array)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;새로운 배열&lt;/code&gt;을 만들때 사용&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리턴값 있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ex-4&#34;&gt;ex)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;for 문으로 name 값 가져오기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let users = [
  
  {name:&amp;quot;john&amp;quot;,age : 20 },
  {name:&amp;quot;tim&amp;quot;,age :40 },
  {name:&amp;quot;esther&amp;quot;,age : 60 },
  
];


let userName = [];


for (let i = 0; i &amp;lt; users.length; i ++ ) {
	userName.push(users[i].name);
 }
 
 userName // [&amp;quot;john&amp;quot;, &amp;quot;tim&amp;quot;, &amp;quot;esther&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;map() 으로 name 값 가져오기&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let users = [
  
  {name:&amp;quot;john&amp;quot;,age : 20 },
  {name:&amp;quot;tim&amp;quot;,age :40 },
  {name:&amp;quot;esther&amp;quot;,age : 60 },
  
];


function getName (user){
  return user.name; //  리턴값 필요하다. 

}

users.map(getName); // [&amp;quot;john&amp;quot;, &amp;quot;tim&amp;quot;, &amp;quot;esther&amp;quot;]





&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-fliter&#34;&gt;3.fliter()&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;array.fliter(callbackFunction(element, index, array)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;조건&lt;/code&gt;에 해당한 것을 새로운 배열의 형태로 출력 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리턴값 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;map 함수는 filter함수와 같이 오브젝트도 컨트롤 할 수도 있습니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;예제-1&#34;&gt;예제&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;filter 로 30 살 보다 많은 사람 사람을 찾는다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let users = [
  
  {name:&amp;quot;john&amp;quot;,age : 20 },
  {name:&amp;quot;tim&amp;quot;,age :40 },
  {name:&amp;quot;esther&amp;quot;,age : 60 },
  
];

function getOldName(user){
	return user.age &amp;gt; 30; // 리턴 필요하다. 
}
// 그리고 filter 에 함수를 넣는다. 
users.filter(getOldName) // [{name:&amp;quot;tim&amp;quot;,age :40 },{name:&amp;quot;esther&amp;quot;,age : 60 }];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;filter 로 이름에 s 가 있는 사람을 가져오고 싶다.?&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let users = [
  
  {name:&amp;quot;john&amp;quot;,age : 20 },
  {name:&amp;quot;tim&amp;quot;,age :40 },
  {name:&amp;quot;esther&amp;quot;,age : 60 },
  
];


function userIncludeS (user){
	return user.name.indexOf(&amp;quot;s&amp;quot;) !== -1; // 조건문 

 }
 
 
users.filter(userIncludeS) // [{name:&amp;quot;esther&amp;quot;,age : 60 }];

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sort&#34;&gt;sort()&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;arr.sort(sortfunc)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1.배열을 정렬한다.&lt;/p&gt;

&lt;p&gt;2.알파벳 순서로 정렬한다.&lt;/p&gt;

&lt;p&gt;3.숫자의 경우 암시적으로 문자열로 형변환 하기 때문에 숫자 1이 숫자 10보다 먼저 나온다.&lt;/p&gt;

&lt;p&gt;4.sortfunc 로 비교 대상인 두개의 인자를 전달하는데, 리턴 값에 따라서 선후를 판단한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
strArr = [&amp;quot;all&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;]

// a 가 크면 리턴 1  작은수부터 정렬
strArr.sort(function(a,b){
	if (a &amp;gt; b) {
	return 1;
} else if (a === b){
	return 0;
} else {
	return -1;
}
})


// a 가 작으면 리턴  큰수부터 정렬

strArr.sort(function(a,b){
	if (a &amp;gt; b) {
	return -1;
} else if (a === b){
	return 0;
} else {
	return 1;
}
})




&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Example 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
var numbers = [9,8,7,6,5,4,3,2,1];
alert(numbers.sort()); // array, [1,2,3,4,5,6,7,8,9]
alert(numbers); // array, [1,2,3,4,5,6,7,8,9], 원본을 변경한다. 
alert(numbers.sort() === numbers); // boolean, true, 원본과 반환값이 같다.
 
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
//array, [1,10,2,20,3,4,5,6,7,8,9], 암시적으로 원소를 문자로 형변환 하기 때문에 10이 1뒤에 온다.
alert(numbers.sort()); 

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Example 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
var x = function(a,b){
	return a-b;
}

console.log(numbers.sort(x));

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20]


순서반대 로 할려면
return a+b;

[20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Example 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
function sortNumber(a,b){
// 비교 대상인 a와 b가 인자로 전달된다.
//alert(&#39;a :&#39;+a+&#39;, b:&#39;+b);
// a에서 b를 뺀 결과가 음수면 a가 b보다 작고, 0이면 같다.
// sort메소드는 return 값이 음수,양수,0인지에 따라서 순서를 정한다.
return a-b;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Description from others&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
위의 sort함수를 보면 parameter로 function이 올수 있다은건 이 문서를 보고 알수 있습니다.
그런데 sort함수 parameter인 function의 parameter와 retrun에 대한 설명(?)은 어떻게 알수 있나요??

예를들어서
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1]; 
function sortNumber(a,b){
return a - b;
}

이럴때, sortNumber함수(내가 만들려는 함수 )의 파라미터가 2개 (a,b)인건 어찌 알수있고, 
return함수가 어떻게 동작하는지는 어떻게 알수 있을까요?


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Description from others&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
우선 [20, 10, 9,8,7,6,5,4,3,2,1]의 배열에서 a-b라는 연산을 모두 한 다음 
그 결과값으로 정렬하는 것이 결코 아닙니다.
뭐하러 굳이 뺄셈을 하고 그 값으로 또 정렬하겠습니까? 

자바스크립트의 정확한 알고리즘은 아니지만 
쉽게 정렬 알고리즘을 설명하면 이렇습니다. 

(a,b) 형식으로 지정한 두 인자를 차례로 비교합니다.

우선 배열 numbers[0]과 numbers[1] 즉, 20과 10을 비교해 볼까요?
20-10 = 10 
결과값이 10 즉, 양수입니다.
sort함수에 sortNumber(a,b)의 return 값으로 양수 10을 전달합니다. 
그럼 sort함수가 양수값을 전달받고 배열의 순서를 바꾸어 버립니다. 
(정확하게 말하면 두 배열 안에 든 값을 교체)
그럼 배열이 [10, 20, 9,8,7,6,5,4,3,2,1] 이렇게 바뀝니다. 

그 다음 numbers[0]과 numbers[2] 즉 10과 9를 비교합니다. 10 - 9 = 1 &amp;gt;0, 양수입니다. 
결과값이 양수이므로 또 10과 9의 순서를 바꿉니다. 
이런 식으로 계속 두 인자를 비교해서 결과값이 양수가 나오면 순서를 바꾸고, 
음수가 나오면 순서를 그대로 유지하는 겁니다.

배열이 바뀌어가는 순서를 보면 이해하기 쉽습니다.

[(20), (10), 9,8,7,6,5,4,3,2,1] 20-10 = 10, 즉 양수이므로 순서바뀜! ()는 비교되는 인자값.
[(10), 20, (9),8,7,6,5,4,3,2,1] 10 - 9 = 1 또 양수, 순서 바뀜.
[(9), 20, 10, (8),7,6,5,4,3,2,1] 반복...
[(8), 20, 10, 9,(7)...]
...
[(2). 20, 10...3, (1)]
[(1), 20, 10...]

그럼 배열 내에서 가장 작은 값 1이 찾아지겠죠. 

[1, 20, 10, 9,8,7,6,5,4,3,2]

1의 순서는 바뀌지 않습니다. 1-2 = -1 
즉 결과값이 음수이기 때문이죠. 

그 다음은 두번째 배열 차례입니다.
20 - 10 = 10 &amp;gt; 0 이므로 순서를 또 바꿉니다. 

[1, (20), (10), 9,8,7,6,5,4,3,2]
[1, (10), 20, (9), 8...]
[1, (9), 20, 10, (8)...]

이런 식으로 반복하다 보면 두번째로 작은 값 2도 찾게 됩니다. 

....

[1, 2, 20, 10, 9,8,7,6,5,4,3]

그럼 다음은 세번째... 
이렇게 지루하게 반복하면 결국 정렬이 됩니다.

물론 실제 자바스크립트에서는 비교하는 순서가 다릅니다. 
다른 알고리즘을 쓰기 때문이죠.

이렇게 차례차례 비교해 나가면 인간이 이해하기는 쉽지만 
연산량이 기하급수적으로 늘어나기 때문에 다른 정렬 알고리즘을 쓰는 것이죠.

실제로는 
[20, 10, 9,8,7,6,5,4,3,2,1]
배열의 양쪽 끝부터 비교하고 (20, 1), 
그 다음 배열의 가운데 값을 차례로 비교해 나갑니다. (1,6)
디버깅해 보시면 쉽게 아실 수 있을 겁니다
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Description from others&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ar numbers = [20, 10, 9,8,7,6,5,4,3,2,1]; 
function sortNumber(a,b){
return a - b;
}
를 하게 되면 모든 값들끼리 a - b를 하게 됩니다. 

그렇게 나온 값들을 sort()에 넣으면, (a - b)의 순서가 숫자가 낮은 것부터 높은 순서대로 정렬이 되겠죠.
-19(1 - 20), -9(1-10), -8(1-9), -7(1-8), -6(1-7), -5(1-6), -4(1-5), -3(1-4), -2(1-3), -1(1-2)
-18(2-20), -8(2-10), -7(2-9), -6(2-8), -5(2-7), -4(2-6), -3(2-5), -2(2-4), -1(2-3), 0(2-2), 1(2-1)
-17(3-20), -7(3-10), -6(3-9), -5(3-8), -4(3-7), -3(3-6), -2(3-5), -1(3-4), 0(3-3), 1(3-2), 2(3-1)
...
10(20-10), 11(20-9), 12(20-8), 13(20-7), 14(20-6), 15(20-5), 16(20-4), 17(20-3), 18(20-2), 19(20-1)

그럼 계산된 숫자의 크기에 따라서 a와 b의 순서가 sort()에 의해 재배열 되어
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20
가 나옵니다.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;every-와-some&#34;&gt;every() 와 some()&lt;/h2&gt;

&lt;h4 id=&#34;1-every&#34;&gt;1.every()&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;array.every(callbackFunction(currentValue, index, array), thisArg)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;every 함수는 배열의 &lt;code&gt;모든 요소&lt;/code&gt;가 callbackFunction 에서 true를 리턴해야 true를 리턴, 하나라도 false가 떨어지면 false를 리턴합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;every나 some 함수의 경우 배열내 값이 존재하는지 확인할때나 조건에 맞는(혹은 맞지 않는) 값이 있는지 확인 할 때 등 활용이 가능합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-some&#34;&gt;2.some()&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;array.some(callbackFunction(currentValue, index, array), thisArg)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;some 함수는 배열의 요소 중 &lt;code&gt;하나라도&lt;/code&gt; callbackFunction에서 true를 리턴하면 true를 리턴 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;every나 some 함수의 경우 배열내 값이 존재하는지 확인할때나 조건에 맞는(혹은 맞지 않는) 값이 있는지 확인 할 때 등 활용이 가능합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;every 와 some 의 차이점&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;every 와 some 메서드는 배열을 순회하면서 특정 조건을 배열의 값들이 만족시키는지 검사하는 메서드로서 호출한 배열이 결론적으로 조건을 만족시키는지(true), 만족시키지 못하는지(false)를 알려준다. every 와 some 의 차이는 every 가 배열의 모든 값이 조건을 만족해야, some 은 일부만 만족해도 true 를 return 한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;toc_86&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;2-dom&#34;&gt;2. Dom&lt;/h2&gt;

&lt;h2 id=&#34;toc_88&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;dom-이란&#34;&gt;Dom 이란 ?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// Dom을 이용해서 HTML문서를 제어할수 있다

// DOM 객체의 값 바꾸기

// ex1-1 document.getElementsByTagName()




document.getElementsByTagName() 
&amp;gt;&amp;gt;html에 있는 tag name 을 가져오는 명령이다.

var list = document.getElementsByTagName(&#39;h2&#39;) 
&amp;gt;&amp;gt;모든 h2를 list 라는 변수에 담아오겠다. 

태그 이름을 바꾸기 위해서는 

a
&amp;gt;&amp;gt; [h2,h2]

a[0]
&amp;gt;&amp;gt; &amp;lt;h2&amp;gt;hello 1&amp;lt;/h2&amp;gt;

a[1]
&amp;gt;&amp;gt; &amp;lt;h2&amp;gt;hello 2&amp;lt;/h2&amp;gt;
이렇게 배열안에 들어가 있다. 

a[1].innerHTML = &amp;quot;good morning&amp;quot;
heelo 2 &amp;gt;&amp;gt; good morning 으로 바뀐다. 

이것이 dom 의 역활 이다. 



// ex1-2 document.getElementsById()


var a = document.getElementsById(&amp;quot;main&amp;quot;)
&amp;gt;&amp;gt; main 아이디 값의 tag를 가져와서  a 변수에 담는다

a
&amp;gt;&amp;gt; &amp;lt;p id = main&amp;gt;hello jj &amp;lt;/p&amp;gt;

a.innerHTML = &amp;quot;hello John jung&amp;quot;

a

&amp;gt;&amp;gt;&amp;lt;p id = main&amp;gt;hello john jung&amp;lt;/p&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;버튼-만들기&#34;&gt;버튼 만들기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;함수를 이용해 버튼 만들기&amp;lt;/h1&amp;gt;
    
    
    // 1.value 를 지정하기 in HTML
    
    
    &amp;lt;input id = &amp;quot;input1&amp;quot; type =&amp;quot;text&amp;quot;&amp;gt;
    &amp;lt;button id =&amp;quot;button1&amp;quot;&amp;gt;cilck&amp;lt;/button&amp;gt;
    
    
    &amp;lt;script&amp;gt;
    
    // 2. 함수&amp;amp;변수를 만들어서 준비한다 
    
        var ret = function(){
            document.getElementById(&amp;quot;input1&amp;quot;);
            console.log(input1.value);
        }
    
        var button = document.getElementById(&amp;quot;button1&amp;quot;);
        
        
    // 3 .입력받을 ID 값을 받는 함수를 연결해준다.
       
        button1.onclick = ret; 

    /script&amp;gt;
    


&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;e-target-이란&#34;&gt;e.target 이란 ?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;event.target 와 event.target.parentNode 차이점&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
* e.target === 클릭된애
* e.target.parentNode === 클릭된애 부모태그 
* e.target.parentNode.parentNode === 클릭된애 부모의 부모태그

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;event.target 과 currentTarget 의 차이점&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
* event.target 은 마우스 클릭할때 발생되는 이벤트가 일어나는 곳을 말하고
* event.currentTarget 은 addEventListener 를발생시키는 대상 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-to-check-if-element-has-any-children&#34;&gt;How to check if element has any children ?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
if (element.firstChild) {
    // It has at least one
}

if (element.hasChildNodes()) {
    // It has at least one
}

if (element.childNodes.length &amp;gt; 0) { // Or just `if (element.childNodes.length)`
    // It has at least one
}

if (element.children.length &amp;gt; 0) { // Or just `if (element.children.length)`
    // It has at least one element as a child
}

if (element.firstElementChild) {
    // It has at least one element as a child
}

var hasChildElements, child;
hasChildElements = false;
for (child = element.firstChild; child; child = child.nextSibling) {
    if (child.nodeType == 1) { // 1 == Element
        hasChildElements = true;
        break;
    }
}

function hasChildElement(elm) {
    var child, rv;

    if (elm.children) {
        // Supports `children`
        rv = elm.children.length !== 0;
    } else {
        // The hard way...
        rv = false;
        for (child = element.firstChild; !rv &amp;amp;&amp;amp; child; child = child.nextSibling) {
            if (child.nodeType == 1) { // 1 == Element
                rv = true;
            }
        }
    }
    return rv;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;checkbox-안에-있는-value-값-얻기&#34;&gt;checkbox 안에 있는 value 값 얻기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;html&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;div class = &amp;quot;container&amp;quot;&amp;gt;
    
    &amp;lt;input type=&amp;quot;checkbox&amp;quot; class =&amp;quot;checks&amp;quot; value =&amp;quot;뜨거워&amp;quot;&amp;gt; hot
    &amp;lt;input type=&amp;quot;checkbox&amp;quot; class =&amp;quot;checks&amp;quot; value =&amp;quot;추워&amp;quot;&amp;gt; clod
    &amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;submitFun();return false;&amp;quot;&amp;gt;ok &amp;lt;/a&amp;gt;

&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


	function submitFun() {
		

		var checks = document.getElementsByClassName(&#39;checks&#39;)
		var str = &amp;quot;&amp;quot;;
		

		for (let i = 0; i &amp;lt; checks.length; i++ ){

			if (checks[i].checked === true ) {
 				str += checks[i].value + &amp;quot;&amp;quot;;
 			}
 		}
 		alert(str);
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;버튼-엔터키-작동-및-입력창-커서유지시키기&#34;&gt;버튼 엔터키 작동 및 입력창 커서유지시키기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;h1&amp;gt;this is coffee machine&amp;lt;h1&amp;gt;
&amp;lt;div id = &amp;quot;menu&amp;quot;&amp;gt;menu&amp;lt;/div&amp;gt;
&amp;lt;input id = &amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot; placeholder = &amp;quot;what drink?&amp;quot;&amp;gt;
&amp;lt;button id = &amp;quot;btn&amp;quot;&amp;gt;order&amp;lt;/button&amp;gt;
&amp;lt;ol id = &amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li class = &amp;quot;americano&amp;quot;&amp;gt;americano&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;latte&amp;quot;&amp;gt;latte&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;flatWhite&amp;quot;&amp;gt;flatWhite&amp;lt;/li&amp;gt;
&amp;lt;ol&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
// 버튼을 누르면 list 가 추가되는데 사용자를 위하여 엔터로 control 할수 있게 하고 커서가 계속 입력창에 깜빡이게 하는 방법이다. 

let coffeeList = document.querySelector(&amp;quot;#list&amp;quot;);
let coffeeInput = document.querySelector(&amp;quot;#input&amp;quot;);
let add = document.querySelector(&amp;quot;#btn&amp;quot;);
// form tag를 만들어 input 과 btn tags 를 넣는다.  
  let form = document.createElement(&amp;quot;form&amp;quot;);
  document.body.appendChild(form);
  form.appendChild(coffeeInput);
  form.appendChild(add);

// form tag에 이벤트를 발생시킨다. 
// form 과 &amp;quot;submit&amp;quot; 의 기본동작은 엔터를 첬을때 새로고침 or 다른페이지로 넘어가게 되어있다. 
// 그것을 막기 위해서 function(event) 설정하고  event.preventDefalut() 넣어주면 된다. 

form.addEventListener(&#39;submit&#39;,function(event){
    event.preventDefault();
  let newList = document.createElement(&amp;quot;li&amp;quot;);  
  newList.setAttribute(&amp;quot;class&amp;quot;,&amp;quot;new-list&amp;quot;);
  coffeeList.appendChild(newList);
  newList.textContent = coffeeInput.value;
  coffeeInput.focus(); // input tag 에 함수를 넣는다. 입력후 계속 입력할수 있게 해준다. 
  
})




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;addeventlistener-사용하기&#34;&gt;addEventListener 사용하기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;this is coffee machine&amp;lt;h1&amp;gt;
&amp;lt;div id = &amp;quot;menu&amp;quot;&amp;gt;menu&amp;lt;/div&amp;gt;
&amp;lt;input id = &amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot; placeholder = &amp;quot;what drink?&amp;quot;&amp;gt;
&amp;lt;button id = &amp;quot;btn&amp;quot;&amp;gt;order&amp;lt;/button&amp;gt;
&amp;lt;ol id = &amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li class = &amp;quot;americano&amp;quot;&amp;gt;americano&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;latte&amp;quot;&amp;gt;latte&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;flatWhite&amp;quot;&amp;gt;flatWhite&amp;lt;/li&amp;gt;
&amp;lt;ol&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1. addEventListener
// 버튼을 누르면 menu 버튼이 한글로 바뀜

let xxx = document.querySelector(&amp;quot;#btn&amp;quot;);
let menu = document.querySelector(&amp;quot;#menu&amp;quot;);

xxx.addEventListener(&#39;click&#39;, function(){
  menu.innerHTML = &amp;quot;메뉴&amp;quot;;
})

// 2 addEventListener 
// 버튼 누르면 리스트가 추가된다. 

let coffeeList = document.querySelector(&amp;quot;#list&amp;quot;);
let coffeeInput = document.querySelector(&amp;quot;#input&amp;quot;);
let add = document.querySelector(&amp;quot;#btn&amp;quot;);

add.addEventListener(&#39;click&#39;,function(){
  let newList = document.createElement(&amp;quot;li&amp;quot;)
  newList.setAttribute(&amp;quot;class&amp;quot;,&amp;quot;new-list&amp;quot;);
  coffeeList.appendChild(newList);
  newList.textContent = coffeeInput.value;
})



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;e-target-와-e-target-parentnode-or-currenttarget의-차이점&#34;&gt;e.target 와 e.target.parentNode or currentTarget의 차이점&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
* e.target === 클릭된애
* e.target.parentNode === 클릭된애 부모태그 
* e.target.parentNode.parentNode === 클릭된애 부모의 부모태그

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;event-target-과-currenttarget-의-차이점&#34;&gt;event.target 과 currentTarget 의 차이점&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
* event.target 은 마우스 클릭할때 발생되는 이벤트가 일어나는 곳을 말하고
* event.currentTarget 은 addEventListener 를발생시키는 대상 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;버튼-엔터키-작동-및-입력창-커서유지시키기-1&#34;&gt;버튼 엔터키 작동 및 입력창 커서유지시키기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;h1&amp;gt;this is coffee machine&amp;lt;h1&amp;gt;
&amp;lt;div id = &amp;quot;menu&amp;quot;&amp;gt;menu&amp;lt;/div&amp;gt;
&amp;lt;input id = &amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot; placeholder = &amp;quot;what drink?&amp;quot;&amp;gt;
&amp;lt;button id = &amp;quot;btn&amp;quot;&amp;gt;order&amp;lt;/button&amp;gt;
&amp;lt;ol id = &amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li class = &amp;quot;americano&amp;quot;&amp;gt;americano&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;latte&amp;quot;&amp;gt;latte&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;flatWhite&amp;quot;&amp;gt;flatWhite&amp;lt;/li&amp;gt;
&amp;lt;ol&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
// 버튼을 누르면 list 가 추가되는데 사용자를 위하여 엔터로 control 할수 있게 하고 커서가 계속 입력창에 깜빡이게 하는 방법이다. 

let coffeeList = document.querySelector(&amp;quot;#list&amp;quot;);
let coffeeInput = document.querySelector(&amp;quot;#input&amp;quot;);
let add = document.querySelector(&amp;quot;#btn&amp;quot;);
// form tag를 만들어 input 과 btn tags 를 넣는다.  
  let form = document.createElement(&amp;quot;form&amp;quot;);
  document.body.appendChild(form);
  form.appendChild(coffeeInput);
  form.appendChild(add);

// form tag에 이벤트를 발생시킨다. 
// form 과 &amp;quot;submit&amp;quot; 의 기본동작은 엔터를 첬을때 새로고침 or 다른페이지로 넘어가게 되어있다. 
// 그것을 막기 위해서 function(event) 설정하고  event.preventDefalut() 넣어주면 된다. 

form.addEventListener(&#39;submit&#39;,function(event){
    event.preventDefault();
  let newList = document.createElement(&amp;quot;li&amp;quot;);  
  newList.setAttribute(&amp;quot;class&amp;quot;,&amp;quot;new-list&amp;quot;);
  coffeeList.appendChild(newList);
  newList.textContent = coffeeInput.value;
  coffeeInput.focus(); // input tag 에 함수를 넣는다. 입력후 계속 입력할수 있게 해준다. 
  
})




&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;onclick-동작하는-원리&#34;&gt;onclick 동작하는 원리&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

&amp;lt;h1&amp;gt;this is coffee machine&amp;lt;h1&amp;gt;
&amp;lt;div id = &amp;quot;menu&amp;quot;&amp;gt;menu&amp;lt;/div&amp;gt;
&amp;lt;input id = &amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot; placeholder = &amp;quot;what drink?&amp;quot;&amp;gt;
&amp;lt;button id = &amp;quot;btn&amp;quot;&amp;gt;order&amp;lt;/button&amp;gt;
&amp;lt;ol id = &amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li class = &amp;quot;americano&amp;quot;&amp;gt;americano&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;latte&amp;quot;&amp;gt;latte&amp;lt;/li&amp;gt;
  &amp;lt;li class = &amp;quot;flatWhite&amp;quot;&amp;gt;flatWhite&amp;lt;/li&amp;gt;
&amp;lt;ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1. onlick 동작하는원리 
// menu 버튼을 누르면 menu 가 red 로 변함  

let xxx = document.querySelector(&amp;quot;#btn&amp;quot;);

xxx.onclick = function() {
  document.querySelector(&amp;quot;#menu&amp;quot;).style.background=&amp;quot;red&amp;quot;;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;textcontent-와-value-의-차이점&#34;&gt;textContent 와 value 의 차이점&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
tag 안에 들어가는 글자내용은  textcontent 이고
input 안에 들어가있는 글자내용은 value 이다 


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;버튼누르면-새로운-글-추가&#34;&gt;버튼누르면 새로운 글 추가&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;

  &amp;lt;button id=&amp;quot;clickbtn&amp;quot;&amp;gt;new_tweet&amp;lt;/button&amp;gt;
    
    &amp;lt;div id=&amp;quot;comments&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

var DATA = [
  { user: &#39;ingikim&#39;, message: &#39;Welcome to Code States #codestates&#39;, created_at: &#39;2019-01-03 12:30:20&#39; },
  { user: &#39;satya&#39;, message: &#39;this is test message #pair #programming&#39;, created_at: &#39;2019-01-04 18:30:20&#39; },
  { user: &#39;sundar&#39;, message: &#39;code now! #work #hard&#39;, created_at: &#39;2019-01-05 07:30:20&#39; },
  { user: &#39;steve&#39;, message: &#39;Stay hungry, and stay foolish&#39;, created_at: &#39;2015-01-03 12:30:20&#39; },
  { user: &#39;tim&#39;, message: &#39;education for real world&#39;, created_at: &#39;2019-01-04 18:30:20&#39; }
];

var randomUser = [&#39;ingikim&#39;, &#39;satya&#39;, &#39;sundar&#39;, &#39;steve&#39;, &#39;tim&#39;, &#39;jeff&#39;];
var randomMessage = [
  &#39;이 헌법공포 당시의 국회의원의 임기는 제1항에 의한 국회의 최초의 집회일 전일까지로 한다. 감사원은 원장을 포함한 5인 이상 11인 이하의 감사위원으로 구성한다.&#39;,
  &#39;헌법재판소의 조직과 운영 기타 필요한 사항은 법률로 정한다. 모든 국민은 자기의 행위가 아닌 친족의 행위로 인하여 불이익한 처우를 받지 아니한다.&#39;,
  &#39;헌법개정은 국회재적의원 과반수 또는 대통령의 발의로 제안된다. 국가는 재해를 예방하고 그 위험으로부터 국민을 보호하기 위하여 노력하여야 한다.&#39;,
  &#39;모든 국민은 직업선택의 자유를 가진다. 군인은 현역을 면한 후가 아니면 국무총리로 임명될 수 없다. 행정권은 대통령을 수반으로 하는 정부에 속한다.&#39;,
  &#39;민주평화통일자문회의의 조직·직무범위 기타 필요한 사항은 법률로 정한다. 국가는 농·어민과 중소기업의 자조조직을 육성하여야 하며, 그 자율적 활동과 발전을 보장한다.&#39;,
  &#39;국회는 국정을 감사하거나 특정한 국정사안에 대하여 조사할 수 있으며, 이에 필요한 서류의 제출 또는 증인의 출석과 증언이나 의견의 진술을 요구할 수 있다.&#39;,
  &#39;인간이 얼음에 고행을 따뜻한 가장 이것이다. 꽃이 곧 동력은 끝에 동산에는 그것은 거선의 별과 인생의 것이다. 구하지 착목한는 스며들어 인생의 것이다.&#39;,
  &#39;새 가슴에 있는 만천하의 있다. 몸이 뜨거운지라, 청춘의 소리다.이것은 같으며, 피다. 설산에서 힘차게 옷을 피다. 놀이 그들의 인간의 주는 소금이라&#39;,
  &#39;귀는 우리는 피에 무엇이 이것이다. 구하지 우리는 그들은 약동하다. 따뜻한 발휘하기 사람은 충분히 사막이다.&#39;
]

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function generateNewTweet() {
  var tweet = {};
  tweet.user = randomUser[getRandomInt(0, randomUser.length)];
  tweet.message = randomMessage[getRandomInt(0, randomMessage.length)];
  tweet.created_at = new Date().format(); // 어떻게 하면 보기 좋은 형태로 나타낼 수 있을까요?
  return tweet;
}

Number.prototype.padLeft = function() {
  if(this &amp;lt; 10) {
    return &#39;0&#39; + String(this);
  }
  else {
    return String(this);
  }
}

Date.prototype.format = function() {
  var yyyy = this.getFullYear();
  var month = (this.getMonth() + 1).padLeft();
  var dd = this.getDate().padLeft();
  var HH = this.getHours().padLeft();
  var mm = this.getMinutes().padLeft();
  var ss = this.getSeconds().padLeft();

  var format = [yyyy, month, dd].join(&#39;-&#39;) + &#39; &#39; + [HH, mm, ss].join(&#39;:&#39;);
  return format;
}





//2.check_new_tweet! 
function myFunction() {
    let  array = [];
    let obj = generateNewTweet();

    array.push(&amp;quot;&amp;lt;div class=&#39;comment&#39;&amp;gt;&amp;quot;
         + &amp;quot;&amp;lt;div class=&#39;username&#39;&amp;gt;&amp;quot;  + obj.user + &amp;quot;&amp;lt;/div&amp;gt;&amp;quot; 
         + &amp;quot;&amp;lt;div&amp;gt;&amp;quot; + obj.message + &amp;quot;&amp;lt;/div&amp;gt;&amp;quot;
         + &amp;quot;&amp;lt;div&amp;gt;&amp;quot; + obj.created_at + &amp;quot;&amp;lt;/div&amp;gt;&amp;quot;
         + &amp;quot;&amp;lt;/div&amp;gt;&amp;quot;);

    
  comments.innerHTML = array + comments.innerHTML;

}




let Button = document.querySelector(&#39;#clickbtn&#39;);

function randomTweet() {
    clickbtn.onclick = function() {
        myFunction();
    }
}

randomTweet();





&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;script-위치&#34;&gt;script 위치&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

//Html 파일에서 script 를 head 안에 넣으면 script 안에 써있는 코드들이 실행이 안된다 !

//하지만 script 안에 있는 코드들을 실행 시키려면 


window.onload = function () { } // 실행하고싶은 코드넣으면 실행할수 있다. 



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insertbefore&#34;&gt;insertBefore()&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// html

&amp;lt;h1&amp;gt;test&amp;lt;/h1&amp;gt; 
  
&amp;lt;ul id=&amp;quot;subjects&amp;quot;&amp;gt; 
        &amp;lt;li&amp;gt;C&amp;lt;/li&amp;gt; 
        &amp;lt;li&amp;gt;Python&amp;lt;/li&amp;gt; 
&amp;lt;/ul&amp;gt; 
  
  
// js

  &amp;lt;script&amp;gt;
  
  function myGeeks() { 
            var newItem = document.createElement(&amp;quot;li&amp;quot;); 
            var textnode = document.createTextNode(&amp;quot;Java&amp;quot;); 
            newItem.appendChild(textnode); 
  
            var list = document.getElementById(&amp;quot;subjects&amp;quot;); 
            list.insertBefore(newItem, list.childNodes.lastChild); // 마지막으로 삽입하고 싶으면 lastChild
            
            list.insertBefore(newItem, list.childNodes[0]); //  첫번째로 삽입하고 싶으면 [0] 
            } 

 myGeeks();
  
  &amp;lt;/script&amp;gt;

// html

// Java     // 삽입 되었다. 
// C
// Python





&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_104&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;3-studying-notes&#34;&gt;3. Studying_Notes&lt;/h2&gt;

&lt;h2 id=&#34;toc_106&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/h2&gt;

&lt;h2 id=&#34;타이머-사용하기&#34;&gt;타이머 사용하기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;setTimeout(callback, millisecond)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;내가 설정한 시간 후에 함수를 실행;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
setTimeout(function() {
  console.log(&#39;1초후 이것이 실행된다&#39;);
}, 1000);


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;setInterval(callback, millisecond)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;내가 설정한 시간마다 계속 실행되는 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
setInterval(function() {
  console.log(&#39;1초마다 실행&#39;);
}, 1000);


&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;clearInterval(timerID)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;반복 실행중인 타이머를 종료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let timer = setInterval(function() {
  console.log(&#39;1초마다 실행&#39;);
}, 1000);


clearInterval(timer); // 실행되는 순간 내가 만든 함수는 멈춘다. 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;객체-숫자-계산-하는-방법&#34;&gt;객체 숫자 계산 하는 방법&lt;/h2&gt;

&lt;h4 id=&#34;how-to-count-the-number-of-properties-of-the-javascript-object&#34;&gt;How to Count the Number of Properties of the JavaScript Object&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// While working with JavaScript, I come across a requirement to count a number of properties in a JavaScript object. I found two ways to find the number of properties in an object. They are as follows:




Consider an object, &amp;quot;cat,&amp;quot; as demonstrated below:

var cat = {
    name: &#39;foo&#39;,
    age: 9
}


// You can find a number of properties by iterating in a for loop and update counter, as shown in the below listing:

let count = 0;
for (var c in cat) {
    count = count + 1;
}
console.log(count);// 2

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Above code will print &amp;ldquo;2&amp;rdquo; as the output.&lt;/p&gt;

&lt;p&gt;The above approach not only prints the object&amp;rsquo;s own enumerable properties, but it also prints properties of objects to which it is linked. To further understand it, let us consider the below listing:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var animal = {
    canRun: true
}
var cat = {
    name: &#39;foo&#39;,
    age: 9
}
cat.__proto__ = animal;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;There are two objects, cat andanimal, and the cat object is linked to an animal object using the &lt;strong&gt;proto&lt;/strong&gt; property. Now, when you use a for loop to iterate and count a number of properties, it will also count the enumerable properties of the animal object. Therefore, the code listing below will print &amp;ldquo;3.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var animal = {
    canRun: true
}
var cat = {
    name: &#39;foo&#39;,
    age: 9
}
cat.__proto__ = animal;
let count = 0;
for (var c in cat) {
    count = count + 1;
}
console.log(count);// 3

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;A JavaScript for loop will iterate through all the linked properties of the object.&lt;/p&gt;

&lt;p&gt;To count the object&amp;rsquo;s own enumerable properties, you may consider using another approach, Object.keys(), which only enumerates the object&amp;rsquo;s own enumerable properties. It does not enumerate the object&amp;rsquo;s linked properties.&lt;/p&gt;

&lt;p&gt;Moving forward, let us again consider the cat object which is linked to animal object and count the number of properties using Object.keys:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
var animal = {
    canRun: true
}
var cat = {
    name: &#39;foo&#39;,
    age: 9
}
cat.__proto__ = animal;
var count = Object.keys(cat).length;
console.log(count);

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Now you will get &amp;ldquo;2&amp;rdquo; printed as the output.&lt;/p&gt;

&lt;p&gt;Object.keys only enumerates the object&amp;rsquo;s own enumerable properties.&lt;/p&gt;

&lt;p&gt;If the object&amp;rsquo;s property enumerable is set to false, then it is not a member of the Object.keys array. Let us again consider the cat object and set its name property enumerable to false.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var cat = {
    name: &#39;foo&#39;,
    age: 9
}
Object.defineProperty(cat, &#39;name&#39;, { enumerable: false });

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, when you use Object.keys to find a number of properties, it will count only one.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var count = Object.keys(cat).length;
console.log(count);  // print 1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In closing, these are the two ways that you can use to find the number of properties in a JavaScript object&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;prototype를-사용해-ininstance-객체에-키값-속성값-추가하는법&#34;&gt;prototype를 사용해 ininstance 객체에 키값 속성값 추가하는법&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// prototype를 사용해 모든 instance 객체에 property와 method 추가하는 법을 확인합니다

function objFunc(para) { // 객체를 담고있는 함수를 먼저 만든다.
      this.age = para; // key 는 name / property는 para  &amp;lt; 아직 모른다.
    }

    let newObj = new objFunc(33); // para 값이 33이 됨 따라서 info1 = { age:33 }
    newObj.name = &amp;quot;John&amp;quot;; //  // 함수안에 infor1 객체안에 키값이랑 property 를 추가한다.

newObj //&amp;gt;&amp;gt; objFunc = { age: 33 , name: &amp;quot;John&amp;quot; } name = &amp;quot;john&amp;quot; 이 추가됬다. 

// prototype 을 사용해서 추가하기

objFunc.prototype.text = function() { // 처음함수에 prototype을 넣는다.  그다음에 text라는 키값을 지정한다. 이키값은 함수이기도 하다. 그래서 키이면서도 함수인 text()가 실행되면 return값이 출력된다.  
	return &amp;quot;this is the stroy what I want to say to &amp;quot; + newObj.name; 
}

newObj.text(); // &amp;quot;this is the stroy what I want to say to john&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;객체안에-담겨있는-function-사용하기&#34;&gt;객체안에 담겨있는 function 사용하기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
  // 객체를 만들고 속성값에 text 내용을 출력할 함수를 만든다. 
  
 // 이름을 몇번 집어넣을지 num 라는 것을 Array(num+1)를 통해 만들고 join 메소드를 이용해 &amp;quot; &amp;quot; 띄어쓰기를 한후 text 를 출력한다.

obj1 = {
      name1 : &amp;quot;john&amp;quot;,
      name2: &amp;quot;tim&amp;quot;,
      funcSum: function (num) {
        return &amp;quot;They are &amp;quot; + this.name1 + &amp;quot; and the&amp;quot; +
        Array(num + 1).join(&amp;quot; &amp;quot; + this.name2);     
      }
    };

let massage = obj1.funcSum(2) //  객체안에 있는 속성인 funcSum(2) 호출한다.

console.log(massage) // &amp;gt;&amp;gt; &amp;quot;They are john and the tim tim&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;함수가-객체의-키값으로-사용&#34;&gt;함수가 객체의 키값으로 사용&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 객체와 함수를 이용한다.
// 장점 객체안에 키값을 자유롭게 사용할수 있다.

let funcGood = function (elem) {
      return elem + &amp;quot; is good man!&amp;quot;;
    };
    let obj1 = { name: funcGood };
    

obj1.name(&amp;quot;John&amp;quot;) // &amp;gt;&amp;gt; john is good man!

// 만약 obj.name 이 다른 기능을 가지고있는 함수를 대입하면..

let funcBad = function (elem) {
      return elem + &amp;quot; is good bad!&amp;quot;;
    };

obj.name = funcBad 

// 기존에 있던 obj.name 기능은 사라지고 obj.name 의 기능은

obj.name(&amp;quot;john&amp;quot;) // john is good bad!


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rest-parameter&#34;&gt;rest parameter&lt;/h2&gt;

&lt;h4 id=&#34;parameter-지정하는-법&#34;&gt;parameter 지정하는 법&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// arguments 이용 

function getMax() {
  let max = arguments[0] 
  for (let i = 0; i &amp;lt; arguments.length; i ++ ) {
    if(max &amp;lt; arguments[i]) {
       max = arguments[i] 
    }
  }
   return max;
}

// args 이용

function getMax(a,b , ...args) {
  let max = args[0] 
  for (let i = 0; i &amp;lt; args.length; i ++ ) {
    if(max &amp;lt; args[i]) {
       max = args[i] 
    }
  }
   return max;
}




&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function timeToGoHome(distance, speed = 20 ) { 

	return distance + speed;
}

timeToGoHome(10);

// 30

timeToGoHome(10,10); // 두번째 값인 지정했던 speed 값이 변한다. 

// 20



 // 만약 첫번째 값을 지정하고 출력하고 싶다면

function timeToGoHome(distance = 20, speed) { 

timeToGoHome(undefined,20) ;
// 40
 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;making-guid&#34;&gt;Making_GUID&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
JavaScript
Its easy to make GUIDs in JavaScript. Below is code to get strings that look like GUIDs. This code just random GUIDs they are not claimed to be unique. Don&#39;t use these if its very important.

function S4() {
    return (((1+Math.random())*0x10000)|0).toString(16).substring(1); 
}
 
// then to call it, plus stitch in &#39;4&#39; in the third group
guid = (S4() + S4() + &amp;quot;-&amp;quot; + S4() + &amp;quot;-4&amp;quot; + S4().substr(0,3) + &amp;quot;-&amp;quot; + S4() + &amp;quot;-&amp;quot; + S4() + S4() + S4()).toLowerCase();


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;할당-연산자&#34;&gt;할당 연산자&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 3 가지가 똑같은 것이다.  할당연산자

count = count + 1 
coutt+= 
count++

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;랜덤-숫자-원하는-수대로-뽑기&#34;&gt;랜덤 숫자 원하는 수대로 뽑기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// for 문을 이용한 랜덤 숫자 원하는수대로 뽑기 
for ( let i = 0 ; i &amp;lt;= 30; i = i + 1 ) { 
  String(Math.random().toFixed(i).split(&#39;&#39;).slice(2).join(&#39;&#39;)) // slice(2) 를 이용해 0과 . 을 제거한 나머지 숫자들을 출력한다.  
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;랜덤글자-가져오기&#34;&gt;랜덤글자 가져오기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var randomUser = [&#39;ingikim&#39;, &#39;satya&#39;, &#39;sundar&#39;, &#39;steve&#39;, &#39;tim&#39;, &#39;jeff&#39;];
var randomMessage = [
  &#39;이 헌법공포 당시의 국회의원의 임기는 제1항에 의한 국회의 최초의 집회일 전일까지로 한다. 감사원은 원장을 포함한 5인 이상 11인 이하의 감사위원으로 구성한다.&#39;,
  &#39;헌법재판소의 조직과 운영 기타 필요한 사항은 법률로 정한다. 모든 국민은 자기의 행위가 아닌 친족의 행위로 인하여 불이익한 처우를 받지 아니한다.&#39;,
  &#39;헌법개정은 국회재적의원 과반수 또는 대통령의 발의로 제안된다. 국가는 재해를 예방하고 그 위험으로부터 국민을 보호하기 위하여 노력하여야 한다.&#39;,
  &#39;모든 국민은 직업선택의 자유를 가진다. 군인은 현역을 면한 후가 아니면 국무총리로 임명될 수 없다. 행정권은 대통령을 수반으로 하는 정부에 속한다.&#39;,
  &#39;민주평화통일자문회의의 조직·직무범위 기타 필요한 사항은 법률로 정한다. 국가는 농·어민과 중소기업의 자조조직을 육성하여야 하며, 그 자율적 활동과 발전을 보장한다.&#39;,
  &#39;국회는 국정을 감사하거나 특정한 국정사안에 대하여 조사할 수 있으며, 이에 필요한 서류의 제출 또는 증인의 출석과 증언이나 의견의 진술을 요구할 수 있다.&#39;,
  &#39;인간이 얼음에 고행을 따뜻한 가장 이것이다. 꽃이 곧 동력은 끝에 동산에는 그것은 거선의 별과 인생의 것이다. 구하지 착목한는 스며들어 인생의 것이다.&#39;,
  &#39;새 가슴에 있는 만천하의 있다. 몸이 뜨거운지라, 청춘의 소리다.이것은 같으며, 피다. 설산에서 힘차게 옷을 피다. 놀이 그들의 인간의 주는 소금이라&#39;,
  &#39;귀는 우리는 피에 무엇이 이것이다. 구하지 우리는 그들은 약동하다. 따뜻한 발휘하기 사람은 충분히 사막이다.&#39;
]


// getRandomInt(min,max)  이용해 인자만큼 가져오는 방법


function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}


// 각각 user or message or time 을 객체안에 넣는다.
// 여기서 들어가는 요소들은 랜덤하게 들어가게 된다. 

function generateNewTweet() {
  var tweet = {};
  tweet.user = randomUser[getRandomInt(0, randomUser.length)]; 
  tweet.message = randomMessage[getRandomInt(0, randomMessage.length)];
  tweet.created_at = new Date().format(); 
  return tweet;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-current-data-time-in-js&#34;&gt;Get Current Data &amp;amp; Time in JS&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

var today = new Date(); // Data 가져온다. 
var date = today.getFullYear()+&#39;-&#39;+(today.getMonth()+1)+&#39;-&#39;+today.getDate(); // 날짜
var time = today.getHours() + &amp;quot;:&amp;quot; + today.getMinutes() + &amp;quot;:&amp;quot; + today.getSeconds(); // 시간 

var dateTime = date+&#39; &#39;+time;  

dateTime // 2019-9-5 13:2:48&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;block-스코프와-function-스코프의-차이&#34;&gt;block 스코프와 function 스코프의 차이&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// block 스코프

for (let i = 0;  i &amp;lt; 5; i = i + 1) {
	console.log(i); //  0,1,2,3,4  출력된다. 
}

console.log(i) //  ReferenceError 출력 이유 : i라는 변수는 block let = i 선언되었을때 i 의 변수는  block 안에 제한 되기 때문이다.


// 
for (var i = 0;  i &amp;lt; 5; i = i + 1) {
	console.log(i); //  0,1,2,3,4  출력된다. 
}
console.log(i) // 5   이유: var 변수를 지정했을때 block의 범위를 넘어선다. 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;var-or-let-변수를-사용한-함수중-어던것이-에러&#34;&gt;var or let 변수를 사용한 함수중 어던것이 에러??&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Note_files/Screen Shot 2019-08-28 at 4.41.59 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function greetSomeone (firstName ) { 
  let time = &amp;quot;night&amp;quot;;
  
  if (time === &amp;quot;night&amp;quot;) {         
    let greeting = &amp;quot;Good Night&amp;quot;; ////////// let greeting block 안에 갇혀 있다. 이 block 를 벗어나는 순간 효력을 잃는 다. 
  }
  
  
  return greeting + &#39; &#39; + firstName;  ///  greeting 실행되지 않는다 
}

greetSomeone(&#39;steve&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;var-and-let-and-const&#34;&gt;var and let and const&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Note_files/Screen Shot 2019-08-28 at 5.37.46 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;strict-mode&#34;&gt;Strict Mode&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// 변수를 안전하게 쓰기위한 “use strict”

`use strict` //  처음 시작에 이렇게 달아둔다.

function showAge() {
  arr = [1234];     //  선언되지 않는 변수가 실행되지 않게 해준다. 
console.log(arr);
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;다중배열-하나로-합치기&#34;&gt;다중배열 하나로 합치기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;재귀로 한 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function flatten(nestedArray, result) {


     // 재귀를 이용한것 

     result = [];
     function flatarr(nestedArray) {
       for(let i = 0; i &amp;lt; nestedArray.length; i++) {
         if(!Array.isArray(nestedArray[i])) {
           result = result.concat(nestedArray[i])
         } else {
           flatarr(nestedArray[i]);
         }
       }
     } flatarr(nestedArray);
     return result;
   };




&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;for 문으로 한방법&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function flatten(nestedArray) {
    //[1, [2], [3, [[[4]]]]]
    //oneflat([1, [2], [3, [[[4]]]]])
    // result = [1, 2, 3, [[[4]]]]
    // result = [1, 2, 3, 4]
    let oneflat = function(array) {
      let resultArr = []
      for (let i in array) {
        if (Array.isArray(array[i])) {
          resultArr = resultArr.concat(array[i]);
        } else {
          resultArr.push(array[i]);
        }
      }
      return resultArr;
    }
    let isinArr = function(array) {
      for (let i in array) {
        if (Array.isArray(array[i])) {
          return true;
        }
      }
      return false;
    }
    while(isinArr(nestedArray)) {
      nestedArray = oneflat(nestedArray);
    }
    return nestedArray;
  };





&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;flat(Infinity)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
arr = [1, [2], [3, [[[4]]]]]

arr.flat(Infinity)

/// [1,2,3,4]

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function flatten(nestedArray, result) {

   let arr = [];
  let arr2 = [];
  if(Array.isArray(nestedArray)) {
    arr = nestedArray.join().split(&#39;,&#39;);
  }
  for(let i=0; i &amp;lt; arr.length; i++) {
    arr2.push(Number(arr[i]));
  }
  return arr2;
};

flatten([1, [2], [3, [[[4]]]]]) // 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;두개의-배열을-비교-및-출력&#34;&gt;두개의 배열을 비교 및 출력&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;filter() and indexOf()&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let filtered1 = [1, 2, 3, 4, 5, 12]
let filtered2 = [1, 2, 4, 8]

let result = filtered1.filter(function(val) {
  return filtered2.indexOf(val) !== -1;
  
reulst // [1, 2, 4] 중복된 값을 리턴한다. 
});

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;filter() and includes()&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let filtered1 = [1, 2, 3, 4, 5, 12]
let filtered2 = [1, 2, 4, 8]

let result = filtered1.filter((val) =&amp;gt; {
  return filtered2.includes(val);

})

result  // [1, 2, 4]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;underbar&#34;&gt;underBar&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
(function() {
  &#39;use strict&#39;;

  window._ = {};

  // argument로 무엇이 전달되든간에, 있는 그대로 리턴하세요.
  // 이 함수가 쓸데없어 보일지 모르겠지만, 기억하세요! - 만약 함수에 iterator가 필요하고,
  // 뭐라도 넘겨줘야 하는 상황에는 이 함수가 유용할 것입니다.
  _.identity = function(val) {
    return val;
  };

  /**
  * COLLECTIONS
  * ===========
  *
  * 이 섹션에서는 우리는 collection이라고 불리는 값들의 집합을 이용하는 함수에 집중할겁니다.
  * JavaScript에서는 collection은 값들을 포함하며, 배열 혹은 객체가 될 수 있습니다.
  *
  *
  * IMPORTANT NOTE!
  * ===========
  *
  * .first 함수가 이미 구현되어 있습니다. 이 함수를 가이드 삼아, 앞으로 나올 함수들을 구현해보세요.
  * 사전에 이미 완료된 과제의 일부분을 만나게 될 경우, 반드시 코드를 잘 읽어보고 이해하고 넘어가십시오.
  * 이러한 과정을 지나친다면, 앞으로 구현하게 될 함수가 훨씬 더 어렵게 느껴질겁니다.
  */

  // 배열의 처음 n개의 element를 담은 배열을 리턴하세요.
  // 만일 n이 undefined일 경우, 단순히 첫번째 element를 리턴하세요.
  _.first = function(array, n) {
    return n === undefined ? array[0] : array.slice(0, n);
  };

  // first와 비슷하게, 마지막 n개의 element를 담은 배열을 리턴하세요.
  // 만일 n이 undefined일 경우, 단순히 마지막 element를 리턴하세요.
  _.last = function(array, n) {
      if ( n===0 ) {
        return [];
      }
      return n === undefined ? array.slice(-1).pop() : array.slice(-n);
  
    };
  // iterator(value, key, collection)를 collection의 각각의 key-value pair에 대해 호출하세요.
  // iterator는 함수로 전달되며, 쉽게 말해 반복해서 실행하는 함수입니다.
  // collection으로 배열과 객체를 다 받을 수 있어야 합니다.
  // 참고로 배열의 value는 element이며, key는 index입니다.
  //
  // Note: _.each 는 아무런 값도 리턴하지 않습니다.
  // 다만 단순히 iterator 함수를 전달되는 collection의 각 항목에 대해 실행할 뿐입니다.
  //
  // Note 2: 이 문제를 풀기 위해서는 여러분이 spec 디렉토리에 있는 테스트 케이스의 요구사항을 잘 살펴볼 필요가 있습니다.
  // 실제로 어떻게 사용되는지 각 테스트 케이스 항목에 잘 나와 있습니다.
  _.each = function(collection, iterator) {
    if (Array.isArray(collection)) {
      for (let i = 0; i &amp;lt; collection.length; i++) {
        // iterator(value, key, collection)
        iterator(collection[i], i, collection);
      }
    } else {
      for (let key in collection) {
        iterator(collection[key], key, collection);
      }
    }
  };

  // target으로 전달되는 값이 array에서 발견되면, 그 index를 리턴하세요.
  // 만일 array에서 발견할 수 없다면 -1을 리턴하세요.
  _.indexOf = function(array, target) {
    // TIP: Here&#39;s an example of a function that needs to iterate, which we&#39;ve
    // implemented for you. Instead of using a standard `for` loop, though,
    // it uses the iteration helper `each`, which you will need to write.
    var result = -1;

    _.each(array, function(item, index) {
      if (item === target &amp;amp;&amp;amp; result === -1) {
        result = index;
      }
    });

    return result;
  };

  // 테스트 함수를 통과하는 모든 element를 담은 배열을 리턴하세요.
  _.filter = function(collection, test) {

    let result = [];
    for (let i = 0; i &amp;lt; collection.length; i ++  ) {
      if (test(collection[i])) {
       result.push(collection[i]);
      }

    }
  return result;
  
  }

  // 테스트 함수를 통과하지 않는 모든 element를 담은 배열을 리턴하세요.
  _.reject = function(collection, test) {
    // TIP: see if you can re-use _.filter() here, without simply
    // copying code in and modifying it

    let result = [];
    for (let i = 0; i &amp;lt; collection.length; i ++  ) {
      if (!test(collection[i])) {
        result.push(collection[i]);
      }
    }

    return result;
  };

  // element가 중복되지 않는 새로운 array를 만드세요.
  _.uniq = function(array) {


    // 1. Array new Set
    
    // let newArr = array.slice(); // 복제 하고 
    // let result = new Set(newArr); // obj 로 바뀐다. 바뀌는 이유는?

    // return [...result];
    // } 

    // // return [result] //  실행되지 않는다.  이유는 obj으로 출력되기 때문.


    
    
    // 2 Array.from() 

    return Array.from(new Set(array));
    }



    // 3.reduce() xxx 값은 출력되는데 데스트 통과는 못함
       
    // array.reduce(function(unique, item){
    //     if (unique.includes(item)){
    //     return unique;
    //       } else {
    //     return [...unique,item];
    //     }
    //   },[]);


    // }


      // const array = [&#39;0&#39;, 1, 2, &#39;0&#39;, &#39;0&#39;, 3];
      // array.reduce((unique, item) =&amp;gt; {
      //   console.log(
      //     // a. Item
      //     item,
      //     // b. Final Array (Accumulator)
      //     unique,
      //     // c. 조건(이 조건이 false여야만 값이 푸시된다
      //     unique.includes(item),
      //     // d. Reduce Function Result
      //     unique.includes(item) ? unique : [...unique, item],
      //   );
      //   return unique.includes(item) ? unique : [...unique, item]
      // }, []); // 초기 Accumulator 는 빈 array 이다
      // }

  // iterator를 각 element에 적용한 결과를 담은 새로운 array를 리턴하세요.

  _.map = function(collection, iterator) {
    // map() is a useful primitive iteration function that works a lot
    // like each(), but in addition to running the operation on all
    // the members, it also maintains an array of results.

// collection.map(iterator(value, key, collection)){
    let newArr = [];  
  
      for (let i = 0; i &amp;lt; collection.length; i ++ ){
        newArr.push(iterator(collection[i]));
      } 
      return newArr;
  }

  // 객체의 배열을 가져와서, 그 안에 있는 특정 속성의 값의 배열을 리턴하세요.
  // 예를 들어, people이라는 객체가 담긴 배열을 가져와서, 그들의 나이만 리턴할 수 있어야 합니다.


  _.pluck = function(collection, key) {
    // TIP: map is really handy when you want to transform an array of
    // values into a new array of values. _.pluck() is solved for you
    // as an example of this.
    
    
    // return collection.map(function(item){
    
    // return item[key] 

    // })

    return _.map(collection, function(item) {
      return item[key];
    });
  };

  // 각 항목에 대해 iterator(accumulator, item)를 반복적으로 호출하여, Reduces an array to a single value by repetitively calling
  // 하나의 값으로 줄입니다. accumulator는 누적값으로, 이전 iterator 호출의 반환값이어야 합니다.
  //
  // reduce에 대한 세번째 argument로 초기값을 전달 할 수 있습니다.
  // 만일 초기값이 전달되지 않으면, 첫번재 element가 accumulator로 사용되며, iterator에 전달되지 않습니다.
  // 즉, 초기값이 전달되지 않은 경우, iterator는 두번째 element로부터 시작합니다.
  //
  // 예제:
  //   const numbers = [1,2,3];
  //   const sum = _.reduce(numbers, function(total, number){
  //     return total + number;
  //   }, 0); // 6이 리턴됩니다
  //
  //   const identity = _.reduce([5], function(total, number){
  //     return total + number * number;
  //   }); // 5가 리턴됩니다, 전달한 iterator와 관계없이, 첫번째 element가 즉시 사용됩니다.
  
  _.reduce = function(collection, iterator, accumulator) {
     
     // 1. 내가 생각 방법
      let i=0;
      if (accumulator === undefined) {
        accumulator = collection[0];
        i++;
      }
      for(i; i&amp;lt;collection.length; i++) {
        accumulator = iterator(accumulator, collection[i]);
      }
      return accumulator;
    }
  // accumulator가 undefined면 : accumulator에게 첫 번째 collection값을 넣고,
  // 그 후 i++를 통해 collection[0]이 아닌 collection[1]부터 iterator가 돌아감
  // 
  
  
  // 2. 지훈씨 생각한 방법
  // for(let i=0; i&amp;lt;collection.length; i++) {
  //     if (accumulator === undefined) {
  //         accumulator = collection[0];
  //     } else {
  //         accumulator = iterator(accumulator, collection[i]);
  //     }
  // }
  // accumulator가 undefined면 : accumulator에게 첫 번째 collection값을 넣고,
  // if문에 걸리지 않은 iterator(accumulator, collection[0])은 pass함
  // 그 후 정상적으로 collection[1]부터 iterator가 돌아감
  // 마지막
  // return accumulator;
// }

  // 배열 또는 객체가 주어진 값을 포함하는지 체크합니다. (`===` 연산자를 사용해서 판단합니다.)
  _.contains = function(collection, target) {
 

    for (let i in collection ) {
      if (collection[i] === target ){
        return true
        } 
      }
      return false;
  }

    // 다른 깔끔한 방법
    // each 방법을 써서..

    // if (Array.isArray(collection)) {
    //   for (let i = 0; i &amp;lt; collection.length; i ++  ) {
    //     if (collection[i] === target) {  
    //       return true;
    //     } else {
    //       return false;
    //     }
    //   }
    // } else {
    //   for (let prop in collection) {
    //     if (collection[prop] === target) { 
    //       return true;
    //     } else {  
    //       return false;
    //     }
    //   }
    // } 
      



  // 모든 element가 iterator에 의해 truthy한지 체크합니다.
  _.every = function(collection, iterator) {
  
  // function every(collection,iterator)
  // collection.every(terator(value, key, collection)) ???
  
    if(iterator === undefined) { // 이것을 왜하는지 ?
      for(let i = 0 ; i &amp;lt; collection.length ; i++) {
        if(Boolean(collection[i]) === false) {
          return false;
        }  
      }
    } else if (iterator) { // 이것은 왜? 
      for (let j = 0 ; j &amp;lt; collection.length ; j++) {
        if (Boolean(iterator(collection[j])) === false) {
          return false;
        }
      }
    } return true;
  };

        // ??


//   if(collection.length !== 0){
//     if(iterator !== undefined){
//       arr = _.map(collection, function(ele){
//         return Boolean(iterator(ele));
//       });
//       arr = _.filter(arr, function(ele){
//         return ele === false;
//       });
//       return !(_.contains(arr, false));
//     } else {
//       arr = _.filter(collection, function(ele){
//         return ele === false;
//       });
//       return !(_.contains(arr, false));
//     }
//   } else {
//     return true;
//   }
// };



  // element가 하나라도 iterator에 의해 truthy한지 체크합니다.
  // iterator가 없다면, element 그 자체가 truthy한지 체크하세요.
  _.some = function(collection, iterator) {

    if(iterator === undefined) { // 이것을 왜하는지 ?
      for(let i = 0 ; i &amp;lt; collection.length ; i++) {
        if(Boolean(collection[i]) === true) {
          return true;
        }  
      }
    } else if (iterator) { // 이것은 왜? 
      for (let j = 0 ; j &amp;lt; collection.length ; j++) {
        if (Boolean(iterator(collection[j])) === true) {
          return true;
        }
      }
    } return false;
  };


  /**
  * OBJECTS
  * =======
  *
  * 이 섹션에서는, 객체를 서로 합쳐주는 몇개의 도우미 함수를 만들겁니다.
  */

  // 주어진 객체를 전달된 모든 속성으로 확장합니다.
  //
  // 예제:
  //   var obj1 = {key1: &amp;quot;something&amp;quot;};
  //   _.extend(obj1, {
  //     key2: &amp;quot;something new&amp;quot;,
  //     key3: &amp;quot;something else new&amp;quot;
  //   }, {
  //     bla: &amp;quot;even more stuff&amp;quot;
  //   }); // obj1은 이제 다음 키를 포함합니다. key1, key2, key3, bla
  _.extend = function(obj, ...objs) {
  
    //객체를 합쳐주는 함수를 만들어보자
  
    for (let i = 0; i &amp;lt; objs.length; i ++ ) {
      for (let prop in objs[i] ) {
        obj[prop] = objs[i][prop];
      }
    }
    return obj;
  }
  

  //   for(let i = 0; i &amp;lt; arguments.length; i++) {
  //     for(let key in arguments[i]) {
  //     obj[key] = arguments[i][key]
  //     }
  //   } return obj;
  // };

  // extend와 비슷하지만, 이번엔 이미 존재하는 key에 대해 값을 덮어쓰기 하지 않습니다.
  _.defaults = function(obj,...objs) {
    
    for (let i = 0; i &amp;lt; objs.length; i ++ ) {
      for (let prop in objs[i]){
        // 만약 기존에있는 obj 의 키값이 새로 더해진 obj 에 없다면 
        if (!(prop in obj)) { 
          // 기존에 있는 obj 의 push 해준다. 
          obj[prop] = objs[i][prop];
        }
      }
    }
    return obj;
  }

  /**
  * FUNCTIONS
  * =========
  *
  * 이번엔 함수 데코레이터(decorator)를 사용합니다. 함수 데코레이터는 쉽게 말해, 어떤 함수를 받아들이고
  * 다소 다르게 작동하는 새로운 버전의 함수를 리턴하는 함수를 의미합니다.
  */

  // 최대 한번만 호출할 수 있는 함수를 리턴합니다. 이후의 호출은 이전에 한번 리턴된 값만을 리턴해야 합니다.
  
  

  // 질문 
  _.once = function(func) {
 
    // ... agrgs 사용한 함수 

    var alreadyCalled = false;
    let result;
    return function(...args) {
      if (!alreadyCalled) {
        alreadyCalled = true;
        result = func(...args);
      }
      return result;
    };
  };


  // this 와 arguments 와 apply 를 사용한 함수 

  //   let alreadyCalled = false;

  //   let result;

  
  //   return function() {
  //     if(alreadyCalled) {
  //       return result 
  //   } else {
  //       alreadyCalled = true 
  //       return result = func.apply(this, arguments);
  //     }
  //   }
  // };







  // 주어진 시간 (밀리초) 동안 함수를 지연한 다음 제공된 argument로 함수를 호출합니다.
  //
  // 원래 함수에 대한 argument는 wait parameter 뒤에 전달됩니다.
  // 예를 들어, 다음을 호출할 경우
  // _.delay(someFunction, 500, &#39;a&#39;, &#39;b&#39;);
  // someFunction(&#39;a&#39;, &#39;b&#39;) 은 500ms 이후에 호출됩니다.


  _.delay = function(func, wait, ...args) {

      setTimeout(function(){
        return func(...args);
      } ,wait);

  };


  /**
  * ADVANCED COLLECTION OPERATIONS
  * ==============================
  */

  // 다차원 배열을 가져와서, 1차원 배열로 변환합니다.
  // 새 배열에는 다차원 배열의 모든 요소가 포함되어야 합니다.
  //
  // Hint: Array.isArray 를 사용해 배열인지 아닌지를 체크하세요.
  _.flatten = function(nestedArray, result) {


     // 재귀를 이용한것 

     result = [];
     function flatarr(nestedArray) {
       for(let i = 0; i &amp;lt; nestedArray.length; i++) {
         if(!Array.isArray(nestedArray[i])) {
           result = result.concat(nestedArray[i])
         } else {
           flatarr(nestedArray[i]);
         }
       }
     } flatarr(nestedArray);
     return result;
   };
 










  // for 문을이용한 것 

  _.flatten = function(nestedArray) {
    //[1, [2], [3, [[[4]]]]]
    //oneflat([1, [2], [3, [[[4]]]]])
    // result = [1, 2, 3, [[[4]]]]
    // result = [1, 2, 3, 4]
    let oneflat = function(array) {
      let resultArr = []
      for (let i in array) {
        if (Array.isArray(array[i])) {
          resultArr = resultArr.concat(array[i]);
        } else {
          resultArr.push(array[i]);
        }
      }
      return resultArr;
    }
    let isinArr = function(array) {
      for (let i in array) {
        if (Array.isArray(array[i])) {
          return true;
        }
      }
      return false;
    }
    while(isinArr(nestedArray)) {
      nestedArray = oneflat(nestedArray);
    }
    return nestedArray;
  };





//   let arr = [];
//   let arr2 = [];
//   if(Array.isArray(nestedArray)) {
//     arr = nestedArray.join().split(&#39;,&#39;);
//   }
//   for(let i=0; i &amp;lt; arr.length; i++) {
//     arr2.push(Number(arr[i]));
//   }
//   return arr2;
// };







  // 배열 내용의 순서를 랜덤하게 변경합니다.
  //
  // TIP: 이 함수는 immutable해야 합니다.

  // 통과가 안됨 
  _.shuffle = function(array) {
    let newArr = [];
    let indexArr = [];
    let randomNum;
    let randomElement;
    for(let j = 0; j&amp;lt; array.length; j++) {
      indexArr.push(j);
    }
    let randomNumber = function(){
      return Math.floor(Math.random() * (array.length))
    }
    while(indexArr.length &amp;gt; 1) {
      randomNum = randomNumber();
      if (indexArr.includes(randomNum)) {
        randomElement = array[randomNum];
        newArr.push(randomElement);
        indexArr = _.filter(indexArr, function(el) {
          return el !== randomNum;
        });
      }
    }
    newArr.push(array[indexArr[0]]);
    return newArr;
 };
  /**
  * ADVANCED
  * =================
  *
  * Note: This is the end of the pre-course curriculum. Feel free to continue,
  * but nothing beyond here is required.
  */

  // Calls the method named by functionOrKey on each value in the list.
  // Note: You will need to learn a bit about .apply to complete this.
  _.invoke = function(collection, functionOrKey, args) {
  };

  // Sort the object&#39;s values by a criterion produced by an iterator.
  // If iterator is a string, sort objects by that property with the name
  // of that string. For example, _.sortBy(people, &#39;name&#39;) should sort
  // an array of people by their name.
  _.sortBy = function(collection, iterator) {
  };

  // Zip together two or more arrays with elements of the same index
  // going together.
  //
  // Example:
  // _.zip([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], [1,2,3]) returns [[&#39;a&#39;,1], [&#39;b&#39;,2], [&#39;c&#39;,3], [&#39;d&#39;,undefined]]
  _.zip = function() {
  };

  // Takes an arbitrary number of arrays and produces an array that contains
  // every item shared between all the passed-in arrays.
  _.intersection = function() {
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
  };

  // Memorize an expensive function&#39;s results by storing them. You may assume
  // that the function only takes primitives as arguments.
  // memoize could be renamed to oncePerUniqueArgumentList; memoize does the
  // same thing as once, but based on many sets of unique arguments.
  //
  // _.memoize should return a function that, when called, will check if it has
  // already computed the result for the given argument and return that value
  // instead if possible.
  _.memoize = function(func) {
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.  See the Underbar readme for extra details
  // on this function.
  //
  // Note: This is difficult! It may take a while to implement.
  _.throttle = function(func, wait) {
  };
}());



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-중복-제거하는-방법&#34;&gt;Array 중복 제거하는 방법&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
var data = [&#39;a&#39; , 1, 2, &#39;a&#39; , &#39;a&#39;, 3];

// 3가지 방법 from() + set , filter , reduce 

// 1: &#39;Set&#39;
Array.from(new Set(data));

// 2: &#39;Filter&#39; // arr 의 요소가 string 이라면 filter(ele,index,array) 사용한다. 
data.filter((ele, index,array) =&amp;gt;{
  return array.indexOf(ele) === index //array 3번째 파라미터를 이용하한다.  
})

//2 : filter // arr 요소가 숫자라면 
data.filter((ele, index,) =&amp;gt;{
  return data.indexOf(ele) === index //array 3번째 파라미터를 이용하한다.  
})




// 3: &#39;Reduce&#39;
array.reduce((unique, item) =&amp;gt;
  unique.includes(item) ? unique : [...unique, item], []);
  

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let names = [&#39;Mike&#39;, &#39;John&#39;, &#39;Bob&#39;, &#39;Jane&#39;, &#39;Bob&#39;, &#39;John&#39;, &#39;Lee&#39;, &#39;Mason&#39;] ;
 
let single = names.reduce(( a, b ) =&amp;gt; {
	if( a.indexOf(b) &amp;lt; 0 ) a.push(b) ;
	return a ;
}, []) ; // &amp;lt;-- 초기값 빈 배열 세팅!
 
console.log( single ) ;
// [ &#39;Mike&#39;, &#39;John&#39;, &#39;Bob&#39;, &#39;Jane&#39;, &#39;Lee&#39;, &#39;Mason&#39; ]


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-안에-알파벳-뽑기&#34;&gt;string 안에 알파벳 뽑기&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
str = &amp;quot;Hello6 9World 2, Nic8e D7ay!&amp;quot;;

var sum = str.match(/\d/g).map(Number).reduce(function(a,c){
	return a + c;
})

str.replace(/[^a-z]/gi, &#39;&#39;); // &amp;quot;HelloWorldNiceDay&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-안에-숫자뽑기&#34;&gt;string 안에  숫자뽑기&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;imutable&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;숫자를 뽑는 역활&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;\d 는 모든 숫자를 각각 배열로 나눠서 출력한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


let str = &amp;quot;123f456f78910&amp;quot;;
str.match(/\d+/g);

// [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;]

```js




* \d+ 숫자가 나란히 붙어있는 것으로 나뉜다. 

*  `imutable`

```js

let str = &amp;quot;123f456f78910&amp;quot;;
str.match(/\d/g);

// [&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;, &amp;quot;789&amp;quot;, &amp;quot;10&amp;quot;]



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;d-or-d-차이점&#34;&gt;\d or \d+  차이점&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 둘다 `imutable`  이다 

// 정규식 표현으로 둘다 숫자를 뽑는 역활을 한다. 

// \d 는 모든 숫자를 각각 배열로 나눠서 출력하낟.  

let str = &amp;quot;123f456f789 10&amp;quot;;
str.match(/\d+/g);

// [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;]




// \d+ 숫자가 나란히 붙어있는 것으로 나뉜다. 
let str = &amp;quot;123f456f789 10&amp;quot;;
str.match(/\d/g);

// [&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;, &amp;quot;789&amp;quot;, &amp;quot;10&amp;quot;]



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;extract-numbers-from-a-string-javascript&#34;&gt;Extract numbers from a string-Javascript&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var string = &amp;quot;border-radius:10px 20px 30px 40px&amp;quot;;
var numbers = string.match(/\d+/g).map(Number); 

console.log(numbers);

// [10, 20, 30, 40]



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;피보나치-수열-이란&#34;&gt;피보나치 수열 이란?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;n 번째의 피보나치 수열에 숫자출력하는 fib(n) 함수만들기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// 0 1 1 2 3 5 8 13 21 34 ......
// 점화식표현은 ==&amp;gt; f(n) = f(n-1) + f(n-2)  

// 5번째 숫자는? = f(n-1) + f(n-2)  
// n = 5 
// 5-1 = 4  네번째 피보나치 수열에 있는 3은  숫자와 5-2 = 3 세번째 피보나치 에 있는 숫자 2 를 더한값이 된다. 



function fib(n) {    // n = 10 
    if (n &amp;lt;= 1) {    // 만약 n 이 0 과 1 이라면 
        return n;    // 그것을 그냥 바로 출력해라 
    } else {         // 만약 그게 아니라면 
        return fib(n-2) + fib(n-1);  //  피보나치 수열에 8번째수와  + 9번째 수의 합을 리턴한다.  그럼 8번째 있는 수는 21 이고 9번째 있는 수는 34 이기 때문에 더한 값은 55가 된다. 

    }
}

fib(10) // ==&amp;gt; 55


function fib(n) {
 
	if (n === 0 ) { // n 이 0 이면 0을 출력하고 그만  
	return 0;      
	}
	if (n === 1 ) { // n 이 1 이면 1을 출력하고 그만 
	return 1;
}


return fib(n-1) + fib(n-2) 
	
}




&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;20번째 까지 피보나치 수열을 출력하는 fib(n) 함수 만들기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function fib(n) {
    if ( n &amp;lt;= 1 ) {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

let  tmp = &#39;&#39;;

for(let i = 0; i &amp;lt; 20; i++){ // 20번째 까지 
    tmp += fib(i) + &amp;quot; &amp;quot; 
}


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;함수사용해서 피보나치 수열 만들기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;




function fibonacci(num){
    var a = 1 
	  var b = 0
	  var temp;
	  
	  for(var i = num; i &amp;gt;= 1; i--){
            temp = a;
            a = a + b;
            b = temp;
            
			if(i === 1) {
			console.log(b);
            }	else {
			console.log(b);
      			
   		 }
        }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;for 문을 사용해서 피보나치 수열 만들기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


var num = 15;  // 몇번째까지 
var a = 1, b = 0, temp;

document.write(b + &amp;quot;, &amp;quot;);

for(var i = num; i &amp;gt;= 1; i--){
temp = a;
a = a + b;
b = temp;
if(i == 1) {
document.write(b);
} else {
document.write(b + &amp;quot;, &amp;quot;);
}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;foreach-for-of-for-in-의-차이&#34;&gt;forEach, for of, for in 의 차이&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;basic for문과 for in은 반복변수에 index를 리턴하지만&lt;/p&gt;

&lt;p&gt;forEach 와 for of 는 해당 값을 리턴하기 때문이죠.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
const array = [&#39;가&#39;,&#39;나&#39;,&#39;다&#39;,&#39;라&#39;];

// for
for(let i=0; i&amp;lt;array.length; i++){
  console.log(array[i]);
}

// 가 나 다 라 


 
//forEach
array.forEach(function(j){
  console.log(array[j]);
});
 
// console.log(array[j]) 
// undefined
 
// console.log(j) 
// 가 나 다 라
 
 
 
 
// for of 
for (let k of array){
  console.log(array[k]);
}
 
// console.log(array[k]) 
// undefined
 
// console.log(k) 
// 가 나 다 라
 
 
 
 
 // for in
for (let z in array){
  console.log(array[z]);
}

// 가 나 다 라



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;falsy-와-fruthy-구별&#34;&gt;Falsy 와 Fruthy 구별&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
undefined, false, null, 0, NaN, “ 는 false 로 취급(falsy)
(NaN : Not a Number)

/위에 적힌 데이터가 아닌 모든 데이터는 trye로 취급(truthy)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;null-과-undefined-는-등록-저장-여부이다&#34;&gt;null 과 undefined 는 등록, 저장 여부이다.&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt; 은 값은 값이지만 값으로써 의미없는 특별한 값이 등록되어 있는 것이고, undefined 는 등록이 되어있지 않기 때문에 초기화도 정의되지도 않은 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt; 는 미리 선언된 전역변수(전역 객체의 프로퍼티)이며, null 은 선언,등록을 하는 키워드인 것입니다.&lt;/p&gt;

&lt;h2 id=&#34;객체인-arguments-를-array-로-바꾸는-방법&#34;&gt;객체인 arguments 를 array 로 바꾸는 방법&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;call()은 상위 context를 변경하는 메서드이고&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arguments는 함수의 매개변수에 접근할 수 있는 속성이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;먼저 위의 행위를 말로 설명하자면 이 코드가 존재하는 함수의 매개변수로 넘어온 값들을 array로 변환하겠다는 것이다.&lt;/p&gt;

&lt;p&gt;function func(a, b){} 에서 a와 b를 arguments[0]과 arguments[1]로 접근가능하다.&lt;/p&gt;

&lt;p&gt;하지만 여기서 arguments는 array가 아니며 &lt;code&gt;object&lt;/code&gt;임을 알아야 한다.(참고) 그러므로 array로 변환할 필요가 있을 경우&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;바꾸는 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.prototype.slice.call(arguments) // 를 사용하는 것이다.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;설명&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
이 코드는 보통 아래와 같이 apply와 함께 사용된다.

var args = Array.prototype.slice.call(arguments);

func.apply(this, args); 

apply는 call과 같이 상위 context를 변경해준다. 차이점은 매개변수를 넘겨주는 2번째 인자가 Array라는 점이다. Array에 담긴 순서에 맞게 호출된 함수(func)의 매개변수에 적용된다.



Array.prototype.slice.call(arguments);

이 코드는 결과만 보면 아래와 같다.

[arguments].slice();

call()의 첫번째 인자에 arguments가 전달되므로 Array의 context는 arguments로 대체되기 때문이다.



추가로 ES6에서는 Array.from()으로 제공한다(참고)



결론

결국 이러한 행위는 문법적 꼼수라고 할 수 있다.

v8엔진에서 최적화 문제도 있다고 하니 다음 코드를 사용해보는 것도 좋다.

var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rest파라미터와-spread연산자-or-함수의-가독성을-높이는-방법&#34;&gt;Rest파라미터와 Spread연산자 or 함수의 가독성을 높이는 방법&lt;/h2&gt;

&lt;h4 id=&#34;rest-파라미터-rest-parameter&#34;&gt;Rest 파라미터 (Rest Parameter)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Rest 파라미터는 Spread 연산자(...)를 사용하여 함수의 파라미터를 작성한 형태를 말한다. 즉, Rest 파라미터를 사용하면 함수의 파라미터로 오는 값들을 &amp;quot;배열&amp;quot;로 전달받을 수 있다.

(Java에서 public static void func(String... strs){...} 이런식의 가변인자와 유사)

사용 방법은 파라미터 앞에 (...)을 붙인다.


function foo(...rest) {
  console.log(Array.isArray(rest)); // true
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}
foo(1, 2, 3, 4, 5);


* function foo(param1, param2, ...rest){~~} 처럼 앞에 파라미터는 일반적인 파라미터로 받을 수 있고 그 뒤부터는 Rest 파라미터로 받을 수 있다.

- 단, Rest파라미터는 항상 제일 마지막 파라미터로 있어야 한다. 예를들어 function foo(...rest, param1, param2){~}는 사용 불가능하다.

arguments VS rest 파라미터

ES5에서도 가변 인자 함수의 경우 arguments 객체를 통해 인자값을 확인할 수 있었다.


var foo = function () {
  console.log(arguments);
};
foo(1, 2); // { &#39;0&#39;: 1, &#39;1&#39;: 2 }


그렇다면 arguments와 rest파라미터의 차이점은 무엇일까?

답부터 말하면 arguments는 유사 배열 객체고 rest는 배열이다.

유사 배열 객체(array-like object)는 간단하게 순회가능한(iterable) 특징이 있고 length 값을 알 수 있는 특징이 있는 것이다. 즉, 배열처럼 사용할 수 있는 객체를 말한다.

무슨 말이냐면 arguments는 유사배열객체이기 때문에 Array 오브젝트의 메서드를 사용할 수 없다.

따라서 ES6에서는 arrow function에 arguments는 사용할 수 없을 뿐더러 Rest 파라미터를 사용하면 더 유연한 코드를 작성할 수 있는 것이기 때문에 Rest 파라미터 사용을 권장한다.


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;spread-연산자-spread-operator&#34;&gt;Spread 연산자 (Spread Operator)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
Spread 연산자는 연산자의 대상 배열 또는 이터러블(iterable)을 &amp;quot;개별&amp;quot; 요소로 분리한다.


// 배열
console.log(...[1, 2, 3]); // -&amp;gt; 1, 2, 3
 
// 문자열
console.log(...&#39;Helllo&#39;);  // H e l l l o
 
// Map과 Set
console.log(...new Map([[&#39;a&#39;, &#39;1&#39;], [&#39;b&#39;, &#39;2&#39;]]));  // [ &#39;a&#39;, &#39;1&#39; ] [ &#39;b&#39;, &#39;2&#39; ]
console.log(...new Set([1, 2, 3]));  // 1 2 3
Colored by Color Scripter


이터러블(iterable)은 Array, String, Map, Set, DOM구조다.

iterator를 생성해서 next()로 순회할 수 있는 자료구조가 이터러블이라고 생각하면 된다.

* 함수의 파라미터로 사용하는 방법


// ES6
function foo(x, y, z) {
  console.log(x); // 1
  console.log(y); // 2
  console.log(z); // 3
}
const arr = [1, 2, 3];
foo(...arr);// Array를 받아서 각 매개변수로 전달되었다.


Rest와 헷갈리지 않기!

Rest는 함수 선언문의 파라미터에 Spread(...)연산자를 이용해서 받으면 가변인자를 받아 배열로 만들어서 사용하는 것이고, 함수 호출문의 파라미터에 Spread(...)연산자를 이용해서 호출하면 배열이 해당 매개변수로 각각 매핑되는 것은 다르다.

//Rest
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest);  // [ 2, 3 ]
}
foo(1, 2, 3);
 
//Spread호출
function bar(x, y, z) {
  console.log(x); // 1
  console.log(y); // 2
  console.log(z); // 3
}
bar(...[1, 2, 3]);


- 또한 Rest에서는 선언에서 Spread연산자를 제일 뒤에만 써야하지만, Spread호출에서는 중간중간 사용해도 상관없다.

* 배열에서 사용하는 방법 (가독성UP)


//ES5
var arr = [1, 2, 3];
console.log(arr.concat([4, 5, 6])); // [ 1, 2, 3, 4, 5, 6 ]
 
// ES6
const arr = [1, 2, 3];
// ...arr은 [1, 2, 3]을 개별 요소로 분리한다
console.log([...arr, 4, 5, 6]); // [ 1, 2, 3, 4, 5, 6 ]


- concat() 대신 가독성이 더 좋아졌다.


// ES5
var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
 
// apply 메소드의 2번째 인자는 배열. 이것은 개별 인자로 push 메소드에 전달된다.
//Array.prototype.push.apply(arr1, arr2);
//arr1.push(arr2); =&amp;gt; [1,2,3,[4,5,6]]
console.log(arr1); // [ 1, 2, 3, 4, 5, 6 ]
 
// ES6
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
 
// ...arr2는 [4, 5, 6]을 개별 요소로 분리한다
arr1.push(...arr2); // == arr1.push(4, 5, 6);
 
console.log(arr1); // [ 1, 2, 3, 4, 5, 6 ]


- push를 개별 요소로 전달할 수 있으니 훨씬 간결하고 가독성 또한 좋아졌다.

* 객체에서 사용하기

const o1 = { x: 1, y: 2 };
const o2 = { ...o1, z: 3 };
console.log(o2); // { x: 1, y: 2, z: 3 }
 
const target = { x: 1, y: 2 };
const source = { z: 3 };
// Object.assign를 사용하여도 동일한 작업을 할 수 있다.
// Object.assign은 타깃 객체를 반환한다
console.log(Object.assign(target, source)); // { x: 1, y: 2, z: 3 }


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>_section1</title>
      <link>/tutorial/javascript_note/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/javascript_note/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Basic CS Sections&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;여기에서는 에서는 가장 기초적인 개발환경 셋팅과 컴퓨터 공학의 기본적인 개념을 다루게 됩니다. 당장에 웹 개발에 필요한 지식(네이버를 만들기 위한) 이라기보다는, 개발자로서 필요한 지식들의 집합이라고 보실 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>_section2</title>
      <link>/tutorial/javascript_q1/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/javascript_q1/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Dictionary_files/javascriptt-light_870x220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;longestword&#34;&gt;longestWord&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Using the JavaScript language, have the function LongestWord take the sen parameter being passed and return the largest word in the string. (문장이 주어졌을때, &amp;lsquo;LongestWord&amp;rsquo; 함수는 주어진 문장에서 가장 긴 단어를 반환합니다.)&lt;/p&gt;

&lt;p&gt;If there are two or more words that are the same length, return the first word from the string with that length. Assume sen will not be empty. (만약 가장 긴 단어가 두개 이상이라면, 첫번째로 등장하는 가장 긴 단어를 반환하세요. 문장은 빈 문자열이 아닙니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It&#39;s used by sort() 

function longestWord(string) {

 // 1. 주어진 문장을 배열로 만들기(split)
 let tmp = string.split(&#39; &#39;);
 //let sorted_tmp =[];
 // [&#39;I&#39;,&#39;love&#39;,&#39;codestates&#39;];
 // 2. sort() 사용 =&amp;gt; 성능 떨어짐
 let x = function(a,b){
   return b.length-a.length;
 };
 // 3. 0번째 요소 출력
 return tmp.sort(x)[0];
}

////////////////////////////////////////////////////////

// It&#39;s used by reudce(1)

function longestWord(string) {
 
 let tmp = string.split(&#39; &#39;);
 let max = tmp[0];
 for(let i =1;i&amp;lt;tmp.length;i++){
   if(tmp[i].length&amp;gt;max.length){
     max = tmp[i];
   }
 }
 return max;
}


/////////////////////////////////////////////////////////

// It&#39;s used by reudce(2) 화살표

function longestWord(string) {

return string.split(&#39; &#39;).reduce((acc,cur)=&amp;gt; acc.length&amp;lt;cur.length? cur:acc);
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-1&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;firstcharacter&#34;&gt;firstCharacter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;In this exercise, a string is passed to a method and a new string has to be returned with the first character of each word in the string (문자열이 주어졌을때, &amp;ldquo;firstCharacter&amp;rdquo; 함수는 문자열의 각 단어 첫글자들로 이루어진 문자열을 반환하여야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-1&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function firstCharacter (string) {
 // Your code here
 
 
 // 1. for문 이용
 
 let output = [];
 let temp_arr = [];

 // 1. split으로 단어로 나눠서 배열 만들기
 
 temp_arr = string.split(&#39; &#39;);
 // 2. 각 인덱스의 첫번째 문자를 배열 output 에 담기
 for(let i=0;i&amp;lt;temp_arr.length;i++){
   output.push(temp_arr[i][0]);
 }
 
 // 4. 출력
 return output.join(&#39;&#39;);
 
 
 
 ////////////////////////////////////////////////////////////////////////
 
 // 2. Reduce 이용
 return string.split(&#39; &#39;).reduce(function(acc,cur){
   return acc+cur[0];
 
 },&#39;&#39;);
 
 // 3. Reduce이용 2
 return string.split(&#39; &#39;).reduce( (acc,cur)=&amp;gt;acc+cur[0] ,&#39;&#39;);
}




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-2&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isoldenoughtodrink&#34;&gt;isOldEnoughToDrink&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;어떤 숫자, 이 경우에는 연령이 하나 주어졌을 때, isOldEnoughToDrink 함수는 주어진 연령의 사람이 미국에서 합법적으로 술을 마실 수 있는지의 여부를 반환해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-2&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function isOldEnoughToDrink(age) {
  // 여기에 코드를 작성하세요
  if (age &amp;lt; 21 ) {
    return false;
  } else {
    return true;
  }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-3&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;checkage&#34;&gt;checkAge&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;이름과 나이를 파라미터로 받는 checkAge라는 함수는 두개 중 하나의 메시지를 리턴합니다.&lt;/p&gt;

&lt;p&gt;만일 21살보다 적으면, Go home, {전달받은_이름}! 만일 21살이거나 더 나이가 많으면, Welcome, {전달받은_이름}! 을 리턴하세요. 쉼표와 공백, 느낌표까지 정확히 리턴해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-3&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function checkAge(name, age) {
  // 여기에 코드를 작성하세요
  if (age &amp;gt;= 21){
    return &#39;Welcome, &#39; + name+ &#39;!&#39;;
  } else {
    return &#39;Go home, &#39; + name+ &#39;!&#39;;
  }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-4&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;equalsten&#34;&gt;equalsTen&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;equalsTen&amp;rdquo;. (&amp;ldquo;equalsTen&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;equalsTen&amp;rdquo; returns whether or not the given number is 10. (&amp;ldquo;숫자가 주어졌을때, &amp;ldquo;equalsTen&amp;rdquo; 함수는 숫자가 10과 같은지 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-4&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function equalsTen(num) {
  // 여기에 코드를 작성하세요
  if ( num !== 10){
    return false;
  }else if (num === 10 ){
    return true;
  }
}

equalsTen(10);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-5&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isgreaterthan&#34;&gt;isGreaterThan&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isGreaterThan&amp;rdquo;. (&amp;ldquo;isGreaterThan&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 2 numbers, &amp;ldquo;isGreaterThan&amp;rdquo; returns whether num2 is greater than num1. (두 숫자가 주어졌을때, &amp;ldquo;isGreaterThan&amp;rdquo; 함수는 두번째 숫자(num2)가 첫번째 숫자(num1)보다 큰지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-5&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function isGreaterThan(num1, num2) {
  // 여기에 코드를 작성하세요
  if ( num1 === num2 ){
    return false;
  } else if ( num1 &amp;lt; num2) {
    return true;
  } else {
    return false;
  }
}

isGreaterThan(20,30)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-6&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;iseven&#34;&gt;isEven&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEven&amp;rdquo;. (&amp;ldquo;isEven&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;isEven&amp;rdquo; returns whether it is even. (&amp;ldquo;숫자가 주어졌을때, &amp;ldquo;isEven&amp;rdquo; 함수는 주어진 숫자가 짝수인지 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-6&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function isEven(num) {
  // 여기에 코드를 작성하세요
  if ( num % 2 === 0 ) {
    return true;
  } else {
    return false;
  }

}

isEven(21)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-7&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isevenandgreaterthanten&#34;&gt;isEvenAndGreaterThanTen&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo;. (&amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number, &amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo; returns whether it is both even and greater than 10. (숫자가 주어졌을때, &amp;ldquo;isEvenAndGreaterThanTen&amp;rdquo; 함수는 주어진 숫자가 10보다 크고 짝수인지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-7&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function isEvenAndGreaterThanTen(num) {
  // 여기에 코드를 작성하세요
  if ( num % 2 === 0 &amp;amp;&amp;amp; num &amp;gt; 10 ){
    return true;
  } else {
    return false;
  }
}
isEvenAndGreaterThanTen(13);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-8&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;convertscoretograde&#34;&gt;convertScoreToGrade&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;convertScoreToGrade&amp;rdquo;. (&amp;ldquo;convertScoreToGrade&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a score, &amp;ldquo;convertScoreToGrade&amp;rdquo; returns a string representing the letter grade corresponding to the given score. (점수가 주어졌을때, &amp;ldquo;convertScoreToGrade&amp;rdquo; 함수는 주어진 점수와 대응하는 등급을 문자열로 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-8&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function convertScoreToGrade(score) {
  // 여기에 코드를 작성하세요
  if ( score &amp;gt; 100 || score &amp;lt; 0) {
    return &amp;quot;INVALID SCORE&amp;quot;;
  } else if ( score &amp;gt;= 90 ) {
    return &amp;quot;A&amp;quot;;
  } else if ( score &amp;gt;= 80 ) {
    return &amp;quot;B&amp;quot;;
  } else if ( score &amp;gt;= 70 ) {
    return &amp;quot;C&amp;quot;;
  } else if ( score &amp;gt;= 60 ) {
    return &amp;quot;D&amp;quot;;
  } else {
   return &#39;F&#39;;
  }
}
convertScoreToGrade(0);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-9&#34;&gt;Question&lt;/h3&gt;

&lt;h3 id=&#34;or&#34;&gt;Or&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;or&amp;rdquo;. (&amp;ldquo;or&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 2 boolean expressions, &amp;ldquo;or&amp;rdquo; returns true or false, corresponding to the || operator. (boolean 두개가 주어졌을때, &amp;ldquo;or&amp;rdquo; 함수는 || 연산자에 대응하는 true 나 false 를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-9&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function or(expression1, expression2) {
  // 여기에 코드를 작성하세요
  if ( expression1 !== false  ) {
    return true;
  } else if ( expression2 !== false ) {
    return true;
  } else {
    return false;
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-10&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;iseitherevenandlessthan9&#34;&gt;isEitherEvenAndLessThan9&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEitherEvenAndLessThan9&amp;rdquo;. (&amp;ldquo;isEitherEvenAndLessThan9&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two numbers, &amp;lsquo;isEitherEvenAndLessThan9&amp;rsquo; returns whether at least one of them is even, and, both of them are less than 9. (숫자 두개가 주어졌을때, &amp;lsquo;isEitherEvenAndLessThan9&amp;rsquo; 함수는 2가지 조건을 검사합니다. 우선 두 숫자 중 적어도 하나가 짝수인지, 그리고 두 숫자 모두 9보다 작은지를 확인합니다. 두 조건을 모두 만족 했을 때만 true를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-10&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function isEitherEvenAndLessThan9(num1, num2) {
  if ((num1 % 2 === 0 || num2 % 2 === 0) &amp;amp;&amp;amp; (num1 &amp;lt; 9 &amp;amp;&amp;amp; num2 &amp;lt; 9)) {
    return true;
  } else {
    return false;
  }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;question-getfullname&#34;&gt;Question : getFullName&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getFullName&amp;rdquo;. (&amp;ldquo;getFullName&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a first and a last name, &amp;ldquo;getFullName&amp;rdquo; returns a single string with the given first and last names separated by a single space. (이름과 성이 주어졌을때, &amp;ldquo;getFullName&amp;rdquo; 함수는 이름과 성이 띄어쓰기 하나를 사이에 둔 단일 문자열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-11&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getFullName(firstName, lastName) {
  // 여기에 코드를 작성하세요
  let output = firstName + lastName;
  return firstName + &amp;quot; &amp;quot; + lastName;
}
  
getFullName(&#39;john&#39;,&#39;jung&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-11&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlengthofword&#34;&gt;getLengthOfWord&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLengthOfWord&amp;rdquo;. (&amp;ldquo;getLengthOfWord&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;getLengthOfWord&amp;rdquo; returns the length of the given word. (단어가 주어졌을때, &amp;ldquo;getLengthOfWord&amp;rdquo; 함수는 단어의 길이를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-12&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getLengthOfWord(word) {
  // 여기에 코드를 작성하세요
  let count = word.length;
  return count;
}
getLengthOfWord(&amp;quot;hello&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-12&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeaveragelengthofwords&#34;&gt;computeAverageLengthOfWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeAverageLengthOfWords&amp;rdquo;. (&amp;ldquo;computeAverageLengthOfWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two words, &amp;ldquo;computeAverageLengthOfWords&amp;rdquo; returns the average of their lengths. (두 단어가 주어졌을때, &amp;ldquo;computeAverageLengthOfWords&amp;rdquo; 함수는 두 단어 길이의 평균값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-13&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function computeAverageLengthOfWords(word1, word2) {
  // your code here
  // count
  var firstNum = word1.length;
  var sceondNum = word2.length;
  var ret = (firstNum + sceondNum) / 2;
  return ret;
  }
  computeAverageLengthOfWords(&amp;quot;whatIYouDoing?&amp;quot;,&amp;quot;this is JJ&amp;quot;)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-13&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isoddlength&#34;&gt;isOddLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isOddLength&amp;rdquo;. (&amp;ldquo;isOddLength&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;isOddLength&amp;rdquo; returns whether the length of the given word is odd. (단어가 주어졌을때, &amp;ldquo;isOddLength&amp;rdquo; 함수는 주어진 단어의 길이가 홀수인지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-14&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function isOddLength(word) {
  // your code here
  let countNum = word.length;
  if ( countNum % 2 !== 0) {
    return true;
  } else {
    return false;
  }
}

isOddLength(&amp;quot;heeeee&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-14&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isevenlength&#34;&gt;isEvenLength&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isEvenLength&amp;rdquo;. (&amp;ldquo;isEvenLength&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;isEvenLength&amp;rdquo; returns whether the length of the word is even. (단어가 주어졌을때, &amp;ldquo;isEvenLength&amp;rdquo; 함수는 주어진 단어의 길이가 짝수인지 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-15&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function isEvenLength(word) {
  // your code here
  var countNum = word.length;
  if ( countNum % 2 === 0 ) {
    return true;
  } else {
    return false;
  }
}

isEvenLength(&amp;quot;hee&amp;quot;)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-15&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;repeatstring&#34;&gt;repeatString&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;repeatString&amp;rdquo;. (&amp;ldquo;repeatString&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a string and a number, &amp;ldquo;repeatString&amp;rdquo; returns the given string repeated the given number of times. (문자열과 숫자가 주어졌을때, &amp;ldquo;repeatString&amp;rdquo; 함수는 주어진 문자열을 주어진 숫자만큼 반복하여 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-16&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function repeatString(string, num) {
  // your code here
 var repeatation = string.repeat(num) 
 return repeatation;
}

repeatString(&amp;quot;thewordofGod is the way&amp;quot;,50)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-16&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;findshortestofthreewords&#34;&gt;findShortestOfThreeWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;findShortestOfThreeWords&amp;rdquo;. (&amp;ldquo;findShortestOfThreeWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given 3 strings, &amp;ldquo;findShortestOfThreeWords&amp;rdquo; returns the shortest of the given strings. (문자열 3개가 주어졌을때, &amp;ldquo;findShortestOfThreeWords&amp;rdquo; 함수는 주어진 문자열 중 가장 짧은 문자열을 반환해야 합니다.)&lt;/p&gt;

&lt;p&gt;If there are ties, it should return the first word in the parameters list. (만약 동률이 있다면, 그 중 앞에 있는 문자열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-17&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function findShortestOfThreeWords(word1, word2, word3) {
  // your code here
  if ( word1.length &amp;lt; word2.length &amp;amp;&amp;amp; word3.length ) {
    return word1;
  } else if (word1.length === word2.length &amp;amp;&amp;amp; word3.length){
    return word1;
  } else if ( word2.length &amp;lt; word1.length &amp;amp;&amp;amp; word3.length ){
  return word2;
  } else if ( word3.length &amp;lt; word2.length &amp;amp;&amp;amp; word1.length ) {
    return word3;
  }
}

findShortestOfThreeWords(&amp;quot;111&amp;quot;,&amp;quot;222&amp;quot;,&amp;quot;333333333&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-17&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;countcharacter&#34;&gt;countCharacter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;countCharacter&amp;rdquo;. (&amp;ldquo;countCharacter&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a string input and a character, &amp;ldquo;countCharacter&amp;rdquo; returns the number of occurences of a given character in the given string. (문자열과 문자가 주어졌을때, &amp;ldquo;countCharacter&amp;rdquo; 함수는 주어진 문자열에서 주어진 문자가 몇개가 있는지를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-18&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function countCharacter(str, char) {
  // your code here
  let countRet = 0;
  for ( let i = 0; i &amp;lt; str.length; i = i + 1 ) {
    if ( str.charAt(i) === char ) {
      countRet = countRet + 1 ;
    }
  }
  return countRet;
}

countCharacter(&amp;quot;hello&amp;quot;, &amp;quot;l&amp;quot; );



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-18&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;arevalidcredentials&#34;&gt;areValidCredentials&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;areValidCredentials&amp;rdquo;. (&amp;ldquo;areValidCredentials&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a name and a password, &amp;ldquo;areValidCredentials&amp;rdquo;, returns true if the name is longer than 3 characters, AND, the password is at least 8 characters long. Otherwise it returns false. (이름과 비밀번호가 주어졌을때, &amp;ldquo;areValidCredentials&amp;rdquo; 함수는 이름이 3글자이상 그리고 비밀번호가 8글자 이상이면 true를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-19&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ex1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function findMinLengthOfThreeWords(word1, word2, word3) {
  // your code here
  if (word1.length === (word2.length &amp;amp;&amp;amp; word3.length)){
    return word1.length
  } else if (word1.length &amp;lt; (word2.length &amp;amp;&amp;amp; word3.length)){
    return word1.length;
  } else if (word2.length &amp;lt; (word1.length &amp;amp;&amp;amp; word3.length) ){
    return word2.length;
  } else if (word3.length &amp;lt; (word1.length &amp;amp;&amp;amp; word2.length) ){
    return word3.length;
  }
}

findMinLengthOfThreeWords(&amp;quot;111&amp;quot;,&amp;quot;2222&amp;quot;,&amp;quot;33333&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMinLengthOfThreeWords(word1, word2, word3) {
  var arr = [];
  arr.push(word1, word2, word3);
  arr.sort();
  return arr[0].length;
}
findMinLengthOfThreeWords(&amp;quot;dwdsdsdsdsdsdsdwd&amp;quot;,&amp;quot;ddwwd&amp;quot;,&amp;quot;wdwdwdsdsdwdwwd&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMinLengthOfThreeWords(word1, word2, word3) {
  // your code here
  /* START SOLUTION */
  words = [word1, word2, word3];
  return words.sort()[0].length;
  /* END SOLUTION */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ex4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function findMinLengthOfThreeWords(word1, word2, word3) {
  return Math.min(word1.length, word2.length, word3.length)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-19&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeareaofatriangle&#34;&gt;computeAreaOfATriangle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given the base and height of a triangle, &amp;ldquo;computeAreaOfATriangle&amp;rdquo; returns its area. (삼각형의 밑변과 높이가 주어졌을때, &amp;ldquo;computeAreaOfATriangle&amp;rdquo; 함수는 삼각형의 넓이를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-20&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function computeAreaOfATriangle(base, height) {
  // your code here
  let ret = base * height / 2;
  return ret;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-20&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeperimeterofacircle&#34;&gt;computePerimeterOfACircle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computePerimeterOfACircle&amp;rdquo;. (&amp;ldquo;computePerimeterOfACircle&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given the radius of a circle, &amp;ldquo;computePerimeterOfACircle&amp;rdquo; returns its perimeter. (원의 반지름이 주어졌을때, &amp;ldquo;computePerimeterOfACircle&amp;rdquo; 함수는 원의 둘레를 반환하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-21&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function computePerimeterOfACircle(radius) {
  // your code here\
  //원의 둘레 = 2 X 반지름 X 원주율 = 지름 X 원주율
  let ret = radius * 2 * Math.PI;
  return ret;
}

computePerimeterOfACircle(200);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-21&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeaverageofnumbers&#34;&gt;computeAverageOfNumbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeAverageOfNumbers&amp;rdquo;. (&amp;ldquo;computeAverageOfNumbers&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;computeAverageOfNumbers&amp;rdquo; returns their average. (숫자이 배열이 주어졌을때, &amp;ldquo;computeAverageOfNumbers&amp;rdquo; 함수는 그들의 평균을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-22&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function computeAverageOfNumbers(nums) {
  // your code here
  let sum = 0;
  if ( nums.length === 0 ) {
    return 0;
  }
  for (let i = 0; i &amp;lt; nums.length; i = i + 1 ){
    sum = sum + nums[i]
  }
  return sum / nums.length; 
}
computeAverageOfNumbers[1,2,3,4,5,6];

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-22&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;converttostring&#34;&gt;convertToString&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;convertToString함수가 있습니다. 이 함수는 주어진 파라미터를 문자열의 형태로 변환합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-23&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertToString(anything) {
  // 여기에 코드를 작성하세요
  return anything.toString();
  // return &amp;quot;&amp;quot; + anything;
  // return String(anything);
}

convertToString(&#39;hello&#39;)




&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-23&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;converttonumber&#34;&gt;convertToNumber&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;convertToNumber함수가 있습니다. 이 함수는 주어진 파라미터를 숫자의 형태로 변환합니다.&lt;/p&gt;

&lt;p&gt;숫자로 변환할 수 없는 경우, NaN (Not a number) 이라는 결과가 나올것입니다. NaN은 숫자가 아님을 나타내는 특수한 값으로, 문자열이 아닙니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soution&#34;&gt;My_Soution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function convertToNumber(anything) {
  anything = Number(anything);
  
  if(!anything){
    return NaN;
  }else{
    return anything;
  }
}
convertToNumber(&#39;hello&#39;)



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-24&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;isfalsy&#34;&gt;isFalsy&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;isFalsy함수가 있습니다. falsy 값은, 거짓으로 취급되는 값을 의미합니다. 이 함수는 주어진 파라미터가 falsy값인지 아닌지를 평가합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-24&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isFalsy(anything) {
  // 여기에 코드를 작성하세요
   if ( typeof anything === &#39;undefined&#39; ) {
      return true;
    } else if (!anything) {
      return true;
    } else if ( anything === null ) {
      return true;
    } else if ( anything === 0 ) {
      return true;
    } else if (anything === NaN ) {
      return true;
    } else if ( anything === &#39;&#39; ) {
      return true;
    } else {
      return false;
    }
} 

isFalsy(&#39;hello&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-25&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;gettype&#34;&gt;getType&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;getType함수가 있습니다. 이 함수는 주어진 파라미터의 타입을 리턴합니다.&lt;/p&gt;

&lt;p&gt;Note:
배열을 넘길 경우, &amp;lsquo;object&amp;rsquo;라고 나올 수 있습니다. 배열과 객체는 어떻게 구분할 수 있을까요?
배열과 객체를 구분하려면 Array.isArray 메소드를 사용하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-25&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getType(anything) {
  // 여기에 코드를 작성하세요
  // if 문을 사용해서 문자,숫자, boolean , arry, object 을 구분하는 것을 사용한다.
  if (Array.isArray(anything) === true ) {
    return &#39;array&#39;
  } else 
  return typeof anything;
}


getType([1,2,3,4])

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-26&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getproperty&#34;&gt;getProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;파라미터로 객체와 키를 받는 getProperty함수가 있습니다. 이 함수는 주어진 객체와 키를 이용하여 속성값을 찾아 리턴합니다.
만일 주어진 키가 객체의 속성에 없다면, undefined를 리턴하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-26&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
function getProperty(obj, propertyName) {
  return obj[propertyName];
}
let person = {
  name: &#39;Steve&#39;,
  age: 16
};

getProperty(person,&amp;quot;name&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-27&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addproperty&#34;&gt;addProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;파라미터로 객체와 키를 받는 addProperty 함수가 있습니다. 이 함수는 주어진 객체에, 키 이름으로 속성을 만들고 값을 true로 설정합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-27&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function addProperty(obj, propertyName) {
  // 여기에 코드를 작성하세요
  return obj[propertyName] = true;
  // return obj.propertyNmae = true; &amp;lt;&amp;lt;&amp;lt;is not working at all
  }

let john = {};

addProperty(john,&#39;isprogrammer&#39;);




// Questoin


/*
obj[propertyName]를 이용했을 때는 테스트가 통과가 되고,
obj.propertyName를 이용했을 때는 통과가 되지 않습니다.
객체에 프로퍼티를 추가할 때 dot노테이션을 사용할 수 있는 걸로 알고있는데..이유가 뭘까요?


answer

으로 했을때는 바로 객체의 키로 접근하고 [ ] 으로 하면 변수로 접근합니다.
addProperty(steve, &#39;isProgrammer&#39;); 이라는 함수 호출 구문이 있다고 가정하면
obj[propertyName] = true; 는 steve.isProgrammer = true; 이고
obj.propertyName = true; 는 steve.propertyName = true; 입니다. 완전히 다른값이 
나오죠?

*/






&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-28&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addobjectproperty&#34;&gt;addObjectProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;파라미터로 두 개의 객체와 키를 받는 addObjectProperty 함수가 있습니다. 이 함수는 주어진 첫번째 객체에, 키 이름으로 속성을 만드는데, 그 값은 두번째 객체로 설정합니다.
객체의 키 값은 또다른 객체가 될 수 있음을 기억하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-28&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function addObjectProperty(obj1, propertyName, obj2) {
  // 여기에 코드를 작성합니다.
  obj1[propertyName] = obj2; 
  return obj1;
}
let person1 = {
  name: &#39;Joe&#39;,
  role: &#39;Team Member&#39;
};
let person2 = {
  name: &#39;Steve&#39;,
  role: &#39;CEO&#39;
};


addObjectProperty(person1, &#39;manager&#39;, person2);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-29&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeproperty&#34;&gt;removeProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeProperty&amp;rdquo;. (&amp;ldquo;removeProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;removeProperty&amp;rdquo; removes the given key from the given object. (객체와 키가 주어졌을때, &amp;ldquo;removeProperty&amp;rdquo; 함수는 주어진 키에 해당하는 객체의 속성값을 제거해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-29&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeProperty(obj, propertyName) {
  // 여기에 코드를 작성하세요
  delete obj[propertyName];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-30&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;ispersonoldenoughtovote&#34;&gt;isPersonOldEnoughToVote&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;isPersonOldEnoughToVote&amp;rdquo;. (&amp;ldquo;isPersonOldEnoughToVote&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a &amp;ldquo;person&amp;rdquo; object, that contains an &amp;ldquo;age&amp;rdquo; property, &amp;ldquo;isPersonOldEnoughToVote&amp;rdquo; returns whether the given person is old enough to vote. (&amp;ldquo;age&amp;rdquo; 속성을 가지고 있는 &amp;ldquo;person&amp;rdquo; 객체가 주어졌을때, &amp;ldquo;isPersonOldEnoughToVote&amp;rdquo; 함수는 그 사람이 미국에서 합법적으로 투표를 할 수 있는 나이인지를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function isPersonOldEnoughToVote(person) {
  // your code here
  // 1. if 사용해서 18세 이상일 경우 리턴 참
  // 2. 아닐경우 거짓
  if ( person.age &amp;gt;= 18 ) {
    return true;
  } else {
    return false;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-31&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removenumberslargerthan&#34;&gt;removeNumbersLargerThan&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeNumbersLargerThan&amp;rdquo;. (&amp;ldquo;removeNumbersLargerThan&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a number and an object, &amp;ldquo;removeNumbersLargerThan&amp;rdquo; removes any properties whose values are numbers greater than the given number. (숫자와 객체가 주어졌을때, &amp;ldquo;removeNumbersLargerThan&amp;rdquo; 함수는 주어진 객체에서 주어진 숫자보다 큰 모든 숫자 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-30&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let obj = {
  a: 8,
  b: 2,
  c: &#39;montana&#39;,
  d: 10,
  e: 4,
  f: 5
}

function removeNumbersLargerThan(num, obj) {
  // your code here
  for (let key in obj){
    if ( obj[key] &amp;gt; num ) {
    delete obj[key];
    }
  }
return obj;
}

removeNumbersLargerThan(3,obj)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-32&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeoddvalues&#34;&gt;removeOddValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeOddValues&amp;rdquo;. (&amp;ldquo;removeOddValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeOddValues&amp;rdquo; removes any properties whose values are odd numbers. (객체가 주어졌을때, &amp;ldquo;removeOddValues&amp;rdquo; 함수는 주어진 객체의 속성값이 홀수인 속성을 모두 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-31&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let obj = {
  a: 2,
  b: 3,
  c: 4,
  d: 7
};
function removeOddValues(obj) {
  // your code here
  // 1. value 을 불러온다
  // 2. value 홀수 있지 짝수 인지 구분한다.
  // 3. value 가 홀수 일때 삭제한다.
  for ( let key in obj ) {
    if ( obj[key] % 2 === 1 ) {
      delete obj[key];
    }
  }
  return obj;
  }
  removeOddValues(obj)


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-33&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;countnumberofkeys&#34;&gt;countNumberOfKeys&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;countNumberOfKeys&amp;rdquo;. (&amp;ldquo;countNumberOfKeus&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;countNumberOfKeys&amp;rdquo; returns how many properties the given object has. (객체가 주어졌을때, &amp;ldquo;countNumberOfKeys&amp;rdquo; 함수는 객체안에 있는 속성들의 갯수를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-32&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function countNumberOfKeys(obj) {
  // 여기에 코드를 작성하세요
  // 1.숫자출력할 변수를 0으로 초기화한다.
  // 2.for 문을 이용해 객체를 나열한다.
  // 3. 나열한 객체를 변수안에 넣는다.
  let count = 0;
  for ( let key in obj ) {
    count = count + 1 ;
    }
    return count;
}

let obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4
};
countNumberOfKeys(obj)



// * Model Solutions

function countNumberOfKeys(obj) {
  return Object.keys(obj).length;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-34&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;printobject&#34;&gt;printObject&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;객체를 파라미터로 받는 printObject 함수는 객체 안에 정의된 키와 값 쌍을 조합한 문자열을 리턴합니다. 문자열은 한 줄에 하나의 키/값 쌍을 콜론(:) 및 공백문자와 함께 표시하며, 또다른 키/값 쌍 사이에는 줄바꿈 문자가 포함되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-33&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
let obj = { name: &#39;Steve&#39;, age: 13, sex: &#39;Male&#39; };

function printObject(obj) {
  let ret = &amp;quot;&amp;quot;
  for ( let key in obj ) {
    ret = ret + key +&amp;quot;: &amp;quot; + obj[key]+ &amp;quot;\n&amp;quot;;
  }
  return ret;
};
printObject(obj);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-35&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;extends&#34;&gt;extends&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;extend&amp;rdquo;. (&amp;ldquo;extend&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two objects, &amp;ldquo;extend&amp;rdquo; adds properties from the 2nd object to the 1st object. (객체 두개가 주어졌을때, &amp;ldquo;extend&amp;rdquo; 함수는 두번째 객체의 속성을 첫번째 객체에 추가해야 합니다.)&lt;/p&gt;

&lt;p&gt;Add any keys that are not in the 1st object. (첫번째 객체에 없는 모든 키를 추가하세요.)&lt;/p&gt;

&lt;p&gt;If the 1st object already has a given key, ignore it (do not overwrite the property value). (만약 첫번째 객체에 이미 있는 키라면, 값을 덮어쓰지 말고 무시하세요.)&lt;/p&gt;

&lt;p&gt;Do not modify the 2nd object at all. (두번째 객체는 수정하지 마세요.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-34&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
et obj1 = {
  a: 1,
  b: 2
};
let obj2 = {
  b: 4,
  c: 3
};

function extend(obj1, obj2) {

  // 여기에 코드를 작성하세요
  // 1. obj2 의 key들을 반복합니다.
  // 2. obj2 안에 있는 key 가  obj1 key 안에에 포함 되어있는지 if 문을 써서 확인한다.
  // 4. 포함되어있지 않으면 ob1에 추가한다.
  
  for ( let key in obj2 ) {
      if (!( key in obj1 )) {
        obj1[key] = obj2[key];
      }
    }
  }
  

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-36&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;countallcharacters&#34;&gt;countAllCharacters&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;countAllCharacters&amp;rdquo;. (&amp;ldquo;countAllCharacters&amp;rdquo; 함수를 작성하세요&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Given a string, &amp;ldquo;countAllCharacters&amp;rdquo; returns an object where each key is a character in the given string. The value of each key should be how many times each character appeared in the given string. (문자열이 주어졌을때, &amp;ldquo;countAllCharacters&amp;rdquo; 함수는 주어진 문자열의 각각의 문자를 키로 가지는 객체를 반환합니다. 각 키의 값은 해당 문자가 주어진 문자열에서 몇번 나오는지를 나타냅니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function countAllCharacters(str) {
  let obj = {};
  for (let i = 0; i &amp;lt; str.length; i++) { // input으로 받은 문자열에서 하나의 character씩 loop를 돕니다.
    
    if (obj[str[i]] === undefined) { 
// 그런데 obj란 객체에 character가 들어 있지 않다면 새로운 문자열이기 때문에 객체에 char를 추가하고 0으로 만들어 줍니다.
      obj[str[i]] = 0;
    }
    obj[str[i]]++;  // 그 이후 이 곳에서 char key의 value 값을 1 더해줍니다.
  }
  return obj;
}

let output = countAllCharacters(&#39;banana&#39;);
console.log(output); // --&amp;gt; {b: 1, a: 3, n: 2}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-37&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removestringvalues&#34;&gt;removeStringValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeStringValues&amp;rdquo;. (&amp;ldquo;removeStringValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeStringValues&amp;rdquo; removes any properties on the given object whose values are strings. (객체가 주어졌을때, &amp;ldquo;removeStringValues&amp;rdquo; 함수는 속성값이 문자열인 모든 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-35&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeStringValues(obj) {
  // 여기에 코드를 작성하세요.
  // 객체안에 있는 속성값이 문자열인지 판별한다.
  // 문자열이라면 삭제한다.
  for ( let prop in obj ) {
    if ( typeof obj[prop] === &amp;quot;string&amp;quot; ) {
      delete obj[prop]
    }
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-38&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removenumbervalues&#34;&gt;removeNumberValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeNumberValues&amp;rdquo;. (&amp;ldquo;removeNumberValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeNumberValues&amp;rdquo; removes any properties whose values are numbers. (객체가 주어졌을때, &amp;ldquo;removeNumberValues&amp;rdquo; 함수는 속성값이 숫자인 모든 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;my-soultion-36&#34;&gt;My_Soultion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let obj = {
  a: 2,
  b: &#39;remaining&#39;,
  c: 4
};


function removeNumberValues(obj) {
  // 여기에 코드를 작성하세요.
  // prop 을 불러온다.
  // 불러온 prop 값을 숫자인지 판별한다/
  // 숫자이면 제거한다
  for ( let prop in obj ) {
    if ( typeof obj[prop] === &amp;quot;number&amp;quot; ) {
      delete obj[prop]
    }
  } 
  return obj;
}

removeNumberValues(obj);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-39&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removearrayvalues&#34;&gt;removeArrayValues&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeArrayValues&amp;rdquo;. (&amp;ldquo;removeArrayValues&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, &amp;ldquo;removeArrayValues&amp;rdquo; removes any properties whose values are arrays. (객체가 주어졌을때, &amp;ldquo;removeArrayValues&amp;rdquo; 함수는 속성값이 배열인 모든 속성을 제거합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-37&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let obj = {
  a: [1, 3, 4],
  b: 2,
  c: [&#39;hi&#39;, &#39;there&#39;]
}
function removeArrayValues(obj) {
  // 여기에 코드를 작성하세요
  // prop 값을 불러온다
  // prop 값이 배열에 속하는지 판별한다
  // 배열에 속하면 제거한다.
  for ( let prop in obj ) {
    if (Array.isArray(obj[prop])) {
      delete obj[prop];
    }
  }
  return obj
}
removeArrayValues(obj)



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-40&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getfirstelement&#34;&gt;getFirstElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getFirstElement&amp;rdquo;. (&amp;ldquo;getFirstElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getFirstElement&amp;rdquo; returns the first element of the given array. (배열이 주어졌을때, &amp;ldquo;getFirstElement&amp;rdquo; 함수는 주어진 배열의 첫번째 요소를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-38&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getFirstElement(array) {
  // 여기에 코드를 작성하세요.
  // 배열을 0번째 숫자를 불러온다.
  if ( array.length === 0 ) {
    return undefined;
  } else
  return array[0];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-41&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlastelement&#34;&gt;getLastElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLastElement&amp;rdquo;. (&amp;ldquo;getLastElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getLastElement&amp;rdquo; returns the last element of the given array. (배열이 주어졌을때, &amp;ldquo;getLastElemeent&amp;rdquo; 함수는 주어진 배열의 마지막 요소를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-39&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getLastElement(array) {
  // 여기에 코드를 작성하세요
  // 만약 배열의 길이가 0 이라면 undefinded 출력
  // 아니라면 return 마지막 배열숫자 출력
  if ( array.length === 0 ) {
    return undefined;
  } else {
    let lastNum = array[array.length -1]
    return lastNum;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-42&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getnthelement&#34;&gt;getNthElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getNthElement&amp;rdquo;. (&amp;ldquo;getNthElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an integer, &amp;ldquo;getNthElement&amp;rdquo; returns the element at the given integer, within the given array. (배열과 숫자가 주어졌을때, &amp;ldquo;getNthElement&amp;rdquo; 함수는 주어진 배열에서 n번 인덱스의 요소를 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-40&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getNthElement(array, n) {
  // 여기에 코드를 작성하세요
  // 만약 배열에 길이가 0보다 크면 코드 진행실행 아니면 undefinded
  // 배열에 n번째 있는 숫자를 변수에 저장
  // 배열안에 있는 n 번째의 숫자 출력
  if ( array.length &amp;gt; 0 ) {
    let ret = array[n];
    return ret;
  } else {
    return undefined;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-43&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addtofront&#34;&gt;addToFront&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;addToFront&amp;rdquo;. (&amp;ldquo;addToFront&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an element, &amp;ldquo;addToFront&amp;rdquo; adds the given element to the front of the given array, and returns the given array. (배열과 요소가 주어졌을때, &amp;ldquo;addToFront&amp;rdquo; 함수는 주어진 요소를 배열의 맨앞에 추가하고 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-41&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function addToFront(arr, element) {
  arr.unshift(element);
  return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-44&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addtoback&#34;&gt;addToBack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;addToBack&amp;rdquo;. (&amp;ldquo;addToBack&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an element, &amp;ldquo;addToBack&amp;rdquo; returns the given array with the given element added to the end. (배열과 요소가 주어졌을때, &amp;ldquo;addToBack&amp;rdquo; 함수는 주어진 요소를 배열의 맨뒤에 추가하고 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-42&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function addToBack(arr, element) {
  // 여기에 코드를 작성하세요.
  // push 사용해 element 값을 뒤에 추가한다.
  arr.push(element);
  return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-45&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;joinarrays&#34;&gt;joinArrays&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;joinArrays&amp;rdquo;. (&amp;ldquo;joinArrays&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given two arrays, &amp;ldquo;joinArrays&amp;rdquo; returns an array with the elements of &amp;ldquo;arr1&amp;rdquo; in order, followed by the elementsin &amp;ldquo;arr2&amp;rdquo;. (두 배열이 주어졌을때, &amp;ldquo;joinArrays&amp;rdquo; 함수는 첫번째 배열(arr1)과 두번째 배열(arr2) 순서로 합쳐진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-43&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function joinArrays(arr1, arr2) {
  // your code here
  // 변수를 만들어 배열1에 배열2를 집어넣는다.
  // 출력한다.
  let arrRet = arr1.concat(arr2);
  return arrRet
  
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-46&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementsafter&#34;&gt;getElementsAfter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementsAfter&amp;rdquo;. (&amp;ldquo;getElementsAfter&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an index, &amp;ldquo;getElementsAfter&amp;rdquo; returns a new array with all the elements after (but not including) the given index. (배열과 인덱스가 주어졌을때, &amp;ldquo;getElementsAfter&amp;rdquo; 함수는 주어진 배열의 인덱스 이후 요소들을 (자신은 포함하지 않고) 새로운 배열로 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-44&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementsAfter(array, n) {
  // your code here
  // 새로운 빈배열을 만든다.
  // 초기값을 n+1을 한 for 문을 이용해 배열인덱스를 불러온다.
  // 불러온 값을 새로운 배열에 push를 사용해 담는다.
  // 출력한다.
  let newArr = [];
  for (let i = n + 1;  i &amp;lt; array.length; i = i + 1 ) {
    newArr.push(array[i]);
  }
  return newArr;
}
getElementsAfter([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], 1);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-47&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementsupto&#34;&gt;getElementsUpTo&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementsUpTo&amp;rdquo;. (&amp;ldquo;getElementsUpTo&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and a index, &amp;ldquo;getElementsUpTo&amp;rdquo;, returns an array with all the elements up until, but not including, the element at the given index. (배열과 인덱스가 주어졌을때, &amp;ldquo;getElementsUpTo&amp;rdquo; 함수는 주어진 배열의 인덱스 이전 요소들을 (자신은 포함하지 않고) 새로운 배열로 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-45&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementsUpTo(array, n) {
  let newArr = array.slice(0,n);
  return newArr
}
getElementsUpTo([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], 3);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-48&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallelementsbutfirst&#34;&gt;getAllElementsButFirst&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllElementsButFirst&amp;rdquo;. (&amp;ldquo;getAllElementsButFirst&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getAllElementsButFirst&amp;rdquo; returns an array with all the elements but the first. (배열이 주어졌을때, &amp;ldquo;getAllElementsButFirst&amp;rdquo; 함수는 첫번째 요소를 제외한 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-46&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getAllElementsButFirst(array) {
  // your code here
  // shift 를 이용해서 앞에 있는 요소를 뺀다.
  // 그리고 기존에 배열을 출력한다. 
  array.shift();
  return array;
}

getAllElementsButFirst([1,2,3,4])


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-solution&#34;&gt;model solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getAllElementsButFirst(array) {
  return array.slice(1, array.length);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-49&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallelementsbutlast&#34;&gt;getAllElementsButLast&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllElementsButLast&amp;rdquo;. (&amp;ldquo;getAllElementsButLast&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getAllElementsButLast&amp;rdquo; returns an array with all the elements but the last. (배열이 주어졌을때, &amp;ldquo;getAllElementsButLast&amp;rdquo; 함수는 마지막 요소를 제외한 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-47&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getAllElementsButLast(array) {
  // your code here
  // slice 를 이용해서 마지막 숫자를 삭제한다.
  // 출력한다.
  array.pop()
  return array
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-50&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removefromfront&#34;&gt;removeFromFront&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeFromFront&amp;rdquo;. (&amp;ldquo;removeFromFront&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;removeFromFront&amp;rdquo; returns the given array with its first element removed. (배열이 주어졌을때, &amp;ldquo;removeFromFront&amp;rdquo; 함수는 첫번째 요소를 삭제한 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-48&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeFromFront(arr) {
  // your code here
  // 메소드 사용해서 첫번째요소 자르기 
  arr.shift();
  return arr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-51&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removefromback&#34;&gt;removeFromBack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeFromBack&amp;rdquo;. (&amp;ldquo;removeFromBack&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;removeFromBack&amp;rdquo; returns the given array with its last element removed. (배열이 주어졌을때, &amp;ldquo;removeFromBack&amp;rdquo; 함수는 마지막 요소를 삭제한 주어진 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-49&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeFromBack(arr) {
  // your code here
  //배열 메소드 이용해서 뒤에 있는거 자르기
  arr.pop();
  return arr;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-52&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removefrombackofnew&#34;&gt;removeFromBackOfNew&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeFromBackOfNew&amp;rdquo;. (&amp;ldquo;removeFromBackOfNew&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;removeFromBackOfNew&amp;rdquo; returns a new array containing all but the last element of the given array. (배열이 주어졌을때, &amp;ldquo;removeFromBackOfNew&amp;rdquo; 함수는 마지막 요소를 제외한 모든 요소를 가지고 있는 새로운 배열을 반환해야 합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-50&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function removeFromBackOfNew(arr) {
  // your code here
  // 빈 배열을 만든다. 
  // 배열을 가져오는데 length를 이용해 마지막숫자를 뺀수를 가져온다
  // 가져온 숫자를 새로운 배열에 넣는다. 
  // arrNew 를 출력한다. 
  let arrNew = [];
  for (let i = 0; i &amp;lt; arr.length -1; i = i + 1 ) {
    arrNew.push(arr[i]);
  }
  return arrNew
  }


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-solution-1&#34;&gt;model solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function removeFromBackOfNew(arr) {
  // your code here
  // 마지막 숫자를 뺀 배열값을 변수에 담는다.
  // 담은 변수를 출력한다.
  let sliced = arr.slice(0,arr.length-1)
  return sliced; 
  
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-53&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;addtobackofnew&#34;&gt;addToBackOfNew&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;addToBackNew&amp;rdquo;. (&amp;ldquo;addToBackNew&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an element, &amp;ldquo;addToBackNew&amp;rdquo; returns a clone of the given array, with the given element added to the end. (배열과 요소가 주어졌을때, &amp;ldquo;addToBackNew&amp;rdquo; 함수는 주어진 배열의 복사본 끝에 주어진 요소가 추가된 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-51&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function addToBackOfNew(arr, element) {
  // your code here
  arr = arr.concat(element);
  return arr;
  }
  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;model-soultion&#34;&gt;model soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function addToBackOfNew(arr, element) {
  const newArr = arr.slice();
  newArr.push(element);
  return newArr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-54&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;joinarrayofarrays&#34;&gt;joinArrayOfArrays&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;joinArrayOfArrays&amp;rdquo;. (&amp;ldquo;joinArrayOfArrays&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of arrays, &amp;ldquo;joinArrayOfArrays&amp;rdquo; returns a single array containing the elements of the nested arrays. (배열들의 배열이 주어졌을때, &amp;ldquo;joinArrayOfArrays&amp;rdquo; 함수는 배열들의 요소를 모두 담고 있는 단일 배열을 반환합니다.)&lt;/p&gt;

&lt;p&gt;it is used by reduce and concat&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-52&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function joinArrayOfArrays(arr) {

  output = arr.reduce(function(acc,cur) {
    return acc.concat(cur); 
    })
    return output;
  }


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-55&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallletters&#34;&gt;getAllLetters&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllLetters&amp;rdquo;. (&amp;ldquo;getAllLetters&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a word, &amp;ldquo;getAllLetters&amp;rdquo; returns an array containing every character in the word. (단어가 주어졌을때, &amp;ldquo;getAllLetters&amp;rdquo; 함수는 주어진 단어에 포함된 모든 문자를 담고 있는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-53&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getAllLetters(str) {
  // your code here
  // 만약 빈문자 열이라면 빈 배열을 리턴한다.
  // 만약 빈배열이 아니라면 문자를 split method 사용한다.
  if ( str === &amp;quot;&amp;quot; ) {
    return str = [];
  } else {
    return str.split(&amp;quot;&amp;quot;)
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-56&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallwords&#34;&gt;getAllWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllWords&amp;rdquo;. (&amp;ldquo;getAllWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given a sentence, &amp;ldquo;getAllWords&amp;rdquo; returns an array containing every word in the sentence. (문장이 주어졌을때, &amp;ldquo;getAllWords&amp;rdquo; 함수는 주어진 문장에 포함된 모든 단어를 담고 있는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-54&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
 
 function getAllWords(str) {
  if (str === &#39;&#39;) {
    return [];
  } else {
    return str.split(&#39; &#39;);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-57&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;removeelement&#34;&gt;removeElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;removeElement&amp;rdquo;. (&amp;ldquo;removeElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of elements, and a &amp;ldquo;discarder&amp;rdquo; parameter, &amp;ldquo;removeElement&amp;rdquo; returns an array containing the items in the given array that do not match the &amp;ldquo;discarder&amp;rdquo; parameter. (배열과 &amp;ldquo;discarder&amp;rdquo; 매개변수가 주어졌을때, &amp;ldquo;removeElement&amp;rdquo; 함수는 주어진 배열에서 &amp;ldquo;discarder&amp;rdquo; 매개변수와 일치하지 않는 모든 요소를 포함하는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-55&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

unction removeElement(array, discarder) {
  // your code here
   /* 
  1. 빈배열이면 빈배열을 반환
  2. 새로운 빈배열을 만든다. newArr
  3. 모든 element를 조사한다.
  4. element가 discarder와 다르다면 newArr에 push로 넣는다.
  5. 위에경우가 아니라면 newArr을 반환
   */

  if ( array === [] ) {
    return [];
  }
  let newArr = [];
  for (let i = 0; i &amp;lt; array.length; i = i + 1 ) {
    if ( discarder !== array[i] ) {
      newArr.push(array[i])
    } 
  }
  return newArr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-58&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;keep&#34;&gt;keep&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;keep&amp;rdquo;. (&amp;ldquo;keep&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and a keeper element, &amp;ldquo;keep&amp;rdquo; returns an array containing the items that match the given keeper element. (배열과 &amp;ldquo;keeper&amp;rdquo; 매개변수가 주어졌을때, &amp;ldquo;keep&amp;rdquo; 함수는 &amp;ldquo;keeper&amp;rdquo; 매개변수와 일치하는 모든 요소&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-56&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function keep(array, keeper) {
  // your code here
  // 만약 배열이 비워있다면 빈배열 리턴
  // 새로운 빈배열을 만든다.
  // for 문을 사용해 배열을 조사
  // 만약 keeper라는 매개변수가 있는지 조사
  // 만약 있다면 push를 사용해 새로운 배열에 투입
  // 새로운 배열 출력
  if ( array === []) {
    return [];
  }
  let newArr = [];
  for ( let i = 0; i &amp;lt; array.length; i = i + 1 ) {
    if ( array[i] === keeper ) {
      newArr.push(array[i]);
    }
  }
  return newArr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-59&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;findsmallestelement&#34;&gt;findSmallestElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;findSmallestElement&amp;rdquo;. (&amp;ldquo;findSmallestElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;findSmallestElement&amp;rdquo; returns the smallest number within the given array. (숫자의 배열이 주어졌을때, &amp;ldquo;findSmallestElement&amp;rdquo; 함수는 주어진 배열에서 가장 작은 수를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution&#34;&gt;My_solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// It is used by sort();



function findSmallestElement(arr) {

  만약 arr 비워있다면 빈배열 리턴
  메소드 slice()이용해 복사 
  복사한 배열을 sort()를 이용해 작은숫자가 앞으로 올수 있도록 정렬
  0번째 있는 요소 출력


  if ( arr.length === 0 ){ 
    return 0;
  }
  let newArr = arr.slice();
  let sortArr = function(a,b) {
    return a-b;
  }
  newArr.sort(sortArr); 
  return newArr[0];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by reudce and if 

function findSmallestElement(arr) {
  if (arr.length &amp;lt; 1) {  // satisfies Notes requirement
    return 0;
  }
  var newNum = arr[0];  // create number placeholder (start with first number of array)
  for (let i in arr) {  // iterate thru array
    if (arr[i] &amp;lt; newNum) {  // if element is larger than current placeholder number
      newNum = arr[i];  // make that element the new placeholder number
    }
  }
  return newNum;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by reudce and if ????? 


function findSmallestElement(arr) {
  
  if(arr.length === 0) {
    return 0;
  } else {
    var smallestNum = arr.reduce(function(a,b) {
      return a &amp;lt; b ? a: b;
    });
    return smallestNum;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// it is used by reudce and Math method

function findSmallestElement(arr) {

  if ( arr.length === 0 ) {
    return 0;
  }

  output = arr.reduce(function(acc,cur){
    return Math.min(acc,cur);

  })  
  return output;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// it is used by reudce and Math method

function findSmallestElement(arr) {

  if ( arr.length === 0 ) {
    return 0;
  }

  return Math.min(...arr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-60&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computesumofallelements&#34;&gt;computeSumOfAllElements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeSumOfAllElements&amp;rdquo;. (&amp;ldquo;computeSumOfAllElements&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;computeSumOfAllElements&amp;rdquo; returns the sum of all the elements in the given array. (숫자의 배열이 주어졌을때, &amp;ldquo;computeSumOfAllElements&amp;rdquo; 함수는 주어진 배열의 모든 요소의 합을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-1&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function computeSumOfAllElements(arr) {
  
  // your code here.
  // 빈 배열을 만든다.
  // count 변수 초기화 한해서 만든다.
  // arr 안에 값들을 조사한다.
  // count 변수안에 조사한 값들을 더해서 넣는다.
  let sum = 0;
  for ( let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
    sum = sum + arr[i];
  }
  return sum
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// it used by reduce 


function computeSumOfAllElements(arr) {
  if ( arr.length === 0 ) {
    return 0;
  }
  return arr.reduce(function(acc,val){
    return acc + val;
  })
  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-61&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;computeproductofallelements&#34;&gt;computeProductOfAllElements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;computeProductOfAllElements&amp;rdquo;. (&amp;ldquo;computeProductOfAllElements&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of numbers, &amp;ldquo;computeProductOfAllElements&amp;rdquo; returns the products of all the elements in the given array. (숫자의 배열이 주어졌을때, &amp;ldquo;computeProductOfAllElements&amp;rdquo; 함수는 주어진 배열의 모든 요소의 곱을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-2&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;



function computeProductOfAllElements(arr) {
  
  // 먄약 배열이 비워있다면 0 리턴;
  // 0으로 된 마지막에 출력할 변수 생성;
  // for 문을 사용해 배열안에 있는 요소 조사
  // 생성한 변수 안에 조사한 요소들을 곱셈하여 넣는다.
  // 변수 출려
  
  if ( arr.length === 0 ) {
    return 0;
  }
  let ret = 1;
  for ( let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
    ret = ret * arr[i];
  } 
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

// It is used by redcue method
function computeProductOfAllElements(arr) {
    
    
    if ( arr.length === 0 ) {
    return 0;
  }
  return arr.reduce(function(acc,cur) {
    return acc * cur;
  })

}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-62&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlengthoflongestelement&#34;&gt;getLengthOfLongestElement&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLengthOfLongestElement&amp;rdquo;. (&amp;ldquo;getLengthOfLongestElement&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array, &amp;ldquo;getLengthOfLongestElement&amp;rdquo; returns the length of the longest string in the given array. (배열이 주어졌을때, &amp;ldquo;getLengthOfLongestElement&amp;rdquo; 함수는 주어진 배열에서 가장 긴 문자열의 길이를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-3&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// it is used by sort()


function getLengthOfLongestElement(arr) {

  if ( arr.length === 0 ){
    return 0;
  } 
  sortArr = function (a, b) { 
    return b.length - a.length;
    }
    let ret = arr.sort(sortArr)[0]
    return ret.length;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by for loop and if


function getLengthOfLongestElement(arr) {
  
  if ( arr.length === 0 ) {
    return 0;
  } 

  let lgth = 0; // =&amp;gt; 3  =&amp;gt;5
  let longest;  // =&amp;gt;&amp;quot;one&amp;quot; =&amp;gt; &amp;quot;three&amp;quot; 
  
  for ( let i = 0; i &amp;lt; arr.length; i = i + 1) {
    if(arr[i].length &amp;gt; lgth) {
      // 첫번째 요소는 &amp;quot;one&amp;quot; 길이는 3 &amp;gt; 0
      // 두번째 요소는 &amp;quot;two&amp;quot; 길이는 3 &amp;gt; 3 : 실행이 안됨
      // 세번째 요소는 &amp;quot;three&amp;quot; 길이는 5 &amp;gt; 3 : 실행되면서 최종적으로 longest변수에 &amp;quot;three&amp;quot;가 담긴다. 
        lgth = arr[i].length;
        longest = arr[i].length;
    }      
  } 
  return longest;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


/*


it is used by reduce method

comment

return a.length or return b.length 하면 안되는 이유. length를 리턴에 넣으면 다음  a 와 b.length의 길이를 비교하기 때문에 안되는거더라구요. 그래서 함수 밖에 붙여주면 숫자로 반환되는 거구요.




*/

function getLengthOfLongestElement(arr) {

 
 return arr.reduce(function(a,b) {
      if (a.length &amp;gt;= b.length) {
        return a;
      } else {
        return b;
      }
  }).length
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-63&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;filteroddlengthwords&#34;&gt;filterOddLengthWords&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;filterOddLengthWords&amp;rdquo;. (&amp;ldquo;filterOddLengthWords&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array of string, &amp;ldquo;filterOddLengthWords&amp;rdquo; returns an array containing only the elements of the given array whose lengths are odd numbers. (문자열의 배열이 주어졌을때, &amp;ldquo;filterOddLengthWords&amp;rdquo; 함수는 주어진 배열의 요소 중 문자열의 길이가 홀수인 문자열만을 요소로 가지는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-57&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


unction filterOddLengthWords(words) {

  // it passed test
  // it&#39;s good to practice useing filter 

  // your code here
  // output 빈 배열을 만든다.
  // for 문을 이용해 배열안에 있는 요소를 조사한다.
  // 만약 배열안에 있는 각각의 요소가 홀수라면 ture
  // ture 인 값을 output 배열에 넣는다.
  // 넣은 값을 출력한다.
  
  let output = [];
  for  ( let i = 0; i &amp;lt; words.length; i = i + 1 ) {
    if ( words[i].length % 2 !== 0 ) { 
      output.push(words[i]);
    }
  }
  return output;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;modle-soultion&#34;&gt;modle_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


// input: an array of strings
// output: return an array containing only the elements of the given array whose lengths are odd numbers

function filterOddLengthWords(arr) {  // HoF
  return arr.filter(function(i) {  // filters each even length elements to its own array
    return i.length % 2 !== 0;
  });
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-64&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementofarrayproperty&#34;&gt;getElementOfArrayProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementOfArrayProperty&amp;rdquo;. (&amp;ldquo;getElementOfArrayProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object, a key, and a numerical index, &amp;ldquo;getElementOfArrayProperty&amp;rdquo; returns the value of the element at the given index of the array located within the given object at the given key. (객체와 키, 그리고 숫자로된 인덱스값이 주어졌을때, &amp;ldquo;getElementOfArrayProperty&amp;rdquo; 함수는 주어진 키에 위치한 배열의 인덱스에 해당하는 값을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-58&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementOfArrayProperty(obj, key, index) {
  // your code here
 
   if (!Array.isArray(obj[key])){
    return undefined;
  } 
  return obj[key][index]; 
} 
let obj = {
  key: [&#39;Jamil&#39;, &#39;Albrey&#39;]
};

getElementOfArrayProperty(obj,&#39;key&#39;,0);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-65&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;select&amp;rdquo;. (&amp;ldquo;select&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an array and an object, &amp;ldquo;select&amp;rdquo; returns a new object whose properties are those in the given object AND whose keys are present in the given array. (배열과 객체가 주어졌을때, &amp;ldquo;select&amp;rdquo; 함수는 주어진 객체의 키값 중 주어진 배열에 포함된 키값만을 속성으로 가지는 새로운 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-59&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function select(arr, obj) {
  // your code here
  let newObj = {};
  for (let key in obj ) {
    for (let i = 0; i &amp;lt; arr.length; i = i + 1 ) {
      if (key === arr[i] ) {
       newObj[key] = obj[key]
      }

    }

  } 
  return newObj;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-66&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getnthelementofproperty&#34;&gt;getNthElementOfProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getNthElementOfProperty&amp;rdquo;. (&amp;ldquo;getNthElementOfProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getNthElementOfProperty&amp;rdquo; returns the nth element of an array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getNthElementOfProperty&amp;rdquo; 함수는 주어진 키에 위차한 배열의 n번째 요소를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-60&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getNthElementOfProperty(obj, key, n) {
  // your code here
  // 만약 주어진 키에 위차하는 속성값이 배열이 아니라면 undefinded 
  // 만약 그게 아니라면 주어진 키값의 인덱스 번호 리턴
  if ( !Array.isArray(obj[key])) {
    return undefined;
  } else {
    return obj[key][n];
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-67&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getelementslessthan100atproperty&#34;&gt;getElementsLessThan100AtProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo;. (&amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo; returns an array containing all the elements of the array located at the given key that are less than 100. (객체와 키값이 주어졌을때, &amp;ldquo;getElementsLessThan100AtProperty&amp;rdquo; 함수는 주어진 키에 위치하는 배열에서 100 보다 작은 값으로만 이루어진 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-61&#34;&gt;MY_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getElementsLessThan100AtProperty(obj, key) {
  for (let prop in obj) {
    if (! Array.isArray(obj[key])){
    return [];
    } else if ( !prop in obj ) {
      return [];
    }
  }
    let retArr = [];
    for ( let prop2 in obj ) {
    for ( let i = 0; i &amp;lt; obj[prop2].length; i = i + 1) {
      if ( obj[prop2][i] &amp;lt; 100 ) {

        retArr.push(obj[prop2][i]);
      }

  }
    }
    return retArr;
  }



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;my-re-soultion&#34;&gt;My_Re_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getElementsLessThan100AtProperty(obj, key) {

  if ( ! Array.isArray(obj[key])) {
    return [];
  } else {
  return obj[key].filter(cur =&amp;gt; cur &amp;lt; 100);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-68&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getlastelementofproperty&#34;&gt;getLastElementOfProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getLastElementOfProperty&amp;rdquo;. (&amp;ldquo;getLastElementOfProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getLastElementOfProperty&amp;rdquo; returns the last element of an array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getLastElementOfProperty&amp;rdquo; 함수는 주어진 키에 위치한 배열의 마지막 요소를 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-4&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getLastElementOfProperty(obj, key) {
  
  // 1. 만약 key의 값에 prop 배열이 아니라면 undefined 출력
  // 2. 배열에 있는 마지막 요소 pop 메소드 이용해서 빼서 변수안에 넣기
  // 3. 변수 리턴 

  if (!Array.isArray(obj[key])) {
    return undefined;
    } else {
      let lastNum = obj[key].pop()
      return lastNum
  } 
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;modle-solution&#34;&gt;modle_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1.마지막 배열에 요소 가져오기 위해 length - 1 이라는 방법을 썻다.

function getLastElementOfProperty(obj, key) {
  let prop = obj[key];
  if (!Array.isArray(prop)) {
    return undefined
  }

  return prop[prop.length - 1]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-69&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getsquaredelementsatproperty&#34;&gt;getSquaredElementsAtProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getSquaredElementsAtProperty&amp;rdquo;. (&amp;ldquo;getSquaredElementsAtProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getSquaredElementsAtProperty&amp;rdquo; returns an array containing all the squared elements of the array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getSquaredElementsAtProperty&amp;rdquo; 함수는 주어진 키에 위치하는 배열의 요소들의 제곱을 요소로 가지는 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-62&#34;&gt;My_Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;

function getSquaredElementsAtProperty(obj, key) {


  
  // 1. 만약 주어진 key 의 값이 배열이 아니라면 빈배열 출력
  // 2. 만약 주어진 key 의 값이 길이가 0 같이 않다면 빈배열
  // 3. 마지막에 출력할 새로운 변수 생성
  // 4. 곱셈할 값을 넣기 위한 새로운 변수 또 생성 
  // 5. 배열안에 있는 요소들 곱하기
  // 6. 곱한값을 arr 이라는배열에 넣는다.    


 if (!Array.isArray(obj[key])) {
    return [];
 } else if (obj[key].length === 0 ){
   return [];
 }
  let arr = [];
  let conut;
  for ( let i = 0; i &amp;lt; obj[key].length; i = i + 1 ) {
    conut = obj[key][i]*obj[key][i];
    arr.push(conut);
  }
 return arr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-soultion&#34;&gt;other Soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;


function getSquaredElementsAtProperty(obj, key) {
  var arr = [];
  if(Array.isArray(obj[key])){
    for(var i in obj[key]){
      var squared =obj[key][i]*obj[key][i];
      arr.push(squared);
    }
  }
  return arr;
}

var obj = {
  key: [2, 1, 5]
};
var output = getSquaredElementsAtProperty(obj, &#39;key&#39;);
console.log(output);


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-70&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getallbutlastelementofproperty&#34;&gt;getAllButLastElementOfProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getAllButLastElementOfProperty&amp;rdquo;. (&amp;ldquo;getAllButLastElementOfProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getAllButLastElementOfProperty&amp;rdquo; returns an array containing all but the last element of the array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getAllButLastElementOfProperty&amp;rdquo; 함수는 주어진 키에 위치하는 배열의 마지막 요소를 제외한 배열을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-solution-5&#34;&gt;My_Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getAllButLastElementOfProperty(obj, key) {
  
  
  // 1.마지막에 출력할 arr 빈배열 생성
  // 2.만약 key의 값의 prop 가 배열이 아니라면 빈배열 리턴
  // 3.만약 key의 값의 prop 의 길이가 0 과 같이 않다면 빈배열 리턴
  // 4.선언된 arr 안에 obj[key] 값을 넣는다.
  // 5.pop()메소드 사용해 마지막 요소 제거
  // 6.arr 리턴


  let arr = [];
  if (!Array.isArray(obj[key])) {
    return [];
  } else if ( obj[key].length === 0 ) {
    return [];
  } else {
    arr = obj[key];
    arr.pop()
  }
  return arr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;question-71&#34;&gt;Question&lt;/h3&gt;

&lt;h2 id=&#34;getproductofallelementsatproperty&#34;&gt;getProductOfAllElementsAtProperty&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function called &amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo;. (&amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo; 함수를 작성하세요.)&lt;/p&gt;

&lt;p&gt;Given an object and a key, &amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo; returns the product of all the elements in the array located at the given key. (객체와 키가 주어졌을때, &amp;ldquo;getProductOfAllElementsAtProperty&amp;rdquo; 함수는 주어진 키에 위치한 배열의 요소의 곱을 반환합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;my-soultion-63&#34;&gt;My_soultion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by for 


function getProductOfAllElementsAtProperty(obj, key) {

  // 1. arr 변수 만들어 key값의 prop 값을 넣는다
  // 2. 곱한값을 담을 sum 이라는 변수 생성 
  // 3. 만약 key의 prop 배열이 아니라면 0을 리턴
  // 4. 만약 key의 prop 길이가 0 과 같다면  0;
  // 5. for 문사용해 arr안에 있는 숫자를 곱한값을 sum 안에 저장
  // 6. sum 출력 
  
  
  let arr = obj[key];
  let sum = 1;
  if ( !Array.isArray(obj[key])) {
    return 0;
  } else if ( obj[key].length === 0 ) {
    return 0;
  }
  for ( let n = 0 ; n &amp;lt; arr.length ; n = n + 1 ) {
    sum = sum * arr[n];
  }
  return sum;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// It is used by reduce

function getProductOfAllElementsAtProperty(obj, key) {
  if (! Array.isArray(obj[key] )) {
    return 0; 
  } else if ( obj[key].length === 0 ){
    return 0;
  }
  let arr = obj[key];
  return arr.reduce(function(acc,cur) {
    return acc * cur;
  }) 
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>_section3</title>
      <link>/tutorial/javascript_q2/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/javascript_q2/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/tutorial/Javascript_Dictionary_files/javascriptt-light_870x220.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;다-완료&#34;&gt;다 완료&lt;/h2&gt;

&lt;h2 id=&#34;dom&#34;&gt;Dom&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;


&amp;lt;!-- div 안에 element 를 추가하는 방법 3가지  --&amp;gt;

  

  &amp;lt;!-- 첫번째 방법 HTML --&amp;gt;
  &amp;lt;div id = &amp;quot;comments&amp;quot;&amp;gt;커피메뉴판&amp;lt;/div&amp;gt;
  
  &amp;lt;script&amp;gt;
  // innerHTML 로 tag 까지 같이 한번에 집어넣는다 
  let comments = document.querySelector(&amp;quot;#comments&amp;quot;);
  comments.innerHTML = &amp;quot;&amp;lt;span&amp;gt;아메리카노&amp;lt;span&amp;gt;&amp;quot;;

  &amp;lt;/script&amp;gt;
  
  
  

  &amp;lt;!-- 두번째 방법 HTML --&amp;gt;
  &amp;lt;div id = &amp;quot;comments&amp;quot;&amp;gt;커피메뉴판&amp;lt;/div&amp;gt; 

  &amp;lt;script&amp;gt;
  
  // element 를 생성해서 집어넣을때는 appendChild 로 집어넣는다. 
  
  let comments = document.querySelector(&amp;quot;#comments&amp;quot;);
  let newElement = document.createElement(&amp;quot;span&amp;quot;); // element 생성
  newElement.innerHTML = &amp;quot;아메리카노&amp;quot;; //  생성된 element  안에 미리 써준다.
  comments.appendChild(newElement); // 집어넣을 comments태그 안에 생성된 elemment를 집어넣는다.
&amp;lt;/script&amp;gt;
  
  
  
  &amp;lt;!-- 세번째 방법 HTML --&amp;gt;

  &amp;lt;template id = &amp;quot;cloneTem&amp;quot;&amp;gt;
  
    &amp;lt;div&amp;gt;새로운 커피매뉴판&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;아메리카노&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;flat_Write&amp;lt;/span&amp;gt;
    &amp;lt;spand&amp;gt;라때&amp;lt;/spand&amp;gt;
  
  &amp;lt;/template&amp;gt; 
  
  &amp;lt;div id = &amp;quot;comments&amp;quot;&amp;gt;커피메뉴판&amp;lt;/div&amp;gt;  
  
  
  
  
  &amp;lt;script&amp;gt;
// 미리 HTML 안에 만들어 놓고 importNode 와 appendChild 사용해서 기존에 있는 template 의 등록한다. 그러먼 id=&amp;quot;comments&amp;quot;에 있는 div 안에 cloneTem 안에 있는 내용들이 담긴다. 

  let comments = document.querySelector(&amp;quot;#comments&amp;quot;); // 집어넣장소가져온다
  let template = document.querySelector(&amp;quot;#cloneTem&amp;quot;); // 
  
  // 새로운 변수를 만들어 template 에있는 모든 content 를 복사해서 집어넣는다. 
  let newComment = document.importNode(template.content,true);  

  comments.innerHTML = &amp;quot;&amp;quot; // 집어넣을 공간을 싹다 지운다 // 커피 메뉴판 날라간다.
  comments.appendChild(newComment) 
  
&amp;lt;/script&amp;gt;  



&amp;lt;!-- HTML 결과  --&amp;gt;
&amp;lt;!-- element 와 id 값이 기존에 elemment 로 바뀌었다  --&amp;gt;
  &amp;lt;div id = &amp;quot;comments&amp;quot;&amp;gt;
  
  &amp;lt;div&amp;gt;새로운 커피매뉴판&amp;lt;/div&amp;gt;
  &amp;lt;span&amp;gt;아메리카노&amp;lt;/span&amp;gt;
  &amp;lt;span&amp;gt;flat_Write&amp;lt;/span&amp;gt;
  &amp;lt;spand&amp;gt;라때&amp;lt;/spand&amp;gt;

  &amp;lt;/div&amp;gt;   



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;call&#34;&gt;call()&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 사용방법 

function identify() {
	return this.name;
}
function speak() {
	var greeting = &amp;quot;hello, I am &amp;quot; + identify.call(this);
	console.log(greet);
}
var me = { name : &amp;quot;jj&amp;quot;};
var you = {name : &amp;quot;Tim&amp;quot;};

// 호출
identify.call(me) // identify함수를 호출한다. return 값의 있는  this 는 me가 된다


// &amp;quot;jj&amp;quot;
speak.call(you) // speak 함수를 호출한다. return 값의 있는  identify 함수가호출된다 마지막으로 this는 you 가 된다.

// hello, I am Tim
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;call-과-apply-의-차이&#34;&gt;call() 과 apply() 의 차이&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// this 값을 넘겨주는 방식이 틀림
// call() and apply()  사용해서 함수안에있는 parameter 사용하기 


var obj = { 
val : 0
}; 

var add = function  ( x , y ) {
	this.val = x + y ;   //  리턴값이 출력되는 것이 아니라 this값이 obj 가 됨으로 obj.val =  2 +3 // 이것을 해주기 위해  add.call(obj,2,3); or add.apply(obj,[2,3]);

add.call(obj,2,3);  // 5 동일다. 
add.apply(obj,[2,3]); // 5  동일하다. 
	
// arr 안에 가장 큰수를 가져오는 방법 apply() 메소드 써서 가져올수 있다.

let arr = [1,2,3,4,5,6];
Math.max.apply(null,arr);

// 6

	
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;class-객체지향-프로그래밍&#34;&gt;Class : 객체지향 프로그래밍&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;



function Car(band,name,color) {
    // 인스턴스가 만들어 질때  실행될 코드들... 
}

// new 키워드를 통해 클라스의 인스턴스를 만들어낼 수 있습니다. 


// Car 라는 class 만들어 낼때 class는 2가지를 갖게 된다.

// 1. 속성  : band,name,color , currentFuel,maxSpeed
// 2. 메소드  : refuel() ,setSpeed(), drive()



// ex


// 1. 클라스 함수 와 인스턴스 생성 

function Car(brand,name,color) { // Car() 는 클라스
	
	this.what_brand = brand; // 여기서 this 는 인자값이 드러갈 변수이름 (avante)
	this.what_name = name;	
	this.what_color = color;
}

// 2. 클라스 함수를 변수에 담고 파라미터 들어갈 값들 넣는다. 

let avante = new Car(&amp;quot;GM&amp;quot;,&amp;quot;avante&amp;quot;,&amp;quot;black&amp;quot;); // 변수를 만든다 (인스턴스값으로 들어갈 )

// 3. 추가로 인스턴스를 생성 

Car.prototype.what_drive = function () { // Car() 인스턴스 생성 그리고 function 는 인스턴스 값  
    console.log(this.name + &amp;quot;가 운전을 합니다. &amp;quot;);
}


avante.what_name // 인스턴스 값 출력
// &amp;quot;avante&amp;quot;
avante.what_brand
// &amp;quot;GM&amp;quot;
avante.what_color
// &amp;quot;black&amp;quot;

avante.what_drive  // 새로 생성한 what_drive 출력 
// jj 가 운전을 합니다. 

`tip`

let arr = [1,2,3,4,5]     // 배열 만들기 
let arr = new Array(1,2,3,4,5) // 배열 만들기  // Array클라스 안에 (인자값들) 



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-1&#34;&gt;Closure 1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 1.클로저란?

함수는 함수를 리턴할수 있다.그것을 고차함수라고 하는데 그것을 클로저라 부른다. 한마디로 `외부함수의 변수에 접근할수 있는 함수`를  `클로저`라 부른다. 

// 2.특징 ?

// 클로저 함수의 장점은 지역변수 외부 함수의 변수 전역 변수 에 접근이 가능하다는 점이다 !



function foo() {
  return function() {
        return 2 
    }
}

foo() // f

// 2 가 반환되지 않고 
//f &amp;lt;&amp;lt; 함수 자체가 리턴된다 


// 클로저예제1 : 함수 이용해서 템플릿 함수 만들기


function htmlMark(tag) {
    let stratTag = &amp;quot;&amp;lt;&amp;quot; + tag + &amp;quot;&amp;gt;&amp;quot; ; 
    let endTag = &amp;quot;&amp;lt;&amp;quot; + tag + &amp;quot;&amp;gt;&amp;quot; ;
      return function(content) {     //  클로저 함수 사용 
        return stratTag + content + endTag;
    }
}

htmlMark(&amp;quot;h1&amp;quot;)(&amp;quot;JJ&amp;quot;); // 커링 사용해서 출력 tag : &amp;quot;h1&amp;quot; content:&amp;quot;JJ&amp;quot;
// &amp;gt;&amp;gt;&amp;gt; &amp;lt;h1&amp;gt;JJ&amp;lt;h1&amp;gt;

let h1Tag = htmlMark(&amp;quot;h1&amp;quot;); // 변수에 tag:&amp;quot;h1&amp;quot;담아서 지정하고 출력 

h1Tag(&amp;quot;JJ&amp;quot;)  //  content : &amp;quot;JJ&amp;quot;
// &amp;gt;&amp;gt;&amp;gt; &amp;lt;h1&amp;gt;JJ&amp;lt;h1&amp;gt;



// 클로저예제 2 : 클로저 모튤 패턴 


// 두 카운터가 각기 다른 privateCount 를 다루면서, privareCounter 을 밖에 노출시키지 않는 것이 장점이다. 

function makeCounter() {
	let privateCounter = 0; 

	let obj = {
	  plus : function() {
		  privateCounter = privateCounter + 1;
	  },	
	  minus: function() {
		  privateCounter = privateCounter - 1;
	  },
	  getValue: function() {
		  return privateCounter;
	  }
  }
  return obj;
};

let count1 = makeCounter() // 함수를 변수에 지정한다. 
count1.plus() // obj key값을 실행시키면 propo 값인 함수가 실행되면서 기존에 privateCounter 0 이였던 것을 1 증가시킨다. 

coun1.getValue() //  obj key값인 getValue() 함수를 실행시키면 지금까지 plus 하고 minus한 값을 출력 할수 있게 코드가 짜여 있다. 


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-2&#34;&gt;Closure 2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
//클로저는 독립적인 (자유) 변수를 가리키는 함수이다. 또는, 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’.

// 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다.


// 일반적인 함수


let addTo = function (passed) {

	let inner = 2;
	return passed + inner; 3 + 2 

};

console.log( addTo(3) ) //  5


//이것이 클로저

let passed = 3;  // 함수 밖에 변수를 선언한다 

let addTo = function () { //  parameter 를 외부에서가져온다. 

	let inner = 2;
	return passed + inner; 3 + 2  // 

};

console.log( addTo() ) //  5

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-3&#34;&gt;Closure 3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다.
// 자바스크립트에서 함수는 일급객체이다. 함수를 호출했을때 리턴되는 함수(클로저)를 참조하고 있는 것이다.
// 즉 반환되는 내부함수가 클로저이다.
 
function outter() {
    
    var title = &#39;난 영혼처럼 살아있다.&#39;;
    
    return function() {
        
        console.log(title); // 클로저로 참조되는 외부변수를 자유변수(Free Variable) 라 부른다.
        
    };
};
 
var inner = outter();  // 생명 주기가 끝난 외부함수의 변수를 참조하는 내부함수를 클로저라 한다.  
inner();  // 결과 : 난 영혼처럼 살아있다. 
 
 
 

// 매번 호출할때 마다 변수값을 유지하고 싶을때 사용한다.
// 클로저가 참조하고 있는 변수를 노출시키지 않는다 (캡슐화)
// 클로저에서는 접근할수 있지만 코드 외부에서는 접근할수 없다.

var a = function() {
    
    var count = 0;
 
    return function() {
         return count++;
    };
};
 
let next = a();
 
console.log(next());  
console.log(next());  
console.log(next());  
console.log(next());  


출처: https://mylife365.tistory.com/108?category=624212 [변화에 적응하기]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure-4&#34;&gt;Closure 4&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 추가설명 &amp;amp; 코드를 작성할때 많이 격는 어려움




/*

클로저는 JavaScript의 유효범위 체인을 이용하여 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 방법입니다. 외부 함수가 종료되더라도 내부함수가 실행되는 상태면 내부함수에서 참조하는 외부함수는 닫히지 못하고 내부함수에 의해서 닫히게 되어 클로저라 불리 웁니다. 따라서 클로저란 외부에서 내부 변수에 접근할 수 있도록 하는 함수입니다.

내부 변수는 하나의 클로저에만 종속될 필요는 없으며 외부 함수가 실행 될 때마다 새로운 유효범위 체인과 새로운 내부 변수를 생성합니다. 또, 클로저가 참조하는 내부 변수는 실제 내부 변수의 복사본이 아닌 그 내부 변수를 직접 참조합니다.

*/

function outerFunc(){  
    var a= 0;
    return {
        innerFunc1 : function(){
            a+=1;
            console.log(&amp;quot;a :&amp;quot;+a);
        },
        innerFunc2 : function(){
            a+=2;
            console.log(&amp;quot;a :&amp;quot;+a);
        }
    };
}
var out = outerFunc();  
out.innerFunc1();  
out.innerFunc2();  
out.innerFunc2();  
out.innerFunc1();

//실행결과
/*
a = 1  
a = 3  
a = 5  
a = 6  
*/
function outerFunc(){  
    var a= 0;
    return {
        innerFunc1 : function(){
            a+=1;
            console.log(&amp;quot;a :&amp;quot;+a);
        },
        innerFunc2 : function(){
            a+=2;
            console.log(&amp;quot;a :&amp;quot;+a);
        }
    };
}
var out = outerFunc();  
var out2 = outerFunc();  
out.innerFunc1();  
out.innerFunc2();  
out2.innerFunc1();  
out2.innerFunc2();


//실행결과

/*
a = 1  
a = 3  
a = 1  
a = 3  
*/


/* 

[예제 8] 클로저의 상호작용, 서로 다른 객체

위의 코드는 클로저의 예제 코드이며 그 중 좌측 코드는 서로 다른 클로저가 같은 내부 변수를 참조하고 있다는 것을 보여주고 있습니다. 서로 다른 클로저 innerFunc1과 innerFunc2가 내부 변수 a를 참조하고 a의 값을 바꿔주고 있습니다. 실행 결과를 보면 내부 변수 a의 메모리를 같이 공유한다는 것을 알 수 있습니다.

우측 코드는 같은 함수를 쓰지만 서로 다른 객체로 내부 변수를 참조하는 모습입니다. 외부 함수가 여러 번 실행되면서 서로 다른 객체가 생성되고 객체가 생성될 때 마다 서로 다른 내부 변수가 생성되어 보기엔 같은 내부 변수 a로 보이지만 서로 다른 내부 변수를 참조합니다.

*/


// 클로저의 사용이유



/*

클로저를 사용하게 되면 전역변수의 오,남용이 없는 깔끔한 스크립트를 작성 할 수 있습니다. 같은 변수를 사용하고자 할 때 전역 변수가 아닌 클로저를 통해 같은 내부 변수를 참조하게 되면 전역변수의 오남용을 줄일 수 있습니다. 또한, 클로저는 JavaScript에 적합한 방식의 스크립트를 구성하고 다양한 JavaScript의 디자인 패턴을 적용할 수 있습니다. 그의 대표적인 예로 모듈 패턴을 말 할 수 있는데 모듈 패턴의 자세한 내용은 [Javascript : 함수(function) 다시 보기]을 참고 하시면 될 것 같습니다. 마지막으로 함수 내부의 함수를 이용해 함수 내부변수 또는 함수에 접근 함으로써 JavaScript에 없는 class의 역할을 대신해 비공개 속성/함수, 공개 속성/함수에 접근을 함으로 class를 구현하는 근거 입니다.

*/


// 3.2 클로저 사용시 주의할 점
// 클로저를 사용할 때 주의해야 할 점이 여럿 있습니다. 제가 알려드리고 싶은 주의 점은 다음과 같습니다.

// for 문 클로저는 상위 함수의 변수를 참조할 때 자신의 생성될 때가 아닌 내부 변수의 최종 값을 참조합니다.

&amp;lt;body&amp;gt;  
    &amp;lt;script&amp;gt;
    window.onload = function(){
        var list = document.getElementsByTagName(&amp;quot;button&amp;quot;);

        for(var i =0, length = list.length; i&amp;lt;length; i++){
            list[i].onclick=function(){
            console.log(this.innerHTML+&amp;quot;은&amp;quot;+(i+1)+&amp;quot;번째 버튼입니다&amp;quot;);
            }
        }
    }
    &amp;lt;/script&amp;gt;
&amp;lt;button&amp;gt;1번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;2번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;3번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;/body&amp;gt;  


//실행결과

/*
1번째 버튼은 4번째 버튼입니다  
2번째 버튼은 4번째 버튼입니다  
3번째 버튼은 4번째 버튼입니다  
*/

// [예제 9] for문안의 클로저

// 위의 코드는 각각의 버튼에 이벤트를 걸어 클릭된 버튼이 몇 번째 버튼인지를 알기 위한 예제 입니다. 하지만, 실행 결과 값은 바라던 결과가 나오지 않습니다. 위의 클로저인 클릭 이벤트가 참조 하는 변수 i의 값이 버튼이 클릭될 때의 값이 아닌 for 구문을 다 돌고 난후 i의 값 4를 참조하기 때문에 모두 4라는 결과가 나옵니다.

&amp;lt;body&amp;gt;  
    &amp;lt;script&amp;gt;
    window.onload = function(){
        var list = document.getElementsByTagName(&amp;quot;button&amp;quot;);

        var gate = function(i){
            list[i].onclick=function(){
            console.log(this.innerHTML+&amp;quot;은&amp;quot;+(i+1)+&amp;quot;번째 버튼입니다&amp;quot;);
            }
        }
        for(var i =0, length = list.length; i&amp;lt;length; i++){
             gate(i);
        }
    }
    &amp;lt;/script&amp;gt;
&amp;lt;button&amp;gt;1번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;2번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;button&amp;gt;3번째 버튼&amp;lt;/button&amp;gt;  
&amp;lt;/body&amp;gt;


//실행결과
/*
1번째 버튼은 1번째 버튼입니다  
2번째 버튼은 2번째 버튼입니다  
3번째 버튼은 3번째 버튼입니다  
*/

// [예제 10] 예제9 해결법 : 중첩클로저

// 위의 예제 코드를 통해 중첩 된 클로저를 사용하는 것 만으로 위와 같은 문제를 피하여 원하는 값이 나옵니다.

// 성능문제 클로저가 필요하지 않는 부분에서 클로저를 사용하는 것은 처리 속도와 메모리 면에서 좋은 방법이 아닙니다.

function MyObject(inputname) {  
    this.name = inputname;
    this.getName = function() {
        return this.name;
    };
    this.setName = function(rename) {
        this.name = rename;
    };
}
var obj= new MyObject(&amp;quot;서&amp;quot;);  
console.log(obj.getName());  


//실행결과
/*
서
*/

// [예제 11] 클로저의 오남용

// 위의 코드와 같은 함수 내부의 클로저 구현은 함수의 객체가 생성될 때마다 클로저가 생성되는 결과를 가져옵니다. 같은 구동을하는 클로저가 객체마다 생성이 된다면 쓸데없이 메모리를 쓸데없이 차지하게 되는데, 이를 클로저의 오남용이라고 합니다. 클로저의 오남용은 성능 문제 면에서 안 좋은 결과를 가져옵니다.

function MyObject(inputname) {  
    this.name = inputname;
}
MyObject.prototype.getName = function() {  
    return this.name;
};
MyObject.prototype.setName =   function(rename) {  
    this.name = rename;
};
var obj= new MyObject(&amp;quot;서&amp;quot;);  
console.log(obj.getName());  

//실행결과
/*
서
*/


// [예제 12] prototype객체를 이용한 클로저 생성

// 클로저를 위의 코드와 같이 prototype객체에 생성하게 되면 객체가 아무리 생성되어도 클로저를 한 번만 생성하고 여러 객체에서 쓸 수 있게 되어 메모리의 낭비를 줄입니다.

// this와 arguments객체 클로저를 통해서는 외부함수의 this객체와 arguments객체를 참조하지 못합니다.

function f1(){  
    function f2(){
        console.log(arguments[0]);
    }
    return f2;
}
var exam = f1(1);  
exam();

//실행결과
/*
undefined  
*/

function f1(){  
    var a= arguments[0];
    function f2(){
        console.log(a);
    }
    return f2;
}
var exam = f1(1);  
exam();  

//실행결과
/*
1  
*/


// [예제 13] arguments객체 참조

// 위의 좌측코드같이 클로저를 통해 arguments객체를 참조하게 되면 undefined라는 실행결과가 나옵니다. 즉, arguments객체는 참조가 불가능하며 굳이 참조하고 싶다면 오른쪽 코드와 같이 새로운 내부 변수에 arguments객체의 값을 넣고 그 변수를 참조 하거나 매개변수를 만들어 매개 변수를 참조하여야 합니다.

Function 생성자

var a= 20;  
function function1(){  
    var a= 10;
    var function2 = new Function(&amp;quot;&amp;quot;,&amp;quot;return a;&amp;quot;);
    return function2;
}
var exam = function1();  
exam();  
//실행결과
/*
20  
*/

// [예제 14] Function생성자로 선언된 클로저

// 위의 코드와 같이 클로저가 Function생성자로 생성된 경우 전역에서 생성된 것으로 인지합니다. 클로저 function2를 통하여 내부 변수 a를 참조하려고 했지만 원했던 결과와 달리 전역 변수 a가 참조 됩니다.



function outerFunc(){  
    var outer_val = {};
    function innerFunc(){
        console.log(outer_val);
    }

    outer_val.values = innerFunc;
    return innerFunc;
}


// [예제 15] 인위적 순환참조

// 위의 코드는 의도적으로 클로저의 순환참조를 만든 예제 코드입니다. 내부 객체 outerval의 속성 값 values 에 내부 함수 innerFunc를 참조하게 만들고 내부 함수 innerFunc는 내부 객체 outerval을 호출 하고 있습니다. 위와 같은 순환 참조는 서로를 참조 하면서 영원히 끝나지 않는 호출로 인하여 메모리 누수를 야기합니다.

function outerFunc(){  
    var outer_val = {};
    function innerFunc(){
        console.log(&amp;quot;Hello&amp;quot;);
    }
    outer_val.values = innerFunc;
    return innerFunc;
}

// [예제 16] 의도치 않은 순환참조

// 그렇다면 위 코드같이 서로를 참조를 하지 않게 되면 순환참조가 끊어질까요? 아닙니다. JavaScript의 클로저는 특별한 문법을 쓰지 않고도 암묵적으로 생기는 특성을 가지고 있습니다. 이는 클로저를 쉽게 만들도록 해주지만 클로저가 사용되는 곳을 사용자가 식별하기 어렵게 만들기도 합니다. 그렇게 되면 내부 함수의 innerFunc는 암묵적으로 상위 함수의 내부 객체인 outer_val을 참조하게 되고 이로인해 의도치 않게 순환참조가 만들어집니다. 이런 의도치 않은 순환참조는 메모리 누수를 야기합니다.

// 이 같은 의도치 않은 순환참조는 객체가 제거될 때 명시적으로 null값으로 초기화 해 주거나 try-catch-finally구문으로 해결합니다. 또는 더 글라스 크락포드가 제시한 purge함수를 쓰게 되면 순환참조를 해결할 수 있습니다. 아래는 purge함수 입니다.

function purge(d) {  
    var a = d.attributes, i, l, n;
    if (a) {
        for (i = a.length - 1; i &amp;gt;= 0; i -= 1) {
            n = a[i].name;
            if (typeof d[n] === &#39;function&#39;) {
                d[n] = null;
            }
        }
    }
    a = d.childNodes;
    if (a) {
        l = a.length;
        for (i = 0; i &amp;lt; l; i += 1) {
            purge(d.childNodes[i]);
        }
    }
}


// [더글라스 크락포드의 purge함수]

// 3.3 캡슐화
//캡슐화란 간단하게 말하면 객체의 자료화 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추는 겁니다. 즉, 외부에서 볼 때는 실제 하는 것이 아닌 추상화 되어 보이게 하는 것으로 정보은닉에 쓰입니다. JavaScript는 이와 같은 캡슐화를 클로저를 사용하여 구현합니다.

function Gugudan(dan){  
    this.maxDan=3;
    this.calculate = function(){
        for(var i =1; i&amp;lt;=this.maxDan; i++){
            console.log(dan+&amp;quot;*&amp;quot;+i+&amp;quot;=&amp;quot;+dan*i);
        }
    }
    this.setMaxDan = function(reset){
        this.maxDan = reset;
    }
}
var dan5 = new Gugudan(5);  
dan5.calculate();

dan5.maxDan=2;  
dan5.calculate();

//실행결과
/*
5*1=5  
5*2=10  
5*3=15

5*1=5  
5*2=10  
*/

// [예제 17] 캡슐화 전

// 위의 코드는 JavaScript 캡슐화 하기 전의 코드입니다. 내부 변수를 this객체로 바인딩 하여 선언하게 되면 내부 변수 maxDan에 대하여 외부에서 직접 접근이 가능합니다. 이런식의 소스코드 구현은 사용자가 임의로 바꿔선 안될 값들이 외부에 공개가 되면서 보안문제에 안좋은 결과를 가져옵니다.

function Gugudan(dan){  
    var maxDan=3;
    this.calculate = function(){
        for(var i =1; i&amp;lt;=maxDan; i++){
            console.log(dan+&amp;quot;*&amp;quot;+i+&amp;quot;=&amp;quot;+dan*i);
        }
    }
    this.setMaxDan = function(reset){
        maxDan = reset;
    }
}
var dan5 = new Gugudan(5);  
dan5.calculate();

dan5.maxDan=2;  
dan5.calculate();

dan5.setMaxDan(2)  
dan5.calculate();  


//실행결과
/*
5*1=5  
5*2=10  
5*3=15

5*1=5  
5*2=10  
5*3=15

5*1=5  
5*2=10  
*/

// [예제 18] 캡슐화 후

// 하지만 위의 코드와 같이 var키워드를 통하여 내부 변수를 선언하게 되면 내부 변수 maxDan이 외부에서 직접 접근이 되지 않고 오직 클로저를 통해서만 접근이 가능합니다. 즉, 사용자가 임의로 값을 바꿀수 없고 개발자가 만들어놓은 길(클로저)을 통해서만 값을 바꿔 줄수 있습니다. 아쉬운 점은 캡슐화를 하게되면 클로저를 prototype 맴버로 등록하지 못해 공용 메소드로 사용할 수 있는 이점은 사라집니다. 하지만, 별도의 부모 객체를 정의해서 공용 메소드나 상수 들을 위치시키고 이를 상속받는 방식으로 보완할 수 있습니다.



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;커링-currying&#34;&gt;커링 (currying)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 호출된 함수의 매개변수로 동적으로 새로운 함수를 생성하여 반환하는 패턴을 커링이라 한다.

// 호출하는 함수의 인자값이 비슷하다면 커링을 사용하는 것이 효율적이다.

// 클로저를 이용해 함수의 인자를 미리 등록해두는 것


function func(a) {
    return function(b) { // 내부 함수, 즉 클로저인 익명 함수 반환
        return a + b;
    }
}
var currying = func(5);
var result = currying(5); 
console.log(result);

// 또는 아래처럼 호출
var result2 = func(5)(7); 
console.log(result2);

https://mylife365.tistory.com/320 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;스코프란&#34;&gt;스코프란?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// 자바스크립트에서 스코프란 어떤 변수들에 접근할 수 있는지를 정의합니다.
//스코프엔 두 가지 종류가 있습니다. 전역 스코프와 지역 스코프로 나뉩니다.


// 전역_스코프


let greeting = &#39;Hello John&#39; // 외부에서 변수가 선언됨

function marcusHello () {
  console.log(greeting)
}

console.log(greeting) // &#39;Hello John!&#39; 

sayHello() // &#39;Hello John!&#39; 



// 지역_스코프


function marcusHello () {
  
  let greeting = &#39;Hello John!&#39; // 안에서 변수가 선언됨
  console.log(greeting)
}

marcusHello() // &#39;Hello John!!&#39;

console.log(x) // Error, hello is not defined


let name = &amp;quot;john&amp;quot;;

function showName() { 
  let name = &amp;quot;jj&amp;quot;; // 2. 지역변수 &amp;lt;&amp;lt; showName함수에서만 접근 가능
  console.log(name); // 2. jj
}

console.log(name); // 1.jj &amp;lt;&amp;lt; 전역변수 가져옴
showname()         // 2.
console.log(name)  // 3. john &amp;lt;&amp;lt; 여전히 전역 변수 john





let name = &amp;quot;john&amp;quot;;

function showName() {
  name = &amp;quot;jj&amp;quot;; // name 이 전역변수로 바뀜 cos let 없기 때문에 외부에서 변수 가져왔다. 
  console.log(name); //   jj 
}

console.log(name); // 1. john &amp;lt;&amp;lt; 전역변수 가져옴
showName()         // 2. 
console.log(name)  // 3. jj 함수가 실행된 뒤에는 함수안에 있는 name = jj 를 가져와서 리턴한다. 왜냐하면 jj 가 전역 변수로 바뀌었기 때문이다. 


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>An example preprint / working paper</title>
      <link>/publication/preprint/</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0900</pubDate>
      
      <guid>/publication/preprint/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Supplementary notes can be added here, including &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34;&gt;code and math&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Privacy Policy</title>
      <link>/privacy/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0900</pubDate>
      
      <guid>/privacy/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>External Project</title>
      <link>/project/external-project/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0900</pubDate>
      
      <guid>/project/external-project/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Collaborative Mapping</title>
      <link>/project/ex1/</link>
      <pubDate>Thu, 07 Apr 2016 00:00:00 +0900</pubDate>
      
      <guid>/project/ex1/</guid>
      <description>&lt;p&gt;Founded by myself and Dr. on Geography Miguel Sevilla in 2016, &lt;em&gt;&lt;a href=&#34;https://translate.google.com/translate?sl=es&amp;amp;tl=en&amp;amp;u=https%3A%2F%2Fmapcolabora.org&#34; target=&#34;_blank&#34;&gt;Collaborative Mapping&lt;/a&gt;&lt;/em&gt; is an action-research group of enthusiasts aimed to foster citizen innovation and collective intelligence through Voluntary Geographic Informationand that result in collaborative maps at the service of citizens. We do so through participatory projects and periodical meetings and talks about tools, methodologies or related topics such as Free Culture and Informationalism paradigm. Some of our main achievements so far have been the organization of &lt;a href=&#34;https://www.msf.org/&#34; target=&#34;_blank&#34;&gt;Medecins Sans Frontieres&lt;/a&gt;’s &lt;strong&gt;Humanitarian Hackaton in Spain&lt;/strong&gt; (2017, 2018 and 2019), leading &lt;strong&gt;Mapping parties&lt;/strong&gt; for &lt;a href=&#34;/project/zaccesible&#34;&gt;Accessible Zaragoza&lt;/a&gt; project, or giving a number of &lt;strong&gt;&lt;a href=&#34;https://translate.google.com/translate?hl=&amp;amp;sl=es&amp;amp;tl=en&amp;amp;u=https%3A%2F%2Fmapcolabora.org%23talks&#34; target=&#34;_blank&#34;&gt;talks and workshops&lt;/a&gt;&lt;/strong&gt; on VGI and tools such as Leaflet, Carto, Mapbox, OpenStreetMap, Overpass API, Mapillary, uMap&amp;hellip;&lt;/p&gt;

&lt;p&gt;Since then, I have been coordinating the group&amp;rsquo;s activities as well with Dr. Miguel Sevilla-Callejo and Alejandro Suárez, Héctor Hochoa and Joan Cano, who joined the staff soon afterwards.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An example journal article</title>
      <link>/publication/journal-article/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0900</pubDate>
      
      <guid>/publication/journal-article/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Supplementary notes can be added here, including &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34;&gt;code and math&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>An example conference paper</title>
      <link>/publication/conference-paper/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0900</pubDate>
      
      <guid>/publication/conference-paper/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Supplementary notes can be added here, including &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34;&gt;code and math&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Pos</title>
      <link>/project/pos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/project/pos/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Previous work&lt;/strong&gt;:&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
