<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.2.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="John Jung">

  
  
  
    
  
  <meta name="description" content="OPP 란? 객체 지향 프로그래밍이란(OOP: Object Oriented Programming)?  객체들의 모임이다.  객체 지향 프로그래밍 장점  코드의 재사용성 제공 *객체의 특성이나 속성을 한 번 정의해 놓으면 해당 객체에 소속되어 있는 모든 객체들의 속성으로 사용할 수 있으므로 재사용성이 높아진다. 유지보수의 용이 : 한 번만 정의한 것을 수정하면 모든 객체의 속성을 수정할 수 있다. 신뢰성 증대 : 다양하게 사용된 속성들에 경험이 쌓이면서 신뢰가 축적되기 쉽고 그것을 다시 사용한다면 에러(버그)의 가능성이 줄어든다.">

  
  <link rel="alternate" hreflang="en-us" href="/tutorial/2019-12-21-spint2/">

  


  

  

  

  

  

  

  
  
  
  <meta name="theme-color" content="#EAF04E">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous" title="hl-light" disabled>
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark">
        
      
    

    

    

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Playfair+Display:400,700|Fauna+One">
  

  <link rel="stylesheet" href="/styles.css">
  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-153100405-1', 'auto');
      
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/tutorial/2019-12-21-spint2/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="JohnJung">
  <meta property="og:url" content="/tutorial/2019-12-21-spint2/">
  <meta property="og:title" content="__DS &amp; OOP | JohnJung">
  <meta property="og:description" content="OPP 란? 객체 지향 프로그래밍이란(OOP: Object Oriented Programming)?  객체들의 모임이다.  객체 지향 프로그래밍 장점  코드의 재사용성 제공 *객체의 특성이나 속성을 한 번 정의해 놓으면 해당 객체에 소속되어 있는 모든 객체들의 속성으로 사용할 수 있으므로 재사용성이 높아진다. 유지보수의 용이 : 한 번만 정의한 것을 수정하면 모든 객체의 속성을 수정할 수 있다. 신뢰성 증대 : 다양하게 사용된 속성들에 경험이 쌓이면서 신뢰가 축적되기 쉽고 그것을 다시 사용한다면 에러(버그)의 가능성이 줄어든다."><meta property="og:image" content="/img/icon-192.png">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-04-29T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2019-04-29T00:00:00&#43;00:00">
  

  

  

  <title>__DS &amp; OOP | JohnJung</title>

</head>
<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" class="dark">
  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">JohnJung</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/tutorial/">
          
          <span>Technical Documents</span>
          
          </a>
        </li>

        

        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/#posts">
          
          <span>Posts</span>
          
          </a>
        </li>

        

        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/#projects">
          
          <span>Projects</span>
          
          </a>
        </li>

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>



<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      




<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" id="search-query" placeholder="Search..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/">Today I Learned</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/it-terminology/">1.Technical terms</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/git/">2.Git</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/html/">3.Html</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/css/">4.Css</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/bootstrap/">5.Bootstrap</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/python/">5.Python</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript/">6.Javascript</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/2019-11-14-javascript-daliy-coding-level-1/">__Algorithm_1</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-11-14-javascript-daliy-coding-level-2/">__Algorithm_2</a>
      </li>
      
      <li >
        <a href="/tutorial/javascript_algorithm/">__Algorithm_3</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-11-14-javascript-my-mdn/">__My_MDN</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-11-26-js-post/">__My_Notes</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_dictionary/">CodeStates</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_note/">_section1</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/2019-12-21-sprint1/">__Immersive Prep</a>
      </li>
      
      <li class="active">
        <a href="/tutorial/2019-12-21-spint2/">__DS &amp; OOP</a>
      </li>
      
      <li >
        <a href="/tutorial/2020-01-05-spint-3/">__Iheritance Patterns</a>
      </li>
      
      <li >
        <a href="/tutorial/2020-01-02-check-point/">__Check_Point</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_q1/">_section2</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/2020-01-13-sever/">__Server</a>
      </li>
      
      <li >
        <a href="/tutorial/2020-01-20-react/">__React</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_q2/">_section3</a>

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-4 docs-toc"style="
    right: -88px;">
      
      <p class="docs-toc-title">On this page</p>
      

      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#opp-란">OPP 란?</a>
<ul>
<li>
<ul>
<li><a href="#객체-지향-프로그래밍이란-oop-object-oriented-programming">객체 지향 프로그래밍이란(OOP: Object Oriented Programming)?</a></li>
<li><a href="#객체-지향-프로그래밍-장점">객체 지향 프로그래밍 장점</a></li>
<li><a href="#oop의-기본-구성-요소">OOP의 기본 구성 요소</a></li>
<li><a href="#opp-기본-컨셉-4-가지-있다">OPP 기본 컨셉 4 가지 있다.</a></li>
<li><a href="#1-캡슐화란">1.캡슐화란?</a></li>
<li><a href="#2-상속">2.상속?</a></li>
<li><a href="#3-추상화란">3.추상화란?</a></li>
<li><a href="#4-여러가지-형태-다양성">4.여러가지 형태 다양성 ?</a></li>
</ul></li>
</ul></li>
<li><a href="#prototype-무엇이냐">prototype 무엇이냐?</a>
<ul>
<li><a href="#자바스크립트는-프로토타입-기반-객체지향-프로그래밍-언어이다">자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다.</a>
<ul>
<li>
<ul>
<li><a href="#첫번째-알아야-할것">첫번째 알아야 할것</a></li>
</ul></li>
<li><a href="#두번째-알아야할-것">두번째 알아야할 것</a></li>
<li><a href="#세번째-알아야-할것">세번째 알아야 할것</a></li>
<li><a href="#네번째-알아야-하는것">네번째 알아야 하는것</a></li>
<li><a href="#예제">예제)</a></li>
</ul></li>
</ul></li>
<li><a href="#instantiation-patterns">Instantiation Patterns</a>
<ul>
<li>
<ul>
<li><a href="#1-functional">1. Functional</a></li>
<li><a href="#2-functional-shared">2. Functional Shared</a></li>
</ul></li>
</ul></li>
<li><a href="#자료구조란">자료구조란 ?</a></li>
<li><a href="#stack">Stack</a>
<ul>
<li>
<ul>
<li><a href="#stack-이란">Stack 이란 ?</a></li>
<li><a href="#property">Property</a></li>
<li><a href="#method">method</a></li>
<li><a href="#오류">오류</a></li>
</ul></li>
</ul></li>
<li><a href="#queue">Queue</a>
<ul>
<li>
<ul>
<li><a href="#queue-이란">Queue 이란 ?</a></li>
<li><a href="#property-1">property</a></li>
<li><a href="#method-1">method</a></li>
<li><a href="#오류-발생">오류 발생</a></li>
</ul></li>
</ul></li>
<li><a href="#linked-list">Linked List</a>
<ul>
<li>
<ul>
<li><a href="#linked-list-란">Linked List 란?</a></li>
<li><a href="#연결-리스트를-사용할-때의-장점">연결 리스트를 사용할 때의 장점</a></li>
<li><a href="#연결-리스트를-원형으로-연결할-때의-장점">연결 리스트를 원형으로 연결할 때의 장점</a></li>
<li><a href="#property-2">Property</a></li>
<li><a href="#method-2">Method</a></li>
</ul></li>
</ul></li>
<li><a href="#graphs">Graphs</a>
<ul>
<li>
<ul>
<li><a href="#graphs-란">Graphs 란?</a></li>
<li><a href="#graphs-종류">Graphs 종류</a></li>
<li><a href="#property-3">Property</a></li>
<li><a href="#method-3">Method</a></li>
<li><a href="#그래프를-코드로-표현하는-2가지-방법">그래프를 코드로 표현하는 2가지 방법</a></li>
<li><a href="#인접-행렬-그래프">인접 행렬 그래프</a></li>
<li><a href="#인접-리스트-그래프-갈-수-있는-곳만-저장">인접 리스트 그래프 - &ldquo;갈 수 있는 곳만 저장&rdquo;</a></li>
<li><a href="#길찾기-알고리즘">길찾기 알고리즘</a></li>
</ul></li>
</ul></li>
<li><a href="#tree">Tree</a>
<ul>
<li>
<ul>
<li><a href="#tree-란">Tree 란?</a></li>
<li><a href="#tree-종류에는-4가지가-대표적으로-있다">Tree 종류에는 4가지가 대표적으로 있다.</a></li>
<li><a href="#용어">용어</a></li>
<li><a href="#property-4">Property</a></li>
<li><a href="#method-4">Method</a></li>
</ul></li>
</ul></li>
<li><a href="#binary-search-tree">binary search tree</a>
<ul>
<li>
<ul>
<li><a href="#알고리즘-방법-추가학습">알고리즘 방법 (추가학습)</a></li>
<li><a href="#property-5">Property</a></li>
<li><a href="#method-5">Method</a></li>
<li><a href="#삭제하는-3가지-방법">삭제하는 3가지 방법</a></li>
</ul></li>
</ul></li>
<li><a href="#hash-table">Hash Table</a>
<ul>
<li>
<ul>
<li><a href="#hash-table-란">Hash Table 란?</a></li>
<li><a href="#특징">특징</a></li>
<li><a href="#주의">주의</a></li>
<li><a href="#property-6">Property</a></li>
<li><a href="#method-6">Method</a></li>
</ul></li>
</ul></li>
<li><a href="#complexity-analysis">Complexity Analysis</a>
<ul>
<li>
<ul>
<li><a href="#시간복잡도에서는-big-o표기-할수-있다">시간복잡도에서는 Big-O표기 할수 있다.</a></li>
<li><a href="#시간복잡도의-예시">시간복잡도의 예시</a></li>
<li><a href="#array">array</a></li>
<li><a href="#singly-linked-list">Singly-Linked List</a></li>
<li><a href="#doubly-linked-lists">Doubly-Linked Lists</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>

      <ul class="nav toc-top">
        <li><a href="#">Back to top</a></li>
      </ul>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-7 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article" itemscope itemtype="http://schema.org/Article">

        <div class="docs-article-container">
          <h1 itemprop="name">__DS &amp; OOP</h1>

          <div class="article-style" itemprop="articleBody">
            

<h2 id="opp-란">OPP 란?</h2>

<h4 id="객체-지향-프로그래밍이란-oop-object-oriented-programming">객체 지향 프로그래밍이란(OOP: Object Oriented Programming)?</h4>

<ul>
<li>객체들의 <code>모임</code>이다.</li>
</ul>

<h4 id="객체-지향-프로그래밍-장점">객체 지향 프로그래밍 장점</h4>

<ul>
<li>코드의 재사용성 제공
*객체의 특성이나 속성을 한 번 정의해 놓으면 해당 객체에 소속되어 있는 모든 객체들의 속성으로 사용할 수 있으므로 재사용성이 높아진다.</li>
<li>유지보수의 용이 : 한 번만 정의한 것을 수정하면 모든 객체의 속성을 수정할 수 있다.</li>
<li>신뢰성 증대 : 다양하게 사용된 속성들에 경험이 쌓이면서 신뢰가 축적되기 쉽고 그것을 다시 사용한다면 에러(버그)의 가능성이 줄어든다.</li>
</ul>

<h4 id="oop의-기본-구성-요소">OOP의 기본 구성 요소</h4>

<ul>
<li><p>클래스(Class)</p></li>

<li><p>객체(Object)</p></li>

<li><p>메서드(Method)</p></li>
</ul>

<h4 id="opp-기본-컨셉-4-가지-있다">OPP 기본 컨셉 4 가지 있다.</h4>

<ul>
<li>1. 캡슐화(Encapsulation)</li>
<li>2. 상속(Inheritance)</li>
<li>3. 추상화(Abstraction)</li>
<li>4. 여러가지 형태 (Polymorphism)
<br /></li>
</ul>

<h4 id="1-캡슐화란">1.캡슐화란?</h4>

<ul>
<li><p>속성들(properties)들을  object안에 넣어서 활용한다.</p></li>

<li><p>예시</p></li>
</ul>

<blockquote>
<p>employee라는 객체 안에 객체들을 넣어서 사용한다. 이것이 캡슐화이다.</p>
</blockquote>

<pre><code class="language-js">
let baseSalary = 3001;
let overTime = 10;
let rate = 20;

function getwage(baseSalary,overTime,rate) {
return baseSalary + (overTime * rate);
}

getwage() // NaN 
getwage(baseSalary,overTime,rate) // 3200


</code></pre>

<ul>
<li>캡슐화 한 코드</li>
</ul>

<pre><code class="language-js">

let employee = {
	baseSalary : 3000,
	overTime : 10,
	rate: 20,
	getWage: function() {
	return this.baseSalary + (this.overTime * this.rate);
	}
 }
 
 employee.getWage();// 3200


</code></pre>

<h4 id="2-상속">2.상속?</h4>

<ul>
<li>상속은 쉽게 말하면 상위 클래스의 모든 것, 행동을 하위 클래스가 가지고 있으며 그대로 사용할 수도 있고 원하면 Customizing을 할 수 있다는 것이다.</li>
<li>부모 클래스가 가지고 있는 속성(프로퍼티, 메소드) 등을 그대로 자식 클래스가 물려 받아 재사용이 가능하다.
<br />
<br /></li>
</ul>

<h4 id="3-추상화란">3.추상화란?</h4>

<ul>
<li>속에는 복잡하게 되어있지만 사용자가 쓰기에는 굉장히 간단하다.</li>
<li>인터페이스가 간단해진다.</li>
<li>복잡한걸 알지않아도 사용자 입장에서는 사용 가능
<br />
<br /></li>
</ul>

<h4 id="4-여러가지-형태-다양성">4.여러가지 형태 다양성 ?</h4>

<ul>
<li>다형성은 상속을 받은 기능을 변경하거나 확장하는 것</li>
<li>코드의 재사용성이 높아져 코드의 길이가 감소하고 유지보수가 용이해짐</li>
</ul>

<h2 id="prototype-무엇이냐">prototype 무엇이냐?</h2>

<h3 id="자바스크립트는-프로토타입-기반-객체지향-프로그래밍-언어이다">자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다.</h3>

<ul>
<li><p>ES6 문법이 도입되기 전에는 JavaScript에는 클래스(Class)가 없었음 그래서 객체 생성을 위해서 prototype을 사용했다.</p></li>

<li><p>객체를 생성하면, 프로토타입이 결정되고, 우리는 그 프로토타입을 변경할 수 있습니다</p></li>
</ul>

<h5 id="첫번째-알아야-할것">첫번째 알아야 할것</h5>

<ul>
<li>함수를 만들어 변수에 담을때 new 라는 것을 같이 담으면 객체가 된다.</li>
</ul>

<pre><code class="language-js">
function Person() {}

let x = new Person(); //  x 라는 변수는 객체가 된다. 


</code></pre>

<h4 id="두번째-알아야할-것">두번째 알아야할 것</h4>

<ul>
<li>객체(object)는 함수(function)로부터 시작된다</li>
</ul>

<pre><code class="language-js">
function Book() { }                // 함수 &lt;&lt;생성자 함수
var jsBook = new Book();           // 객체 생성


</code></pre>

<ul>
<li>두가지 방식을 객체를 생성할수 있다.</li>
</ul>

<pre><code class="language-js">var jsBook = new Book(); // 첫번째 방식 (생성자 함수) // 객체 

var jsBook = {}          // 두번째 방식(생성자 선언 없이 ) // 객체 


</code></pre>

<h4 id="세번째-알아야-할것">세번째 알아야 할것</h4>

<ul>
<li><p>함수 생성시 발생하는 것을 알아야 한다.</p>

<ul>
<li>1.함수를 정의하면 함수가 생성되며 <code>Prototype object</code>가 같이 생성 됩니다.</li>
</ul></li>
</ul>

<blockquote>
<p>생성된 Prototype object는 함수의 prototype 속성을 통해 접근할 수 있습니다.
(Prototype object같은 경우 <code>함수 생성시</code>(var jsBook = new Book())에만 됩니다. 일반 객체 생성시에는 생성되지 않습니다.)</p>
</blockquote>

<ul>
<li>2.함수의 생성과 함께 생성된 Prototype object는 constructor와 <strong>proto</strong>를 갖고 있습니다.</li>
</ul>

<blockquote>
<p>constructor는 <code>생성된 함수</code>를 가리키며(여기서는 function Book을 가리킵니다.)</p>

<p><strong>proto</strong>는 Prototype Link로서 객체가 생성될 때 사용된 생성자(함수)의 <code>Prototype object</code>를 가리킵니다.</p>
</blockquote>

<h4 id="네번째-알아야-하는것">네번째 알아야 하는것</h4>

<ul>
<li>객체(object) 생성시 발생하는 일</li>
</ul>

<blockquote>
<p>생성하는 순간 jsBook 이라는 객체는 <strong>proto</strong> 라는 <code>_proto__</code>라는 프로퍼티를 갖고있습니다.</p>
</blockquote>

<pre><code class="language-js">
function Book() { }

Book.prototype.name = &quot;john&quot; 

var jsBook = new Book() // jsBook 은 객체이다. 


</code></pre>

<blockquote>
<p>prototype property(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 <strong>proto</strong>는 객체라면 모두 갖고 있습니다.</p>
</blockquote>

<p><img src="/tutorial/2019-11-26-js-post_files/Screen Shot 2019-12-16 at 2.39.56 PM.png" alt="" /></p>

<blockquote>
<p><code>prototype property</code>(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 <code>__proto__</code>는 객체라면 모두 갖고 있습니다.</p>
</blockquote>

<h4 id="예제">예제)</h4>

<ul>
<li>1.일반적인 함수 패턴
<br /></li>
</ul>

<pre><code class="language-js">


function Name(_name){
    var oName = {
        name : _name,
        getName : function(){
            return this.name;
        }
    }

    return oName;
}

Name('john'); // Object{name: 'siwa', getName:function()} 리턴
var x = Name('john');
x.getName(); // 'john' 리턴


</code></pre>

<ul>
<li><p>1.객체 생성자 함수의 활용 - <code>모듈화</code>,<code>프로토타입</code></p>

<ul>
<li><p>new Key word 를 사용한다.</p></li>

<li><p>이는 객체지향적인 언어를 표방하는 기능, 클래스를 만드는 것과 비슷하다.</p></li>

<li><p>(<code>new</code>라는 키워드는 자바에서 클래스를 호출해서 인스턴스를 만드는 것과 비슷하다)</p></li>
</ul></li>
</ul>

<pre><code class="language-js">
 function Name(_name){
		console.log('this is',this);
		this.name = _name;
		this. getName = function(){
        return this.name;
    }
}

// 함수 를 그냥 호출했을때 와 new 키워드와 같이 호출했을때의 차이점 을 할수 있다. 

// 1. 함수를 그냥 호출했을때
Name('john'); // this is window, undefined 리턴

// 2. new 키워드와 함께 함수를 호출했을 때
new Name('john'); // this is Name{}, Name{name:'monkey', getName()} 리턴



var x = new Name('john');

x.getName(); // 'john'




</code></pre>

<ul>
<li>2.객체 생성자 함수의 활용 - <code>모듈화</code> 와  <code>프로토타입</code></li>
</ul>

<p>*기능별로 모듈화 시킨 독립적인 클래스 단위로 그루핑할때 생성자 함수를 활용할 수 있다.</p>

<ul>
<li>예를 들어 구글지도 UI를 만들 때, 화면에 보이는 기능 단위 즉 의미적으로 다른 기능이라면 (ex. 사진, 공유, 검색, 지도화면, 설정) 각각의 기능을 별도 모듈(클래스 단위)로 만들 수 있다.</li>
</ul>

<pre><code class="language-js">
// 모듈화 수도코드 예시
// 지도를 표현하는 영역 클래스

function Map(name){
    this.name = &quot;john&quot;
    }
    
// 지도를 검색하는 영역 클래스
function SearchMenu(){}

// 사진을 슬라이드 하는 영역 클래스
function ViewCurrentPhotos(){}


var oMap = new Map(&quot;john&quot;);

 // 여기서 setDraw 를 설정해준다.
Map.prototype.setDraw = function (){
    console.log(name + &quot;그림을 그리네 ?&quot;);
}

oMap.setDraw() // john 그림을 그리네?


</code></pre>

<ul>
<li>3.객체 생성자 함수의 활용 - <code>모듈화</code> 와  <code>프로토타입</code></li>
</ul>

<pre><code class="language-js">


function Car(band,name,color) {
    // 인스턴스가 만들어 질때  실행될 코드들... 
}

// new 키워드를 통해 클라스의 인스턴스를 만들어낼 수 있습니다. 



// 1. 속성  : band,name,color , currentFuel,maxSpeed
// 2. 메소드  : refuel() ,setSpeed(), drive()



// ex


// 1. 클라스 함수 와 인스턴스 생성 

function Car(brand,name,color) { // Car() 는 클라스
	
	this.what_brand = brand; // 여기서 this 는 인자값이 드러갈 변수이름 (avante)
	this.what_name = name;	
	this.what_color = color;
}

// 2. 클라스 함수를 변수에 담고 파라미터 들어갈 값들 넣는다. 

let avante = new Car(&quot;GM&quot;,&quot;avante&quot;,&quot;black&quot;); // 변수를 만든다 (인스턴스값으로 들어갈 )

// 3. 추가로 인스턴스를 생성 

Car.prototype.what_drive = function () { // Car() 인스턴스 생성 그리고 function 는 인스턴스 값  
    console.log(this.name + &quot;가 운전을 합니다. &quot;);
}


avante.what_name // 인스턴스 값 출력
// &quot;avante&quot;
avante.what_brand
// &quot;GM&quot;
avante.what_color
// &quot;black&quot;

avante.what_drive()  // 새로 생성한 what_drive 출력 
// jj 가 운전을 합니다. 

`tip`

let arr = [1,2,3,4,5]     // 배열 만들기 
let arr = new Array(1,2,3,4,5) // 배열 만들기  // Array클라스 안에 (인자값들) 




// ES6  에서는 클라스라는 키워드를 이용해서 정의 할수 있다. 


class car {
	constructor(brand,name,color) {
	
	// 인스턴스가 만들어질 때 실행되는 코드
		}
}



</code></pre>

<h2 id="instantiation-patterns">Instantiation Patterns</h2>

<ul>
<li><p>자바스크립트에 Class가 나오기 전에 사용하던 4가지 class 선언 방식 이것이 바로 <code>Instantiation Patterns</code> 방식이다.</p></li>

<li><p>함수를 이용한 객체 생성 방식을 이용한다.</p></li>

<li><p>Object 를 생성하는 4가지 방법</p>

<ul>
<li>1. Functional</li>
<li>2. Functional Shared</li>
<li>3. Prototypal</li>
<li>4. Pseudoclassical</li>
</ul></li>
</ul>

<h4 id="1-functional">1. Functional</h4>

<pre><code class="language-js">
let Car = function() {
  let printingInstance = {};
  printingInstance.position = 0;
  printingInstance.move = function() {
    this.position ++;
  }
  return printingInstance;
}

let car1 = Car();

car1 {position: 0, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 1, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 2, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 3, move: ƒ} 
car1.move() // position 1 증가하한다 
car1 {position: 4, move: ƒ} 


// position 초기값을 정해줄 수도 있다


let CarType2 = function(position) {
  let printingInstance = {};
  printingInstance.position = position;
  printingInstance.move = function() {
    console.log(this); 
    this.position ++;
  }
 return printingInstance;
}
 
var car2 = CarType2(2);
car2.move();
car2 // { position: 2, move: ƒ }
car2.move(); 
car2 // // { position: 3, move: ƒ }



</code></pre>

<h4 id="2-functional-shared">2. Functional Shared</h4>

<ul>
<li>Functional Shared라는 방식을 사용한다면, someMethods라는 객체에 있는 메소드들의 메모리 주소만을 참조하기 때문에 메모리 효율이 좋아진다</li>
</ul>

<pre><code class="language-js">
// 3. // someInstance와 someMethods를 합치는 extend 함수를 만들어 Car 함수 내부에 넣는다. 

let extend = function(to, from) { 
  for(let key in from) {
    to[key] = from[key];
  }
}


// 2.메소드를 담아줄 객체를 생성.

let someMethods = {}; 
someMethods.move = function() {  // 모든 메소드는 someMethods에 담긴다. 
  this.position ++;
}


//  1. 먼저 Car 함수를 선언해 줍니다. 

let Car = function(position) { 
  let printingInstance = {
    position : position,
  }
   
  extend(printingInstance, someMethods); // Car함수 내부에서 합쳐준다 
  return printingInstance;
}


var car1 = Car(5); // 공장처럼 찍어낸다.
var car2 = Car(10); // 공장처럼 찍어낸다. 


</code></pre>

<ol>
<li>Prototypal</li>
</ol>

<blockquote>
<p>왜 이방식을 쓰냐? 귀찬게? 이전의 Functional 방식은 인스턴스를 생성할 때마다 모든 메소드를 someInstance에게 할당하므로, 각각의 인스턴스들이 메소드의 수 만큼의 메모리를 더 차지하기 때문입니다.</p>

<p>However, Functional Shared라는 방식을 사용한다면, someMethods라는 객체에 있는 메소드들의 메모리 주소만을 참조하기 때문에 메모리 효율이 좋아진다</p>
</blockquote>

<pre><code class="language-js">
// 1. 먼저 Functional Shared 비슷하게 메소드를 담아둘 객체 생성 

var someMethods = {};
someMethods.move = function() {
 this.position += 1;
};


// 2. Car 라는 함수 선언해 준다. 

var Car = function(position) {
	var printingInstance = Object.create(someMethods);  //기존에 만든 someMethods를 상속해버린다. 어디에? 여기에
    printingInstance.position = position;
    return printingInstance;
};

var car1 = Car(10);
car1 // {position: 10} // 이렇게 나온다.

// 메소드 move 는 어디갔냐? 
console.dir(car1) // 하면 
// position: 10
//__proto__:
//	move: f()

car1.move() 
car1 //  {position: 11}
car1.move() 
car1 //  {position: 12}
car1.move() 
car1 //  {position: 13}


</code></pre>

<ul>
<li>4. Pseudoclassical</li>
</ul>

<pre><code class="language-js">// 1.먼저 Car 함수 생성
var Car = function(position) {
    this.position = position
    }

// 2. 그다음 prototype 에 메소드를 추가한다. 

Car.prototype.move = function (){
    this.position ++;
 }



var car1 = new Car(10) // 꼭 new operater 를 붙여야 한다. 
car1 // {position: 10} // 이렇게 나온다.

// 메소드 move 는 어디갔냐? 
console.dir(car1) // 하면 
// position: 10
//__proto__:
//	move: f()

car1.move() 
car1 //  {position: 11}
car1.move() 
car1 //  {position: 12}
car1.move() 
car1 //  {position: 13}


</code></pre>

<h2 id="자료구조란">자료구조란 ?</h2>

<ul>
<li>데이터에 편리하게 접근하고, 변경하기 위해서 데이터를 저장하거나 조직하는 방법 을 말한다. 모든 목적에 맞는 자료구조는 찾기 어렵다.</li>
</ul>

<h2 id="stack">Stack</h2>

<h4 id="stack-이란">Stack 이란 ?</h4>

<ul>
<li>마지막에 쌓인것이 먼저 먼저 나오는 자료구조</li>
<li>Last In First Out  =&gt; <code>L I F O</code> 이렇게 표현된다.
<br /></li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 4.43.04 PM.png" alt="" /></p>

<h4 id="property">Property</h4>

<pre><code>* top : 가장 최근에 들어간, 맨 위의 값
* maxSize : 스택의 최대 할당 크기
* storage : 스택이 가지고 있는 데이터들의 모음
</code></pre>

<h4 id="method">method</h4>

<pre><code>* 1. push : 맨 뒤에(위에) 삽입
* 2. pop : 맨위 제거
* 3. size : 크기 확인
</code></pre>

<h4 id="오류">오류</h4>

<ul>
<li><p>stack이  꽉차있는데 데이터를 삽입하려고 하면  Stack Overflow가 발생해 데이터가 들어가는 것을 차단한다.</p></li>

<li><p>재귀함수가 멈추지 않을떄 자바스크립상에서 이를 방지하기 위해 <code>Maximum call stack size exceeded</code> 발생 시킨다 이것은 <code>Stack Overflow</code>에 기반한 오류로 볼 수 있다.</p></li>

<li><p>Stack이 없는데 값을 꺼내려고 하면 <code>Stack underflow</code>가 발생한다.</p></li>
</ul>

<h2 id="queue">Queue</h2>

<h4 id="queue-이란">Queue 이란 ?</h4>

<ul>
<li>먼저 들어간 데이터가 먼저 나오는 자료 구조.</li>
<li>First In First Out =&gt; <code>F I F O</code>
<br /></li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 4.47.58 PM.png" alt="" /></p>

<h4 id="property-1">property</h4>

<pre><code>* front : 가장 먼저 들어간, 맨 밑의 값
* rear : 새로운 데이터가 들어갈 인덱스 (가장 최근의 인덱스 + 1)
* storage : 큐가 가지고 있는 데이터들의 모음
</code></pre>

<h4 id="method-1">method</h4>

<pre><code>* 1. enqueue : 맨 뒤에(위에)삽입
* 2. dequeue : 제일 앞에 빼기
</code></pre>

<h4 id="오류-발생">오류 발생</h4>

<ul>
<li>만약 큐데이터가 비워있는데  삭제한다고 하면 오류가 발생한다.
<code>Queue Underflow</code> 라고 한다.</li>
<li>만약 큐데이터가 꽉 차있을 경우 삽일 하려고 한다면 오류가 난다.
<code>Queue Overflow</code> 라고 한다.</li>
</ul>

<h2 id="linked-list">Linked List</h2>

<h4 id="linked-list-란">Linked List 란?</h4>

<ul>
<li>연결리스트는 각 데이터들을 포인터로 연결하여 관리하는 자료구조</li>
<li>데이터값이 앞과 뒤로 연결되있다.</li>
<li>노드들의 모임</li>
<li>배열은 추가삭제가 느리지만 인덱스 조회가 빠르고 Linked List 는 추가삭제는 빠르지만 인덱스의 조회가 느리다.</li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.03.37 PM.png" alt="" /></p>

<h4 id="연결-리스트를-사용할-때의-장점">연결 리스트를 사용할 때의 장점</h4>

<ul>
<li><p>데이터를 차례대로 순회하면서 연산하기 좋음</p></li>

<li><p>순회 도중에 새로운 데이터의 삽입, 삭제에 용이함</p></li>

<li><p>배열과는 달리 데이터의 개수를 모르는 경우에도 별도의 비용없이 추가할 수 있음</p></li>
</ul>

<h4 id="연결-리스트를-원형으로-연결할-때의-장점">연결 리스트를 원형으로 연결할 때의 장점</h4>

<ul>
<li><p>반복적인 순회에서 연결리스트의 끝을 체크해야할 필요가 없음</p></li>

<li><p>head같은 메타데이터가 필요하지 않음</p></li>

<li><p>이로인해 시간, 메모리, 코드 모두 이득을 볼 수 있음</p></li>
</ul>

<h4 id="property-2">Property</h4>

<pre><code>HEAD : 첫 번째 노드를 지정하는 값
TAIL : 마지막 노드를 지정하는 값
</code></pre>

<h4 id="method-2">Method</h4>

<pre><code>addToTail 추가 : 마지막 번째 노드에 데이터를 삽입
removeHead 삭제  : 첫 번째 노드를 삭제
contains 탐색 : 연결 리스트가 주어진 값을 포함하고 있는지 확인
</code></pre>

<h2 id="graphs">Graphs</h2>

<h4 id="graphs-란">Graphs 란?</h4>

<ul>
<li>노드(node)와 노드를 연결하는 간선(edge)로 이루어진 비선형 자료 구조</li>
<li>버텍스(vertex)와 노드를 연결하는 아크로 이루어진 비선형 자료 구조</li>
<li>그래프에서는 노드를 <code>버텍스</code>, 엣지를 <code>아크</code>라고 부릅니다.</li>
<li>예를 들어 지도, 지하철 노선도의 최단 경로, 전기 회로의 소자들, 도로(교차점과 일방통행길), 선수 과목 등이 있다.</li>
<li>오일러 문제(다리 건너기), 길찾기 알고리즘, 최단거리 알고리즘(다익스트라,벨만포드)</li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.35.39 PM.png" alt="" /></p>

<h4 id="graphs-종류">Graphs 종류</h4>

<pre><code>* 무방향 그래프
* 정방향 그래프
</code></pre>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 1.34.31 PM.png" alt="" /></p>

<h4 id="property-3">Property</h4>

<pre><code>node : 그래프를 구성하는 노드들
edge : 노드들을 연결하고 관계짓는 간선들
nodes : 노드들을 담고 있는 데이터 배열
</code></pre>

<h4 id="method-3">Method</h4>

<pre><code>addNode : 그래프에 노드를 추가한다.
removeNode : 그래프에서 노드를 제거한다.
addEdge : 노드와 노드 사이에 간선을 추가한다.
removeEdge : 노드와 노드 사이의 간선(관계)를 제거한다.
hasEdge : 노드와 노드 사이에 간선(관계)가 있는지 확인한다.
contains : 그래프가 주어진 값의 노드를 포함하고 있는지 확인한다.
forEachNode : 주어진 함수를 그래프가 가지고 있는 노드 각각에 대해 실행한다.
</code></pre>

<h4 id="그래프를-코드로-표현하는-2가지-방법">그래프를 코드로 표현하는 2가지 방법</h4>

<ul>
<li>1. 인접 행렬 그래프</li>
<li>2. 인접 리스트 그래프의 두가지로 나눌 수 있다.</li>
</ul>

<h4 id="인접-행렬-그래프">인접 행렬 그래프</h4>

<pre><code>장점: 직관적이며 쉽게 구현 가능
단점: 불필요한 정보의 저장이 많으며, 그래프의 크기가 커지면 메모리 초과가 발생할 수 있음
구현: int형의 2차원 배열을 주로 이용하며, 이동할 수 있으면 1, 없으면 0으로 표기함
</code></pre>

<h4 id="인접-리스트-그래프-갈-수-있는-곳만-저장">인접 리스트 그래프 - &ldquo;갈 수 있는 곳만 저장&rdquo;</h4>

<pre><code>장점: 필요한 정보만 저장하여 메모리 절약 가능
단점: 인접행렬에 비해 다소 어려움
구현: 리스트(List)나 벡터(Vector)등의 자료구조를 이용하여 각 정점에서 이동가능한 정점들을 저장(List나 Vector를 이용한 2차원 배열이라 생각하면 이해하기 쉬움)
</code></pre>

<h4 id="길찾기-알고리즘">길찾기 알고리즘</h4>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-04 at 2.17.29 PM.png" alt="" /></p>

<h2 id="tree">Tree</h2>

<h4 id="tree-란">Tree 란?</h4>

<ul>
<li>트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨</li>
<li>부모-자식 관계를 이루는 노드들로 구성된 자료 구조</li>
<li>컴퓨터 directory 구조 비슷 특정한 파일을 찾을때 폴더안에 폴더가 있고 그안에 파일이 있다 이러한 구조를 Tree 구조라고 한다.(조직도)
<br />
<br /></li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.10.35 PM.png" alt="" /></p>

<h4 id="tree-종류에는-4가지가-대표적으로-있다">Tree 종류에는 4가지가 대표적으로 있다.</h4>

<ul>
<li>1.이진 트리 (binary Tree) 란?</li>
<li>2.편향 이진트리(skewed binary tree)란?</li>
<li>3.포화 이진트리(full binary tree)란?</li>
<li>4.완전 이진트리(complete binary tree)란?</li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-04 at 2.52.31 PM.png" alt="" /></p>

<ul>
<li><p>1.이진 트리 (binary Tree) 란?</p>

<ul>
<li><p>이진 트리에서 각 노드는 <code>최대 2</code>개의 자식을 가진다.</p></li>

<li><p>이진트리인 경우 <code>왼쪽</code>서브트리와 <code>오른쪽</code> 서브트리로 구성된다.  여기서 <code>중요한점</code>은 왼쪽과 오른쪽 서브트리를 확실하게 구분한다는 것이다.</p></li>
</ul></li>

<li><p>2 편향 이진트리(skewed binary tree)란?</p>

<ul>
<li>한쪽으로만 되어있는 한쪽 자식만 가지고 있는 것</li>
<li>liked list 와 같이 생각할수 있다.</li>
</ul></li>

<li><ol>
<li>포화 이진 트리(Full Binary Tree) ?</li>
</ol>

<ul>
<li>모든 레벨이 꽉 찬 이진 트리</li>
</ul></li>

<li><ol>
<li>완전 이진 트리(Complete Binart Tree) 란?</li>
</ol>

<ul>
<li>포화 이진 트리처럼 모든 레벨이 꽉 찬 상태는 아니지만, 차곡차곡 빈 틈 없이 노드가 채워진 이진 트리



<br /></li>
</ul></li>
</ul>

<h4 id="용어">용어</h4>

<pre><code>  루트 노드(root node) : 부모가 없는 노드. 트리는 하나의 루트 노드만을 가진다.
  단말 노드(leaf node) : 자식이 없는 노드이다.
  내부(internal) 노드 : 리프 노드가 아닌 노드.
  링크(link) : 노드를 연결하는 선 (edge, branch 라고도 부름).
  형제(sibling) : 같은 부모를 가지는 노드.
</code></pre>

<h4 id="property-4">Property</h4>

<pre><code>nodes : 값과 자식들로 이루어진, 노드들의 모임
edge : 노드들을 서로 연결하는 간선
</code></pre>

<h4 id="method-4">Method</h4>

<pre><code>addChild() : 주어가 되는 노드에 자식 노드를 추가한다.
removeNode() : 주어진 값을 가진 노드를 삭제한다.
contains() : 주어진 값을 트리에 있는 노드들이 가지고 있는지 확인한다.
</code></pre>

<h2 id="binary-search-tree">binary search tree</h2>

<ul>
<li>이진 탐색 트리(binary search tree)는 이진 트리 기반의 <code>탐색</code>을 위한 자료 구조이다</li>
</ul>

<p>이진 탐색 트리는 4개의 조건이 있다</p>

<ul>
<li><p>바이너리 서치 트리는 세 가지 특징을 가지고 있습니다.</p>

<ul>
<li><ol>
<li>트리의 각 노드가 갖는 자식 노드의 수가 <strong>2개 이하</strong>가 되어야 합니다.</li>
</ol></li>

<li><ol>
<li>부모 노드의 <strong>왼쪽 하위 트리</strong>에 있는 모든 노드의 데이터는 부모의 데이터보다 <strong>작거나 같아야</strong> 합니다.</li>
</ol></li>

<li><ol>
<li>부모 노드의 <strong>오른쪽 하위 트리</strong>에 있는 모든 노드의 데이터는 부모의 데이터보다 <strong>커야</strong> 합니다.</li>
</ol></li>
</ul></li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.16.03 PM.png" alt="" /></p>

<ul>
<li><p>바이너리 서치 트리를 순회하는 방법에는 두 가지가 있습니다.</p></li>

<li><p>DFS (깊이 우선 탐색, Depth-First Search):</p></li>
</ul>

<blockquote>
<p>루트를 시작으로 점차 깊이 들어갔다가, 가장 깊은 depth에 도달했을 때 다시 나오고, 또 다시 깊이 들어가는 방식을 반복하며 전체 트리를 순회합니다.</p>
</blockquote>

<ul>
<li>BFS (너비 우선 탐색, Breadth-First Search):</li>
</ul>

<blockquote>
<p>sibling을 먼저 탐색하고, 그 후 다음 depth로 들어가 해당 depth의 slibling을 탐색하는 식으로 전체 트리를 순회합니다.</p>
</blockquote>

<h4 id="알고리즘-방법-추가학습">알고리즘 방법 (추가학습)</h4>

<pre><code>&lt;탐색 알고리즘&gt;
&lt;삽입 알고리즘&gt;
&lt;삭제 알고리즘&gt;
이진 탐색 트리의 시간복잡도 분석
이진 탐색 트리에서는 최상의 경우 시간복잡도가 O(logn)인 탐색을 할 수 있다.
</code></pre>

<h4 id="property-5">Property</h4>

<pre><code>left :  루트노드의 왼쪽에 있는 노드들  오른쪽보다 작은 
right : 루트 노드 의 오른쪽에 있는 노드들 왼쪽보다 큰 
value : 노드의 값
</code></pre>

<h4 id="method-5">Method</h4>

<pre><code>insert : 주어진 값으로 노드를 만들어, 맞는 위치에 삽입
contains : 트리를 반복하여 주어진 값이 있는지 확인
delete : 노드를 삭제하고 트리 위치를 조정 
</code></pre>

<h4 id="삭제하는-3가지-방법">삭제하는 3가지 방법</h4>

<ul>
<li><p>1.맨밑에 지울때 리프한번의 연산 <code>O(1)</code></p></li>

<li><p>2.자식이 한개인노드를 지울때 두번의 연산 일어난다. <code>O(n)</code></p></li>

<li><p>3.자식이 2개이상인 노드를 지울때 이자리에 올려줄 친구를 찾는다.??? <code>O(n)</code></p></li>
</ul>

<h2 id="hash-table">Hash Table</h2>

<h4 id="hash-table-란">Hash Table 란?</h4>

<ul>
<li><p>데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이 때 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)라고 합니다.</p></li>

<li><p>값을 가공하기 위해서는 해쉬 함수가 필요하다</p></li>

<li><p>해쉬 함수란?</p>

<ul>
<li>키값을 (Dog)  을 넣으면 고유의 값(!@#1)이 나와서 hi 를 찾게 해준다.</li>
<li>0 부터 key를 담은 값의 length 만큼만 반환시켜줄수 있어야 한다.</li>
<li>언제든지 key 를 넣었을때 같은 값이 나와야 한다.</li>
<li>어떠한 저장도 할수 없다. 기억을 가지고 있지않고 그때그때 값을 내밷어야 한다.</li>
<li>근데 만약 fox 를 넣었는데 Dog 을 넣었을때 고유의 값 고유의 값(!@#1) 가 나온다면 충돌이 난다.</li>
<li>그래서 고유의 값(!@#1)이 저장되에 있는곳에 0번째에 Dog &gt; 1번째의 hi 를 가르키게 해주고 저장해놓고  0번째의 fox &gt; 1번째의 hello  를 저장해놓게 된다면 고유의 값(!@#1) 값에서 0번째들안에 fox 를 찾아 value 값을 반환해주게 하면 된다 !
<br /></li>
</ul></li>
</ul>

<h4 id="특징">특징</h4>

<ul>
<li>key,value를가지고 있는 것</li>
<li>어떤 특정 값을 받으면 그 값을 해시 함수에 통과시켜 나온 인덱스(index)에 저장하는 자료구조</li>
<li>O(1)의 시간복잡도로 해결할 수 있다</li>
<li>고유에 인댁스로 바로 접근할수 있기  때문에 빠르게 검색할수 있다.<br /></li>
<li>해시 테이블은 사전을 구현하는 가장 효율적인 자료구조이다.
<br />
<br /></li>
</ul>

<h4 id="주의">주의</h4>

<ul>
<li><p>해쉬 테이블은 원래 O(1) 를 자랑하는데 O(n) 이 될수 있다.</p></li>

<li><p>내가 insert 한 값이 same bucket 에 들어가게 된다면 O(n) 이 된다.</p></li>

<li><p>when a hash table is growing, it resizes itself  and every element must be rehashed</p></li>
</ul>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2019-12-31 at 5.53.57 PM.png" alt="" /></p>

<ul>
<li><p>스토리지 ?</p></li>

<li><p>튜퓰 ?</p></li>

<li><p>bucket ?
<img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-05 at 12.36.09 PM.png" alt="" /></p></li>
</ul>

<h4 id="property-6">Property</h4>

<pre><code>limit : 한 슬롯(버킷) 안에 들어갈 수 있는 데이터의 최대 갯수이다.
storage : 데이터들이 저장되는 테이블이다.
</code></pre>

<h4 id="method-6">Method</h4>

<pre><code>insert : 주어진 index로 테이블에 데이터를 추가한다.
retrieve : 주어진 Index로 데이터 값을 찾아 리턴한다.
remove : 주어진 키값에 해당하는 index에 들어 있는 값을 제거한다.
</code></pre>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>Complexity Analysis : 복잡도 분석이다.</p>

<ul>
<li><p>복잡도 분석이란 무엇이냐?</p>

<ul>
<li>알고리즘이 문제를 해결하는데 얼마나 시간과 공간을 차지 하는지 나타내는 지표이다.
<br />
<br /></li>
</ul></li>
</ul>

<h4 id="시간복잡도에서는-big-o표기-할수-있다">시간복잡도에서는 Big-O표기 할수 있다.</h4>

<ul>
<li>O(1) – 상수 시간 :
<br /></li>
</ul>

<blockquote>
<p>입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거친다.</p>

<p>예 ) array lookup, hash table insertion</p>
</blockquote>

<ul>
<li>O(log n) – 로그 시간 :</li>
</ul>

<blockquote>
<p>입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.</p>

<p>예 ) binary search(tree)</p>
</blockquote>

<ul>
<li>O(n) – 직선적 시간 :</li>
</ul>

<blockquote>
<p>문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다.</p>

<p>예 ) linked list, array search</p>
</blockquote>

<ul>
<li>O(n^2) – 2차 시간 :</li>
</ul>

<blockquote>
<p>문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.</p>

<p>예 ) constant time operation inside two nested for-loops</p>
</blockquote>

<ul>
<li>O(C^n) – 지수 시간 :</li>
</ul>

<blockquote>
<p>문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱이다.</p>

<p>예 ) recursion 피보나치 수열 등등</p>
</blockquote>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 11.35.18 AM.png" alt="" /></p>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 11.35.32 AM.png" alt="" /></p>

<h4 id="시간복잡도의-예시">시간복잡도의 예시</h4>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 11.33.25 AM.png" alt="" /></p>

<p><strong>Arrays</strong></p>

<ul>
<li>lookup O(1)</li>
</ul>

<blockquote>
<p>인덱스를 알고있기때문에 바로찾을수 있다.</p>
</blockquote>

<ul>
<li>Assign O(1)</li>
</ul>

<blockquote>
<p>인덱스를 알고있기 때문에 바로 바꿔버릴수 있다.</p>
</blockquote>

<ul>
<li>insert O(n)</li>
</ul>

<blockquote>
<p>값을 추가하고 나머지 값들의 인덱스가 바꿔지기 때문에 시간복잡도가 늘어난다.</p>
</blockquote>

<ul>
<li>Remove O(n)</li>
</ul>

<blockquote>
<p>특정값을 제거하면 나머지 값을을 땡겨서 인덱스를 맞춰야 하기 때문에 시간복잡도가 늘어난다.</p>
</blockquote>

<ul>
<li>find(value) O(n)</li>
</ul>

<blockquote>
<p>값이 어디에있는지 찾으려면 모든 인덱스값에 접근해야 하기때문에 시간복잡도가 늘어난다.</p>
</blockquote>

<p><strong>Linked Lists</strong></p>

<ul>
<li>Lookup(Position) O(n)</li>
</ul>

<blockquote>
<p>특정 위치 를 찾으려고 한다.</p>

<p>인덱스를 알수가 없다 무조건 head 부터 시작해야 한다. head 부터 시작해서 차례대로 찾는다.</p>
</blockquote>

<ul>
<li>Find (value )O(n)</li>
</ul>

<blockquote>
<p>특정 값을 를 찾으려고 한다.</p>

<p>인덱스를 알수가 없다 무조건 head 부터 시작해야 한다. head 부터 시작해서 차례대로 찾는다.</p>
</blockquote>

<ul>
<li>Assign O(n)</li>
</ul>

<blockquote>
<p>값을 바꿔주려고 할때 그값을 찾으러 갈때 head부터 차례대로 가기 때문에 시간복잡도가 O(n) 이 된다.</p>
</blockquote>

<ul>
<li>insert O(1)</li>
</ul>

<blockquote>
<p>만약 내가 어디에 추가하고싶은지 알고있다면 O(n) 된다.</p>

<p>왜냐하면 기존 에 값의 next pointer 를 알고있기때문에  next pointer 를 내가 추가하고자 하는 값에 연결시켜주고 내가 많든 값의 next pointer 를 다음 값에 연결시켜주면 되는 것이다.</p>
</blockquote>

<ul>
<li>Removal O(n)  or O(n)</li>
</ul>

<blockquote>
<p><code>head</code> 처음에 값을 제거하려면  O(1)된다.</p>

<p><code>midle</code> 중간에 값을 제거하려면 O(n) 된다.</p>

<p>왜냐하면 값을 제거하기위 next-poniter 를 옮겨주면 되지만 뒤에 poniter 를 가지고 있지 않기 때문이다. 그래서 찾아야한다.</p>
</blockquote>

<p><code>하지만 Doubly_linked lists</code> 에서는 <code>insert</code> 와 <code>remove</code> 는 O(1) 이된다
왜냐하면 이전에 pointer 와 다음에 poniter 둘다를 가지고 있기 때문이다.</p>

<p><strong>Array % Singly-Linked List &amp; Doubly-Linked Lists</strong></p>

<h4 id="array">array</h4>

<pre><code>  O(1) : lookUp
  O(n) : insert/remove
</code></pre>

<h4 id="singly-linked-list">Singly-Linked List</h4>

<pre><code>  O(1) : insert
  O(n) : lookup, remove
</code></pre>

<h4 id="doubly-linked-lists">Doubly-Linked Lists</h4>

<pre><code>  O(1) : insert/remove
</code></pre>

<p><code>여기서 주의해야하는 것이</code></p>

<blockquote>
<p>Doulbly-linked Lists 는 각각의 노드들이 이전 다음 pointers 를 가지고 있기 때문에 <code>공간 복잡도</code>에서 조금 늘어나는 차이가 있다.</p>
</blockquote>

<p><strong>Trees</strong></p>

<ul>
<li>Find O(n)</li>
</ul>

<blockquote>
<p>각각의 노드를 검색해야하기 때문에 시간복잡도가 늘어난다.</p>

<p>루트부터 쫙 찾야아 한다.</p>
</blockquote>

<p><strong>Binary Search Tree</strong></p>

<p><code>특정조건이 가지고 있다.</code></p>

<ul>
<li>find O(log n)</li>
</ul>

<blockquote>
<p>특정값을 찾겠다고 하면</p>

<p>3번만에 확인이 가능하다.</p>

<p>빠른것이다.</p>
</blockquote>

<p>만약 <code>linked-list</code> 처럼 형태가 만들어진다면 (일자형 ) <code>find O(n)</code> 되버린다.</p>

<p>이런경우를 방지하기 위해 <code>Tree 구조</code>를 틀어버린다.</p>

<p><img src="/tutorial/2019-12-21-spint2_files/Screen Shot 2020-01-02 at 8.09.06 PM.png" alt="" /></p>

<p>그림에 나와있는 것처럼 추가할때마다 벨런스를 에 맞겠 조정을 해주면 다시</p>

<p>find O(log n) 의 구조를 유지할수 있다.</p>

<ul>
<li>정렬된 구조에서 배열을 쓰지않고 binary  search 구조를 쓰는 이유가 있을까요?</li>
</ul>

<blockquote>
<p>Array 는 메모리를 계속 차지한다.</p>

<p>Trees 구조는  linked-list 도 쓸수 있기때문에 구석구속 메모리를 쓸수 있어 효율적이다.</p>

<p>메모리 효율적인면에서 BST 가 더낳다.</p>
</blockquote>

          </div>

          

        </div>

        <div class="body-footer">
          Last updated on Apr 29, 2019
        </div>

      </article>

      <footer class="site-footer">
  
  <p class="powered-by">
    <a href="/privacy/">Privacy Policy</a>
  </p>
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
  </p>
</footer>


    </main>
  </div>
</div>

    

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
      

      
      
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.11384ce0c8c15291681687fbc4e0b90a.js"></script>

  </body>
</html>


