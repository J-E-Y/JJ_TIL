<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.2.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="John Jung">

  
  
  
    
  
  <meta name="description" content="1. What is &ldquo;React&rdquo;??  인터렉션이 늘어남에 OR 관리 해야할 Dom 이 많아질수록 관리하기가 힘들어짐 프론트 엔드 라이브러리, 프레임웍 많이 있다. 그중에 하나가 React 이다.  React ES6 반드시 알아야 할 ES6 문법들 1) Destructuring(구조 분해) 2) spread operator(전개 구문) 3) rest parameters 4) default parameters(기본 매개변수) 5) template literals 6) arrow function(화살표 함수) 7) for-of loop  1.Destructuring(구조 분해)
 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식">

  
  <link rel="alternate" hreflang="en-us" href="/tutorial/2020-01-20-react/">

  


  

  

  

  

  

  

  
  
  
  <meta name="theme-color" content="#EAF04E">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous" title="hl-light" disabled>
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark">
        
      
    

    

    

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Playfair+Display:400,700|Fauna+One">
  

  <link rel="stylesheet" href="/styles.css">
  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-153100405-1', 'auto');
      
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/tutorial/2020-01-20-react/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="JohnJung">
  <meta property="og:url" content="/tutorial/2020-01-20-react/">
  <meta property="og:title" content="__React | JohnJung">
  <meta property="og:description" content="1. What is &ldquo;React&rdquo;??  인터렉션이 늘어남에 OR 관리 해야할 Dom 이 많아질수록 관리하기가 힘들어짐 프론트 엔드 라이브러리, 프레임웍 많이 있다. 그중에 하나가 React 이다.  React ES6 반드시 알아야 할 ES6 문법들 1) Destructuring(구조 분해) 2) spread operator(전개 구문) 3) rest parameters 4) default parameters(기본 매개변수) 5) template literals 6) arrow function(화살표 함수) 7) for-of loop  1.Destructuring(구조 분해)
 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식"><meta property="og:image" content="/img/icon-192.png">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2020-01-14T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2020-01-14T00:00:00&#43;00:00">
  

  

  

  <title>__React | JohnJung</title>

</head>
<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" class="dark">
  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">JohnJung</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/tutorial/">
          
          <span>Technical Documents</span>
          
          </a>
        </li>

        

        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/#posts">
          
          <span>Posts</span>
          
          </a>
        </li>

        

        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/#projects">
          
          <span>Projects</span>
          
          </a>
        </li>

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>



<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      




<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" id="search-query" placeholder="Search..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/">Today I Learned</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/it-terminology/">1.Technical terms</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/git/">2.Git</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/html/">3.Html</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/css/">4.Css</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/bootstrap/">5.Bootstrap</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/python/">5.Python</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript/">6.Javascript</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/2019-11-14-javascript-daliy-coding-level-1/">__Algorithm_1</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-11-14-javascript-daliy-coding-level-2/">__Algorithm_2</a>
      </li>
      
      <li >
        <a href="/tutorial/javascript_algorithm/">__Algorithm_3</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-11-14-javascript-my-mdn/">__My_MDN</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-11-26-js-post/">__My_Notes</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_dictionary/">CodeStates</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_note/">_section1</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/2019-12-21-sprint1/">__Immersive Prep</a>
      </li>
      
      <li >
        <a href="/tutorial/2019-12-21-spint2/">__DS &amp; OOP</a>
      </li>
      
      <li >
        <a href="/tutorial/2020-01-05-spint-3/">__Iheritance Patterns</a>
      </li>
      
      <li >
        <a href="/tutorial/2020-01-02-check-point/">__Check_Point</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_q1/">_section2</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/2020-01-13-sever/">__Server</a>
      </li>
      
      <li class="active">
        <a href="/tutorial/2020-01-20-react/">__React</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/javascript_q2/">_section3</a>

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-4 docs-toc"style="
    right: -88px;">
      
      <p class="docs-toc-title">On this page</p>
      

      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#1-what-is-react">1. What is &ldquo;React&rdquo;??</a></li>
<li><a href="#react-es6">React ES6</a>
<ul>
<li>
<ul>
<li><a href="#반드시-알아야-할-es6-문법들">반드시 알아야 할 ES6 문법들</a></li>
</ul></li>
</ul></li>
<li><a href="#jsx">JSX</a></li>
<li><a href="#1-data-flow">1. Data flow</a></li>
<li><a href="#2-컴포넌트와-props">2. 컴포넌트와 Props</a></li>
<li><a href="#3-state">3. State</a></li>
<li><a href="#life-cycle"><strong>Life Cycle</strong></a></li>
<li><a href="#component-만들기">Component 만들기</a></li>
<li><a href="#props-만들기">Props 만들기</a></li>
<li><a href="#component-파일로-분리하기">Component 파일로 분리하기</a></li>
<li><a href="#state의-사용">state의 사용</a></li>
<li><a href="#state-key">state (Key)</a></li>
</ul></li>
</ul>
</nav>

      <ul class="nav toc-top">
        <li><a href="#">Back to top</a></li>
      </ul>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-7 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article" itemscope itemtype="http://schema.org/Article">

        <div class="docs-article-container">
          <h1 itemprop="name">__React</h1>

          <div class="article-style" itemprop="articleBody">
            

<h2 id="1-what-is-react">1. What is &ldquo;React&rdquo;??</h2>

<ul>
<li>인터렉션이 늘어남에 OR 관리 해야할 Dom 이 많아질수록 관리하기가 힘들어짐</li>
<li>프론트 엔드 라이브러리, 프레임웍 많이 있다. 그중에 하나가 React 이다.</li>
</ul>

<h2 id="react-es6">React ES6</h2>

<h4 id="반드시-알아야-할-es6-문법들">반드시 알아야 할 ES6 문법들</h4>

<pre><code>1) Destructuring(구조 분해)
2) spread operator(전개 구문)
3) rest parameters
4) default parameters(기본 매개변수)
5) template literals
6) arrow function(화살표 함수)
7) for-of loop
</code></pre>

<p>1.Destructuring(구조 분해)</p>

<blockquote>
<p>배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식</p>
</blockquote>

<pre><code class="language-js">
var a, b, rest;

[a, b] = [10, 20];

console.log(a); //10
console.log(b); //20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(a); //10
console.log(b); //20
console.log(rest); //[30, 40, 50]



({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}

var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2




선언에서 분리한 할당

var a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2



기본값

var a, b;

[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7



변수 값 교환하기

var a = 1, b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1


일부 반환 값 무시하기

function f() {
    return [1, 2, 3];
}

var [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

반환 값을 모두 무시할 수도 있음
[,,] = f();




새로운 변수 이름으로 할당하기

var o = {p: 42, q: true};
var {p: foo, q: bar} = o;
//var foo = 42; // 이것과 동일하다. 
//var bar = true; // 이것과 동일하다. 


//[foo, bar] = [42, true]   같다 왜??



console.log(foo); // 42

console.log(bar); // true

</code></pre>

<p>2.spread operator(전개 구문)</p>

<blockquote>
<p>배열이나 문자열과 같이 반복 가능한 문자를 0개 이상의 인수 (함수로 호출할 경우) 또는 요소 (배열 리터럴의 경우)로 확장하여, 0개 이상의 키-값의 쌍으로 객체로 확장시킬 수 있음.</p>
</blockquote>

<pre><code class="language-js">
function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

console.log(sum.apply(null, numbers)); //6
console.log(sum(...numbers)); //6
//함수에 배열을 인자로 넣고 싶을 대, apply대신 배열을 전개해서 사용할 수 있다.


구문


myFunction(...iterableObj);


[...iterableObj, '4', 'five', 6];


let obj = {a: 1, b: 2};
let objClone = { ...obj }; //얕은 복사
console.log(objColne); //{a: 1, b: 2}


배열의 연결(concat 대신 사용)


var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = arr1.concat(arr2); //arr1: [0, 1, 2, 3, 4, 5]



var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = [...arr1, ...arr2]; //arr1: [0, 1, 2, 3, 4, 5]





</code></pre>

<p>3.rest parameters</p>

<ul>
<li>정해지지 않은 수(an indefinite number, 부정수) 인수를 배열로 나타낼 수 있게 함.</li>
</ul>

<pre><code class="language-js">
function sum(...theArgs) {
  return theArgs.reduce((previous, current) =&gt; {
    return previous + current;
  });
}

// 만약 function sum(arguments) 으로 하면 
// sort, map, forEach 또는 pop 같은 메서드 가 되지 않는다. 

console.log(sum(1, 2, 3)); //6
console.log(sum(1, 2, 3, 4)); //10


Rest 파라미터와 arguments 객체간의 차이

`Rest 파라미터`는 구분된 이름(예, 함수 표현에 정식으로 정의된 것)이 주어지지 않은 유일한 대상인 반면, arguments 객체는 함수로 전달된 모든 인수를 포함합니다.

`arguments 객체`는 실제 배열이 아니고 rest 파라미터는 Array 인스턴스로, sort, map, forEach 또는 pop 같은 메서드가 바로 인스턴스에 적용될 수 있음을 뜻합니다.
즉 arguments 객체는 자체에 특정 추가 기능이 있습니다 (callee 속성처럼).


Rest 파라미터 해체

function f(...[a, b, c]) {
  return a + b + c;
}

f(1)// NaN  (b 와 c 가 undefined)
f(1,2)// NaN  ( c 가 undefined)
f(1, 2, 3)    // 6
f(1, 2, 3, 4) // 6 (4번 째 파라미터는 해체되지 않음)

</code></pre>

<p>4.default parameters(기본 매개변수)</p>

<blockquote>
<p>기본 함수 매개변수(default function parameter)를 사용하면 값이 없거나 undefined가 전달될 경우 매개변수를 기본값으로 초기화할 수 있음.</p>
</blockquote>

<pre><code class="language-js">


function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5, 2)); //10  
console.log(multiply(5)); //5 // 5 * 1



</code></pre>

<p>5.template literals</p>

<blockquote>
<p>내장된 표현식을 허용하는 문자열 리터럴입니다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있습니다. 이전 버전의 ES2015사양 명세에서는 &ldquo;template strings&rdquo; (템플릿 문자열) 라고 불려 왔습니다.</p>
</blockquote>

<pre><code class="language-js">
var text = `hello`;
console.log(`text: ${text}, type: ${typeof text}`);
//text: hello, type: string

</code></pre>

<p>6.arrow function(화살표 함수)</p>

<blockquote>
<p>화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다. 화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.</p>
</blockquote>

<p><code>화살표 함수는 항상 익명입니다.</code></p>

<pre><code class="language-js">var materials = [
  'Hydrogen',
  'Helium',
  'Lithium',
  'Beryllium'
];



materials.map(value =&gt; value.length);
// //Array [8, 6, 7, 9]

</code></pre>

<p>7.for-of loop</p>

<blockquote>
<p>for&hellip;of 명령문은 반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복하고 각 개별 속성값에 대해 실행되는 문이 있는 사용자 정의 반복 후크를 호출하는 루프를 생성합니다.</p>
</blockquote>

<pre><code class="language-js">

const array1 = ['a', 'b', 'c'];

for (const element of array1) {
  console.log(element);
}
// expected output: &quot;a&quot;
// expected output: &quot;b&quot;
// expected output: &quot;c&quot;

Map의 대한 반복문

인스턴스의 키와 value 값을 가져온다. 

let iterable = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);

for (let entry of iterable) {
  console.log(entry);
}
// [a, 1]
// [b, 2]
// [c, 3]

 인스턴스에 value값을 가져온다. 

for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3




</code></pre>

<h2 id="jsx">JSX</h2>

<p>JSX 란?</p>

<ul>
<li><p>자바 스크립트의 확장 문법</p></li>

<li><p>반드시 하나의 엘리먼트로 감싸야 한다.</p></li>

<li><p>자바스크립트 코드를 적용할 땐 { } 안에 작성한다.</p></li>

<li><p>JSX 내부에선 if문을 사용할 수 없다. IIFE or 삼항연산자 사용</p></li>

<li><p>엘리먼트의 클래스 이름을 적용할 때, className 을 사용(class는 ES6에 존재하기 때문)</p></li>
</ul>

<p>JSX 객체 표현</p>

<blockquote>
<p>Babel은 JSX를 React.createElement() 호출로 컴파일합니다.</p>
</blockquote>

<ul>
<li><p>아래 두 예제는 동일합니다.</p>

<pre><code>
// 
const element = (
&lt;h1 className=&quot;greeting&quot;&gt;
Hello, world!
&lt;/h1&gt;
);


const element = React.createElement(
'h1',
{className: 'greeting'},
'Hello, world!'
);

</code></pre></li>
</ul>

<p>React.createElement() 는 버그 없는 코드를 작성하는 데 도움을 주는 몇가지 체크를 하지만 기본적으로는 아래와 같은 객체를 생성합니다.</p>

<pre><code class="language-js">

// Note: this structure is simplified
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  }
};

</code></pre>

<p>이 객체는 <code>“React elements”</code> 부릅니다. 화면에서 볼 수 있는 내용에 대한 설명으로 생각할 수 있습니다. React는 이 객체를 읽어들이고 이를 사용하여 DOM을 구성하고 최신 상태로 유지합니다.</p>

<h2 id="1-data-flow">1. Data flow</h2>

<ul>
<li>부모 컴포넌트에서 자식 컴포넌트로 데이터가 흐름</li>
<li>자식이 부모컴포넌트에 데이터를 줄수 없음</li>
</ul>

<p><img src="/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 1.50.10 PM.png" alt="" /></p>

<h2 id="2-컴포넌트와-props">2. 컴포넌트와 Props</h2>

<ul>
<li><p>Props 란?</p>

<ul>
<li>Props: <code>상위</code> 컴포넌트가 <code>하위</code> 컴포넌트에게 <code>내려</code>주는 <code>데이터(속성)</code></li>
<li>단순히 사용만 할 수 있다. 변경할 수 없다.</li>
</ul></li>

<li><p>컴포넌트?</p>

<ul>
<li>개념상 컴포넌트는 자바스크립트 함수와 비슷함.</li>
<li>임의의 입력 (“props”라고 부르는)을 받아들이고 어떤 게 화면에 나타나야 하는 지를 설명하는 React 요소를 반환함.</li>
</ul></li>

<li><p>2-1. 함수형 및 클래스 컴포넌트</p></li>
</ul>

<blockquote>
<p>컴포넌트는 자바스크립트의 함수형 및 클래스형으로 작성할 수 있다.</p>
</blockquote>

<pre><code class="language-js">
`아래는 함수형으로 작성한 컴포넌트`


function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}


`아래는 ES6를 사용해 작성한 컴포넌트`


class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
    }
}


위의 두 컴포넌트는 React 관점에서 보면 동일하지만 ES6의 클래스 기능을 사용한 컴포넌트가 몇가지 기능을 더 가지고 있음.


</code></pre>

<p>2-2. 컴포넌트 렌더링</p>

<ul>
<li>props: React가 유저가 정의한 컴포넌트를 나타내는 요소를 볼 때 JSX 속성을 이 컴포넌트에 단일 객체로 전달하는데, 이 객체를 props라고 부름</li>
</ul>

<p><code>Bable</code></p>

<pre><code class="language-js">


function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name=&quot;Rami&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById('root')
);

</code></pre>

<p><img src="/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 2.29.59 PM.png" alt="" /></p>

<p><code>여기서의 props: { name: 'rami' }</code>
<code>Welcome(props)</code>
컴포넌트의 이름은 항상 <code>대문자</code>로 시작해야 함.</p>

<p>2-3. 컴포넌트 결합</p>

<blockquote>
<p>컴포넌트는 출력될 때 다른 컴포넌트를 참조할 수 있습니다. 이를 통해 모든 세부 레벨에서 동일한 컴포넌트 추상화를 사용할 수 있습니다.</p>
</blockquote>

<pre><code class="language-js">//-----------------component-------------------------------
function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
//-----------------component-------------------------------
 
function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name=&quot;Sara&quot; /&gt;  // name=&quot;Sara&quot; &gt;&gt;&gt;props
      &lt;Welcome name=&quot;Cahal&quot; /&gt; // name=&quot;Cahal&quot; &gt;&gt;&gt;props
      &lt;Welcome name=&quot;Edite&quot; /&gt; // name=&quot;Edite&quot;  &gt;&gt;&gt;props
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('root')
);


</code></pre>

<p><img src="/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 2.47.22 PM.png" alt="" /></p>

<p>2.4 Props는 읽기전용</p>

<h2 id="3-state">3. State</h2>

<p>State 란?</p>

<ul>
<li><p>컴포넌트가 갖는 <code>상태</code>. <code>객체의 형태</code>로 컴포넌트 내에서 보관하고 관리한다.</p></li>

<li><p>1) <code>class</code> 컴포넌트로 작성되어야 한다</p></li>
</ul>

<blockquote>
<p>class형식으로 무조건 작성되어야 하한다.</p>
</blockquote>

<ul>
<li>2) 반드시 <code>setState</code> 메서드로 값을 변경</li>
</ul>

<blockquote>
<p><code>state의 값을 직접적으로 변경하면 안됨.</code></p>
</blockquote>

<p>state 값을 변경할때 변경 ( setState 메서드 사용할때 ) ==&gt; <code>render() 함수</code>가 실행된다.</p>

<pre><code class="language-js">
class Foo extends Component{
    state = {
        a: 10,
        b: false
    }
	changeState() {        
        //this.state.a = 100; ~~~~~~!!!~~~!!!  직접 바꾸면 안되고 
        this.setState({     // 이렇게 
            a: 100          // 이렇게 
        })                  // 이렇게  바꿔야 한다. 
    }
}


</code></pre>

<ul>
<li>3) State 업데이트는 비동기일 수 있다</li>
</ul>

<blockquote>
<p>React는 여러 setState() 호출을 성능을 위해 단일 업데이트로 배치할 수 있습니다.</p>

<p>this.props 및 this.state 가 비동기로 업데이트될 수 있기 때문에, 다음 state를 계산할 때 해당 값을 신뢰해서는 안됩니다.</p>

<p>예를 들어, 카운터를 업데이트하는 이 코드는 실패할 수 있습니다.</p>
</blockquote>

<pre><code class="language-js">
// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});


</code></pre>

<ul>
<li>이 문제를 해결하기 위해 객체가 아닌 함수를 받는 두 번째 형식의 setState() 를 사용할 수 있습니다.</li>
</ul>

<pre><code class="language-js">

// Correct
this.setState((prevState, props) =&gt; ({
  counter: prevState.counter + props.increment
}));


</code></pre>

<ul>
<li>4)State Update는 병합됨</li>
</ul>

<blockquote>
<p>setState() 를 호출할 때, React는 현재 state와 제공한 객체를 병합합니다.</p>
</blockquote>

<pre><code class="language-js">
constructor(props) {
    super(props);
    this.state = {
        posts: [],
        comments: []
    };
}

componentDidMount() {
    fetchPosts().then(response =&gt; {
      this.setState({
        posts: response.posts
        //여기서의 setState()는 posts만 변경할 뿐 comments는 건드리지 않음.
      });
    });

    fetchComments().then(response =&gt; {
      this.setState({
        comments: response.comments
        //여기서의 setState()는 comments만 변경할 뿐 posts는 건드리지 않음.
      });
    });
  }



</code></pre>

<ul>
<li>5) 데이터는 아래로 흐름</li>
</ul>

<blockquote>
<p>부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없습니다.</p>
</blockquote>

<p><strong>State는 props와 비슷하지만 컴포넌트에 의해 완전히 제어되며 private 속성이다.</strong></p>

<h2 id="life-cycle"><strong>Life Cycle</strong></h2>

<p>컴포넌트가 브라우저에 보여질 때, 업데이트될 때, 사라질 때 각 단계 전,후로 특정 메서드가 호출된다.</p>

<p>라이프 사이클 이벤트란</p>

<p>React의 컴포너트는 생명주기(Life cycle)을 가진다. 생명주기란 컴포넌트가 생성되고 사용되고 소멸될 때 까지 일련의 과정을 말한다.
이러한 생명주기 안에서는 특정 시점에 자동으로 호출되는 메서드가 있는데, 이를 라이프 사이클 이벤트라고 한다.</p>

<p><img src="/tutorial/2020-01-20-react_files/Screen Shot 2020-01-20 at 4.48.31 PM.png" alt="" /></p>

<ul>
<li><p>많은 컴포넌트를 가진 어플리케이션에서, 컴포넌트가 제거될 때 리소스를 풀어주는 건 아주 중요한 일</p></li>

<li><p>컴포넌트가 DOM에 최초로 렌더링 될 때 React에서 이를 “mounting” 이라고 부릅니다.
메서드명은 componentDidMount라고 써야 함.</p></li>

<li><p>DOM에서 컴포넌트를 삭제할 때 React에서 이를 “unmounting” 이라고 부릅니다.
메서드명은 componentWillUnmount이다.</p></li>
</ul>

<p><code>라이프사이클 훅</code></p>

<blockquote>
<p>컴포넌트가 <code>마운트</code> (mount) 되고 <code>언마운트</code> (unmount) 될 때 <code>특정 코드</code>를 실행하기 위해 컴포넌트 클래스에 특별한 메서드를 선언할 수 있고 이런 메서드들을 “<code>라이프사이클 훅</code>” 이라고 부릅니다.</p>
</blockquote>

<h2 id="component-만들기">Component 만들기</h2>

<p>HTML tag</p>

<pre><code class="language-js">&lt;html&gt;
  &lt;body&gt;
    &lt;header&gt;
      &lt;h1&gt;WEB&lt;/h1&gt;
      world wide web!
    &lt;/header&gt;

    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;1.html&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;2.html&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;3.html&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;

    &lt;article&gt;
      &lt;h2&gt;HTML&lt;/h2&gt;
      HTML is HyperText Markup Language.
    &lt;/article&gt;
  &lt;/body&gt;
&lt;/html&gt;




</code></pre>

<p>App.js</p>

<pre><code class="language-js">
import React, { Component } from &quot;react&quot;;
import logo from &quot;./logo.svg&quot;; //필요없다 현재
import &quot;./App.css&quot;;

class Content extends Component {
  render() {
    return (
      &lt;article&gt;
        &lt;h2&gt;HTML&lt;/h2&gt;
        HTML is HyperText Markup Language.
      &lt;/article&gt;
    );
  }
}

class TOC extends Component {
  render() {
    return (
      &lt;nav&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href=&quot;1.html&quot;&gt;HTML&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;2.html&quot;&gt;CSS&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;3.html&quot;&gt;JavaScript&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    );
  }
}

// 컴퍼넌트를 만들때는 항상 하나의 최상의 tag로 시작해야한다.

class Subject extends Component {
  render() {
    return (
      &lt;header&gt; 
        &lt;h1&gt;WEB&lt;/h1&gt;
        world wide web!
      &lt;/header&gt;
    );
  }
}

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;Subject&gt;&lt;/Subject&gt;
        &lt;TOC&gt;&lt;/TOC&gt;
        &lt;Content&gt;&lt;/Content&gt;
      &lt;/div&gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;



</code></pre>

<h2 id="props-만들기">Props 만들기</h2>

<pre><code class="language-js">import React, { Component } from &quot;react&quot;;
import logo from &quot;./logo.svg&quot;; //필요없다 현재
import &quot;./App.css&quot;;

class Content extends Component {
  render() {
    return (
      &lt;article&gt; // props
        &lt;h2&gt;{this.props.title}&lt;/h2&gt;  
        {this.props.desc}
      &lt;/article&gt;
    );
  }
}

class TOC extends Component {
  render() {
    return (
      &lt;nav&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href=&quot;1.html&quot;&gt;HTML&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;2.html&quot;&gt;CSS&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;3.html&quot;&gt;JavaScript&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    );
  }
}

// 컴퍼넌트를 만들때는 항상 하나의 최상의 tag로 시작해야한다.
class Subject extends Component {
  render() {
    return (
      &lt;header&gt; // props
        &lt;h1&gt;{this.props.title}&lt;/h1&gt;
        {this.props.sub}
      &lt;/header&gt;
    );
  }
}

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;Subject title=&quot;WEB&quot; sub=&quot;world wide web!&quot;&gt;&lt;/Subject&gt;
        &lt;Subject title=&quot;menu&quot; sub=&quot;this is what I wanted to build&quot;&gt;&lt;/Subject&gt;
        &lt;TOC&gt;&lt;/TOC&gt;
        &lt;Content
          title=&quot;HTML&quot;
          desc=&quot; HTML is HyperText Markup Language.&quot;
        &gt;&lt;/Content&gt;
      &lt;/div&gt;
    ); 
  }
}

export default App;



</code></pre>

<h2 id="component-파일로-분리하기">Component 파일로 분리하기</h2>

<blockquote>
<p>만약 하나의 파일에 component가 수천개 있다면 복잡할 것이다.</p>
</blockquote>

<p>App.js</p>

<blockquote>
<p>main JS 파일</p>
</blockquote>

<pre><code class="language-js">
import React, { Component } from &quot;react&quot;;
import logo from &quot;./logo.svg&quot;; //필요없다 현재
import TOC from &quot;./component/TOC&quot;;
import Subject from &quot;./component/subject&quot;;
import Content from &quot;./component/content&quot;;
import &quot;./App.css&quot;;

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;Subject title=&quot;WEB&quot; sub=&quot;world wide web!&quot;&gt;&lt;/Subject&gt;
        &lt;Subject title=&quot;menu&quot; sub=&quot;this is what I wanted to build&quot;&gt;&lt;/Subject&gt;
        &lt;TOC&gt;&lt;/TOC&gt;
        &lt;Content
          title=&quot;HTML&quot;
          desc=&quot; HTML is HyperText Markup Language.&quot;
        &gt;&lt;/Content&gt;
      &lt;/div&gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;




</code></pre>

<p>component파일 안에</p>

<p>subject.js</p>

<blockquote>
<p>component파일</p>
</blockquote>

<pre><code class="language-js">import React, { Component } from &quot;react&quot;;

// 컴퍼넌트를 만들때는 항상 하나의 최상의 tag로 시작해야한다.

class Subject extends Component {
  render() {
    return (
      &lt;header&gt;
        &lt;h1&gt;{this.props.title}&lt;/h1&gt;
        {this.props.sub}
      &lt;/header&gt;
    );
  }
}

export default Subject;



</code></pre>

<p>component파일 안에</p>

<p>content.js</p>

<blockquote>
<p>component파일</p>
</blockquote>

<pre><code class="language-js">
import React, { Component } from &quot;react&quot;;
class Content extends Component {
  render() {
    return (
      &lt;article&gt;
        &lt;h2&gt;{this.props.title}&lt;/h2&gt;
        {this.props.desc}
      &lt;/article&gt;
    );
  }
}

export default Content;



</code></pre>

<p>component파일 안에</p>

<p>TOC.js</p>

<blockquote>
<p>component파일</p>
</blockquote>

<pre><code class="language-js">
import React, { Component } from &quot;react&quot;;

class TOC extends Component {
  render() {
    return (
      &lt;nav&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href=&quot;1.html&quot;&gt;HTML&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;2.html&quot;&gt;CSS&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;3.html&quot;&gt;JavaScript&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    );
  }
}

export default TOC;



</code></pre>

<h2 id="state의-사용">state의 사용</h2>

<blockquote>
<p>리팩토링과 마찬가지이다.</p>
</blockquote>

<pre><code class="language-js">import React, { Component } from &quot;react&quot;;
import logo from &quot;./logo.svg&quot;; //필요없다 현재
import TOC from &quot;./component/TOC&quot;;
import Subject from &quot;./component/subject&quot;;
import Content from &quot;./component/content&quot;;
import &quot;./App.css&quot;;

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      subject: { title: &quot;WEB&quot;, sub: &quot;world wide web!&quot; }
    };
  }
  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;Subject
          title={this.state.subject.title} //this 로 constructor 에 속성값 불러온다. 
          sub={this.state.subject.sub}
        &gt;&lt;/Subject&gt;
        &lt;TOC&gt;&lt;/TOC&gt;
        &lt;Content
          title=&quot;HTML&quot;
          desc=&quot; HTML is HyperText Markup Language.&quot;
        &gt;&lt;/Content&gt;
      &lt;/div&gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;


</code></pre>

<h2 id="state-key">state (Key)</h2>

<blockquote>
<p>복수의 앨리먼트를 생성할 때는 <code>key</code>라는 특수한 <code>props</code>를 사용해야 합니다. 여기서는 key의 사용법을 소개합니다.</p>
</blockquote>

<p>App.js</p>

<pre><code class="language-js">
import React, { Component } from &quot;react&quot;;
import logo from &quot;./logo.svg&quot;; //필요없다 현재
import TOC from &quot;./component/TOC&quot;;
import Subject from &quot;./component/subject&quot;;
import Content from &quot;./component/content&quot;;
import &quot;./App.css&quot;;

// App이라는 것이 Component 를 만들 것이다.
// App 는 render 라는 메소드를 가지고 있다.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      subject: { title: &quot;WEB&quot;, sub: &quot;world wide web!&quot; },
      contents: [
        // 1. contents 키값과 value 값으로 [] 만들고 그안에 내용을 적는다.
        { id: 1, title: &quot;HTML&quot;, desc: &quot;HTML is information&quot; },
        { id: 2, title: &quot;CSS&quot;, desc: &quot;CSS is information&quot; },
        { id: 3, title: &quot;JS&quot;, desc: &quot;JS is information&quot; }
      ]
    };
  }
  // 2.render() 메소드 안에 TOC data = {this.state.contents} 넣어준다.
  // 3.그리고 TOC component 로 이동한다.
  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;Subject
          title={this.state.subject.title}
          sub={this.state.subject.sub}
        &gt;&lt;/Subject&gt;
        &lt;TOC data={this.state.contents}&gt;&lt;/TOC&gt;
        &lt;Content
          title=&quot;HTML&quot;
          desc=&quot; HTML is HyperText Markup Language.&quot;
        &gt;&lt;/Content&gt;
      &lt;/div&gt;
    ); // class =  에서 calssName으로 바뀜
  }
}

export default App;


</code></pre>

<p>이전 TOC.js</p>

<pre><code class="language-js">

import React, { Component } from &quot;react&quot;;

class TOC extends Component {
  render() {
    return (
      &lt;nav&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href=&quot;1.html&quot;&gt;HTML&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;2.html&quot;&gt;CSS&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=&quot;3.html&quot;&gt;JavaScript&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    );
  }
}

export default TOC;



</code></pre>

<p>이후 TOC.js</p>

<pre><code class="language-js">


import React, { Component } from &quot;react&quot;;

class TOC extends Component {
  render() {
    var lists = [];
    var data = this.props.data; // &lt;TOC data={this.state.contents}&gt;&lt;/TOC&gt; 연결된다.
    var i = 0;
    // 여러게의 엘리먼트를 자동으로 생성할때 콘솔에 에러가 발생한다. 왜냐하면 각각의 목록에 키값을 주라는 것이다.
    // 이것은 react 가 필요로 하는 것이기 때문에 넣어 주어야 한다.
    // li tag 에 key 를 넣고 값은 App 의 프로퍼티에 있는 dt
    while (i &lt; data.length) {
      lists.push(
        &lt;li key={data[i].id}&gt;
          &lt;a href={&quot;/content/&quot; + data[i].id}&gt;{data[i].title}&lt;/a&gt;
        &lt;/li&gt;
      );
      i = i + 1;
    }

    return &lt;nav&gt;{lists}&lt;/nav&gt;;
  }
}

//     &lt;ul&gt;
//       &lt;li&gt;&lt;a href=&quot;1.html&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;
//       &lt;li&gt;&lt;a href=&quot;2.html&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;
//       &lt;li&gt;&lt;a href=&quot;3.html&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
//     &lt;/ul&gt;

export default TOC;



</code></pre>

          </div>

          

        </div>

        <div class="body-footer">
          Last updated on Jan 14, 2020
        </div>

      </article>

      <footer class="site-footer">
  
  <p class="powered-by">
    <a href="/privacy/">Privacy Policy</a>
  </p>
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
  </p>
</footer>


    </main>
  </div>
</div>

    

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
      

      
      
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.11384ce0c8c15291681687fbc4e0b90a.js"></script>

  </body>
</html>


